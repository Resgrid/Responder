diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/buildConfig/debug/com/rnmapbox/rnmbx/BuildConfig.java b/node_modules/@rnmapbox/maps/android/build/generated/source/buildConfig/debug/com/rnmapbox/rnmbx/BuildConfig.java
new file mode 100644
index 0000000..f8f7ad6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/buildConfig/debug/com/rnmapbox/rnmbx/BuildConfig.java
@@ -0,0 +1,12 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.rnmapbox.rnmbx;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String LIBRARY_PACKAGE_NAME = "com.rnmapbox.rnmbx";
+  public static final String BUILD_TYPE = "debug";
+  // Field from default config.
+  public static final boolean IS_NEW_ARCHITECTURE_ENABLED = true;
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXAtmosphereManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXAtmosphereManagerDelegate.java
new file mode 100644
index 0000000..342de06
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXAtmosphereManagerDelegate.java
@@ -0,0 +1,33 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXAtmosphereManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXAtmosphereManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXAtmosphereManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXAtmosphereManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXAtmosphereManagerInterface.java
new file mode 100644
index 0000000..4ca4850
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXAtmosphereManagerInterface.java
@@ -0,0 +1,18 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXAtmosphereManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXBackgroundLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXBackgroundLayerManagerDelegate.java
new file mode 100644
index 0000000..a7af3e0
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXBackgroundLayerManagerDelegate.java
@@ -0,0 +1,60 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXBackgroundLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXBackgroundLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXBackgroundLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXBackgroundLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXBackgroundLayerManagerInterface.java
new file mode 100644
index 0000000..6ac2e9e
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXBackgroundLayerManagerInterface.java
@@ -0,0 +1,27 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXBackgroundLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCalloutManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCalloutManagerDelegate.java
new file mode 100644
index 0000000..5f13e79
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCalloutManagerDelegate.java
@@ -0,0 +1,26 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXCalloutManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXCalloutManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXCalloutManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    super.setProperty(view, propName, value);
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCalloutManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCalloutManagerInterface.java
new file mode 100644
index 0000000..4c8e042
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCalloutManagerInterface.java
@@ -0,0 +1,17 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXCalloutManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  // No props
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraGestureObserverManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraGestureObserverManagerDelegate.java
new file mode 100644
index 0000000..18fb7c8
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraGestureObserverManagerDelegate.java
@@ -0,0 +1,39 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXCameraGestureObserverManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXCameraGestureObserverManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXCameraGestureObserverManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "quietPeriodMs":
+        mViewManager.setQuietPeriodMs(view, new DynamicFromObject(value));
+        break;
+      case "maxIntervalMs":
+        mViewManager.setMaxIntervalMs(view, new DynamicFromObject(value));
+        break;
+      case "hasOnMapSteady":
+        mViewManager.setHasOnMapSteady(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraGestureObserverManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraGestureObserverManagerInterface.java
new file mode 100644
index 0000000..9af62df
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraGestureObserverManagerInterface.java
@@ -0,0 +1,20 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXCameraGestureObserverManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setQuietPeriodMs(T view, Dynamic value);
+  void setMaxIntervalMs(T view, Dynamic value);
+  void setHasOnMapSteady(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraManagerDelegate.java
new file mode 100644
index 0000000..db3e9ce
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraManagerDelegate.java
@@ -0,0 +1,75 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXCameraManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXCameraManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXCameraManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "maxBounds":
+        mViewManager.setMaxBounds(view, new DynamicFromObject(value));
+        break;
+      case "animationDuration":
+        mViewManager.setAnimationDuration(view, new DynamicFromObject(value));
+        break;
+      case "animationMode":
+        mViewManager.setAnimationMode(view, new DynamicFromObject(value));
+        break;
+      case "defaultStop":
+        mViewManager.setDefaultStop(view, new DynamicFromObject(value));
+        break;
+      case "userTrackingMode":
+        mViewManager.setUserTrackingMode(view, new DynamicFromObject(value));
+        break;
+      case "followUserLocation":
+        mViewManager.setFollowUserLocation(view, new DynamicFromObject(value));
+        break;
+      case "followUserMode":
+        mViewManager.setFollowUserMode(view, new DynamicFromObject(value));
+        break;
+      case "followZoomLevel":
+        mViewManager.setFollowZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "followPitch":
+        mViewManager.setFollowPitch(view, new DynamicFromObject(value));
+        break;
+      case "followHeading":
+        mViewManager.setFollowHeading(view, new DynamicFromObject(value));
+        break;
+      case "followPadding":
+        mViewManager.setFollowPadding(view, new DynamicFromObject(value));
+        break;
+      case "zoomLevel":
+        mViewManager.setZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "stop":
+        mViewManager.setStop(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraManagerInterface.java
new file mode 100644
index 0000000..0460c4e
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCameraManagerInterface.java
@@ -0,0 +1,32 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXCameraManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setMaxBounds(T view, Dynamic value);
+  void setAnimationDuration(T view, Dynamic value);
+  void setAnimationMode(T view, Dynamic value);
+  void setDefaultStop(T view, Dynamic value);
+  void setUserTrackingMode(T view, Dynamic value);
+  void setFollowUserLocation(T view, Dynamic value);
+  void setFollowUserMode(T view, Dynamic value);
+  void setFollowZoomLevel(T view, Dynamic value);
+  void setFollowPitch(T view, Dynamic value);
+  void setFollowHeading(T view, Dynamic value);
+  void setFollowPadding(T view, Dynamic value);
+  void setZoomLevel(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setStop(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCircleLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCircleLayerManagerDelegate.java
new file mode 100644
index 0000000..4615522
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCircleLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXCircleLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXCircleLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXCircleLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCircleLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCircleLayerManagerInterface.java
new file mode 100644
index 0000000..7c8eae4
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCircleLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXCircleLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCustomLocationProviderManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCustomLocationProviderManagerDelegate.java
new file mode 100644
index 0000000..5d4d3ff
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCustomLocationProviderManagerDelegate.java
@@ -0,0 +1,36 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXCustomLocationProviderManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXCustomLocationProviderManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXCustomLocationProviderManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "coordinate":
+        mViewManager.setCoordinate(view, new DynamicFromObject(value));
+        break;
+      case "heading":
+        mViewManager.setHeading(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCustomLocationProviderManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCustomLocationProviderManagerInterface.java
new file mode 100644
index 0000000..da679d7
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXCustomLocationProviderManagerInterface.java
@@ -0,0 +1,19 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXCustomLocationProviderManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setCoordinate(T view, Dynamic value);
+  void setHeading(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillExtrusionLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillExtrusionLayerManagerDelegate.java
new file mode 100644
index 0000000..74d71ef
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillExtrusionLayerManagerDelegate.java
@@ -0,0 +1,63 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXFillExtrusionLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXFillExtrusionLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXFillExtrusionLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillExtrusionLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillExtrusionLayerManagerInterface.java
new file mode 100644
index 0000000..0f410f3
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillExtrusionLayerManagerInterface.java
@@ -0,0 +1,28 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXFillExtrusionLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillLayerManagerDelegate.java
new file mode 100644
index 0000000..51e36e4
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXFillLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXFillLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXFillLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillLayerManagerInterface.java
new file mode 100644
index 0000000..4bfd29d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXFillLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXFillLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXHeatmapLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXHeatmapLayerManagerDelegate.java
new file mode 100644
index 0000000..26227c1
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXHeatmapLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXHeatmapLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXHeatmapLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXHeatmapLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXHeatmapLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXHeatmapLayerManagerInterface.java
new file mode 100644
index 0000000..d4f58e2
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXHeatmapLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXHeatmapLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageManagerDelegate.java
new file mode 100644
index 0000000..9feed84
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageManagerDelegate.java
@@ -0,0 +1,48 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXImageManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXImageManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXImageManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "stretchX":
+        mViewManager.setStretchX(view, new DynamicFromObject(value));
+        break;
+      case "stretchY":
+        mViewManager.setStretchY(view, new DynamicFromObject(value));
+        break;
+      case "content":
+        mViewManager.setContent(view, new DynamicFromObject(value));
+        break;
+      case "sdf":
+        mViewManager.setSdf(view, new DynamicFromObject(value));
+        break;
+      case "name":
+        mViewManager.setName(view, new DynamicFromObject(value));
+        break;
+      case "scale":
+        mViewManager.setScale(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageManagerInterface.java
new file mode 100644
index 0000000..6dc6b3e
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageManagerInterface.java
@@ -0,0 +1,23 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXImageManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setStretchX(T view, Dynamic value);
+  void setStretchY(T view, Dynamic value);
+  void setContent(T view, Dynamic value);
+  void setSdf(T view, Dynamic value);
+  void setName(T view, Dynamic value);
+  void setScale(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageSourceManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageSourceManagerDelegate.java
new file mode 100644
index 0000000..a61516d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageSourceManagerDelegate.java
@@ -0,0 +1,42 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXImageSourceManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXImageSourceManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXImageSourceManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "url":
+        mViewManager.setUrl(view, new DynamicFromObject(value));
+        break;
+      case "coordinates":
+        mViewManager.setCoordinates(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageSourceManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageSourceManagerInterface.java
new file mode 100644
index 0000000..ed521ac
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImageSourceManagerInterface.java
@@ -0,0 +1,21 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXImageSourceManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setUrl(T view, Dynamic value);
+  void setCoordinates(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImagesManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImagesManagerDelegate.java
new file mode 100644
index 0000000..0e45f93
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImagesManagerDelegate.java
@@ -0,0 +1,39 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXImagesManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXImagesManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXImagesManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "images":
+        mViewManager.setImages(view, new DynamicFromObject(value));
+        break;
+      case "nativeImages":
+        mViewManager.setNativeImages(view, new DynamicFromObject(value));
+        break;
+      case "hasOnImageMissing":
+        mViewManager.setHasOnImageMissing(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImagesManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImagesManagerInterface.java
new file mode 100644
index 0000000..3549554
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXImagesManagerInterface.java
@@ -0,0 +1,20 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXImagesManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setImages(T view, Dynamic value);
+  void setNativeImages(T view, Dynamic value);
+  void setHasOnImageMissing(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLightManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLightManagerDelegate.java
new file mode 100644
index 0000000..2abdb45
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLightManagerDelegate.java
@@ -0,0 +1,33 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXLightManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXLightManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXLightManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLightManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLightManagerInterface.java
new file mode 100644
index 0000000..7412e34
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLightManagerInterface.java
@@ -0,0 +1,18 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXLightManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLineLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLineLayerManagerDelegate.java
new file mode 100644
index 0000000..8d57d8b
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLineLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXLineLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXLineLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXLineLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLineLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLineLayerManagerInterface.java
new file mode 100644
index 0000000..5d61ef8
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXLineLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXLineLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMapViewManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMapViewManagerDelegate.java
new file mode 100644
index 0000000..07dc39f
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMapViewManagerDelegate.java
@@ -0,0 +1,117 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXMapViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXMapViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXMapViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "attributionEnabled":
+        mViewManager.setAttributionEnabled(view, new DynamicFromObject(value));
+        break;
+      case "attributionPosition":
+        mViewManager.setAttributionPosition(view, new DynamicFromObject(value));
+        break;
+      case "logoEnabled":
+        mViewManager.setLogoEnabled(view, new DynamicFromObject(value));
+        break;
+      case "logoPosition":
+        mViewManager.setLogoPosition(view, new DynamicFromObject(value));
+        break;
+      case "compassEnabled":
+        mViewManager.setCompassEnabled(view, new DynamicFromObject(value));
+        break;
+      case "compassFadeWhenNorth":
+        mViewManager.setCompassFadeWhenNorth(view, new DynamicFromObject(value));
+        break;
+      case "compassPosition":
+        mViewManager.setCompassPosition(view, new DynamicFromObject(value));
+        break;
+      case "compassViewPosition":
+        mViewManager.setCompassViewPosition(view, new DynamicFromObject(value));
+        break;
+      case "compassViewMargins":
+        mViewManager.setCompassViewMargins(view, new DynamicFromObject(value));
+        break;
+      case "scaleBarEnabled":
+        mViewManager.setScaleBarEnabled(view, new DynamicFromObject(value));
+        break;
+      case "scaleBarPosition":
+        mViewManager.setScaleBarPosition(view, new DynamicFromObject(value));
+        break;
+      case "zoomEnabled":
+        mViewManager.setZoomEnabled(view, new DynamicFromObject(value));
+        break;
+      case "scrollEnabled":
+        mViewManager.setScrollEnabled(view, new DynamicFromObject(value));
+        break;
+      case "rotateEnabled":
+        mViewManager.setRotateEnabled(view, new DynamicFromObject(value));
+        break;
+      case "pitchEnabled":
+        mViewManager.setPitchEnabled(view, new DynamicFromObject(value));
+        break;
+      case "maxPitch":
+        mViewManager.setMaxPitch(view, new DynamicFromObject(value));
+        break;
+      case "deselectAnnotationOnTap":
+        mViewManager.setDeselectAnnotationOnTap(view, new DynamicFromObject(value));
+        break;
+      case "requestDisallowInterceptTouchEvent":
+        mViewManager.setRequestDisallowInterceptTouchEvent(view, new DynamicFromObject(value));
+        break;
+      case "projection":
+        mViewManager.setProjection(view, new DynamicFromObject(value));
+        break;
+      case "localizeLabels":
+        mViewManager.setLocalizeLabels(view, new DynamicFromObject(value));
+        break;
+      case "styleURL":
+        mViewManager.setStyleURL(view, new DynamicFromObject(value));
+        break;
+      case "gestureSettings":
+        mViewManager.setGestureSettings(view, new DynamicFromObject(value));
+        break;
+      case "surfaceView":
+        mViewManager.setSurfaceView(view, new DynamicFromObject(value));
+        break;
+      case "scaleBarViewMargins":
+        mViewManager.setScaleBarViewMargins(view, new DynamicFromObject(value));
+        break;
+      case "attributionViewMargins":
+        mViewManager.setAttributionViewMargins(view, new DynamicFromObject(value));
+        break;
+      case "attributionViewPosition":
+        mViewManager.setAttributionViewPosition(view, new DynamicFromObject(value));
+        break;
+      case "compassImage":
+        mViewManager.setCompassImage(view, new DynamicFromObject(value));
+        break;
+      case "mapViewImpl":
+        mViewManager.setMapViewImpl(view, new DynamicFromObject(value));
+        break;
+      case "preferredFramesPerSecond":
+        mViewManager.setPreferredFramesPerSecond(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMapViewManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMapViewManagerInterface.java
new file mode 100644
index 0000000..3a47dba
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMapViewManagerInterface.java
@@ -0,0 +1,46 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXMapViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setAttributionEnabled(T view, Dynamic value);
+  void setAttributionPosition(T view, Dynamic value);
+  void setLogoEnabled(T view, Dynamic value);
+  void setLogoPosition(T view, Dynamic value);
+  void setCompassEnabled(T view, Dynamic value);
+  void setCompassFadeWhenNorth(T view, Dynamic value);
+  void setCompassPosition(T view, Dynamic value);
+  void setCompassViewPosition(T view, Dynamic value);
+  void setCompassViewMargins(T view, Dynamic value);
+  void setScaleBarEnabled(T view, Dynamic value);
+  void setScaleBarPosition(T view, Dynamic value);
+  void setZoomEnabled(T view, Dynamic value);
+  void setScrollEnabled(T view, Dynamic value);
+  void setRotateEnabled(T view, Dynamic value);
+  void setPitchEnabled(T view, Dynamic value);
+  void setMaxPitch(T view, Dynamic value);
+  void setDeselectAnnotationOnTap(T view, Dynamic value);
+  void setRequestDisallowInterceptTouchEvent(T view, Dynamic value);
+  void setProjection(T view, Dynamic value);
+  void setLocalizeLabels(T view, Dynamic value);
+  void setStyleURL(T view, Dynamic value);
+  void setGestureSettings(T view, Dynamic value);
+  void setSurfaceView(T view, Dynamic value);
+  void setScaleBarViewMargins(T view, Dynamic value);
+  void setAttributionViewMargins(T view, Dynamic value);
+  void setAttributionViewPosition(T view, Dynamic value);
+  void setCompassImage(T view, Dynamic value);
+  void setMapViewImpl(T view, Dynamic value);
+  void setPreferredFramesPerSecond(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewContentManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewContentManagerDelegate.java
new file mode 100644
index 0000000..0b53e6e
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewContentManagerDelegate.java
@@ -0,0 +1,26 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXMarkerViewContentManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXMarkerViewContentManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXMarkerViewContentManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    super.setProperty(view, propName, value);
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewContentManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewContentManagerInterface.java
new file mode 100644
index 0000000..15a4c51
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewContentManagerInterface.java
@@ -0,0 +1,17 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXMarkerViewContentManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  // No props
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewManagerDelegate.java
new file mode 100644
index 0000000..1901060
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewManagerDelegate.java
@@ -0,0 +1,45 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXMarkerViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXMarkerViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXMarkerViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "coordinate":
+        mViewManager.setCoordinate(view, new DynamicFromObject(value));
+        break;
+      case "anchor":
+        mViewManager.setAnchor(view, new DynamicFromObject(value));
+        break;
+      case "allowOverlap":
+        mViewManager.setAllowOverlap(view, new DynamicFromObject(value));
+        break;
+      case "allowOverlapWithPuck":
+        mViewManager.setAllowOverlapWithPuck(view, new DynamicFromObject(value));
+        break;
+      case "isSelected":
+        mViewManager.setIsSelected(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewManagerInterface.java
new file mode 100644
index 0000000..d116d69
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXMarkerViewManagerInterface.java
@@ -0,0 +1,22 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXMarkerViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setCoordinate(T view, Dynamic value);
+  void setAnchor(T view, Dynamic value);
+  void setAllowOverlap(T view, Dynamic value);
+  void setAllowOverlapWithPuck(T view, Dynamic value);
+  void setIsSelected(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelLayerManagerDelegate.java
new file mode 100644
index 0000000..ffb987d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXModelLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXModelLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXModelLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelLayerManagerInterface.java
new file mode 100644
index 0000000..da992aa
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXModelLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelsManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelsManagerDelegate.java
new file mode 100644
index 0000000..9d0c149
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelsManagerDelegate.java
@@ -0,0 +1,33 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXModelsManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXModelsManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXModelsManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "models":
+        mViewManager.setModels(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelsManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelsManagerInterface.java
new file mode 100644
index 0000000..2888f2d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXModelsManagerInterface.java
@@ -0,0 +1,18 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXModelsManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setModels(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXNativeUserLocationManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXNativeUserLocationManagerDelegate.java
new file mode 100644
index 0000000..35caed4
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXNativeUserLocationManagerDelegate.java
@@ -0,0 +1,57 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXNativeUserLocationManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXNativeUserLocationManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXNativeUserLocationManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "androidRenderMode":
+        mViewManager.setAndroidRenderMode(view, new DynamicFromObject(value));
+        break;
+      case "puckBearing":
+        mViewManager.setPuckBearing(view, new DynamicFromObject(value));
+        break;
+      case "puckBearingEnabled":
+        mViewManager.setPuckBearingEnabled(view, new DynamicFromObject(value));
+        break;
+      case "bearingImage":
+        mViewManager.setBearingImage(view, new DynamicFromObject(value));
+        break;
+      case "shadowImage":
+        mViewManager.setShadowImage(view, new DynamicFromObject(value));
+        break;
+      case "topImage":
+        mViewManager.setTopImage(view, new DynamicFromObject(value));
+        break;
+      case "scale":
+        mViewManager.setScale(view, new DynamicFromObject(value));
+        break;
+      case "visible":
+        mViewManager.setVisible(view, value == null ? false : (boolean) value);
+        break;
+      case "pulsing":
+        mViewManager.setPulsing(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXNativeUserLocationManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXNativeUserLocationManagerInterface.java
new file mode 100644
index 0000000..0ef212d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXNativeUserLocationManagerInterface.java
@@ -0,0 +1,26 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXNativeUserLocationManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setAndroidRenderMode(T view, Dynamic value);
+  void setPuckBearing(T view, Dynamic value);
+  void setPuckBearingEnabled(T view, Dynamic value);
+  void setBearingImage(T view, Dynamic value);
+  void setShadowImage(T view, Dynamic value);
+  void setTopImage(T view, Dynamic value);
+  void setScale(T view, Dynamic value);
+  void setVisible(T view, boolean value);
+  void setPulsing(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXPointAnnotationManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXPointAnnotationManagerDelegate.java
new file mode 100644
index 0000000..950dc3b
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXPointAnnotationManagerDelegate.java
@@ -0,0 +1,42 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXPointAnnotationManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXPointAnnotationManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXPointAnnotationManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "coordinate":
+        mViewManager.setCoordinate(view, new DynamicFromObject(value));
+        break;
+      case "draggable":
+        mViewManager.setDraggable(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "anchor":
+        mViewManager.setAnchor(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXPointAnnotationManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXPointAnnotationManagerInterface.java
new file mode 100644
index 0000000..2cceb2f
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXPointAnnotationManagerInterface.java
@@ -0,0 +1,21 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXPointAnnotationManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setCoordinate(T view, Dynamic value);
+  void setDraggable(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setAnchor(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterArraySourceManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterArraySourceManagerDelegate.java
new file mode 100644
index 0000000..72fc102
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterArraySourceManagerDelegate.java
@@ -0,0 +1,54 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXRasterArraySourceManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXRasterArraySourceManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXRasterArraySourceManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "url":
+        mViewManager.setUrl(view, new DynamicFromObject(value));
+        break;
+      case "tileUrlTemplates":
+        mViewManager.setTileUrlTemplates(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "tileSize":
+        mViewManager.setTileSize(view, new DynamicFromObject(value));
+        break;
+      case "sourceBounds":
+        mViewManager.setSourceBounds(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterArraySourceManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterArraySourceManagerInterface.java
new file mode 100644
index 0000000..075114f
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterArraySourceManagerInterface.java
@@ -0,0 +1,25 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXRasterArraySourceManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setUrl(T view, Dynamic value);
+  void setTileUrlTemplates(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setTileSize(T view, Dynamic value);
+  void setSourceBounds(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterDemSourceManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterDemSourceManagerDelegate.java
new file mode 100644
index 0000000..5fac0a3
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterDemSourceManagerDelegate.java
@@ -0,0 +1,51 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXRasterDemSourceManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXRasterDemSourceManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXRasterDemSourceManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "url":
+        mViewManager.setUrl(view, new DynamicFromObject(value));
+        break;
+      case "tileUrlTemplates":
+        mViewManager.setTileUrlTemplates(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "tileSize":
+        mViewManager.setTileSize(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterDemSourceManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterDemSourceManagerInterface.java
new file mode 100644
index 0000000..3e19ea1
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterDemSourceManagerInterface.java
@@ -0,0 +1,24 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXRasterDemSourceManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setUrl(T view, Dynamic value);
+  void setTileUrlTemplates(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setTileSize(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterLayerManagerDelegate.java
new file mode 100644
index 0000000..80776b6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXRasterLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXRasterLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXRasterLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterLayerManagerInterface.java
new file mode 100644
index 0000000..b992efa
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXRasterLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterParticleLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterParticleLayerManagerDelegate.java
new file mode 100644
index 0000000..60330aa
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterParticleLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXRasterParticleLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXRasterParticleLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXRasterParticleLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterParticleLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterParticleLayerManagerInterface.java
new file mode 100644
index 0000000..e3db378
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterParticleLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXRasterParticleLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterSourceManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterSourceManagerDelegate.java
new file mode 100644
index 0000000..3681a0b
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterSourceManagerDelegate.java
@@ -0,0 +1,60 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXRasterSourceManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXRasterSourceManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXRasterSourceManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "url":
+        mViewManager.setUrl(view, new DynamicFromObject(value));
+        break;
+      case "tileUrlTemplates":
+        mViewManager.setTileUrlTemplates(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "tileSize":
+        mViewManager.setTileSize(view, new DynamicFromObject(value));
+        break;
+      case "tms":
+        mViewManager.setTms(view, new DynamicFromObject(value));
+        break;
+      case "attribution":
+        mViewManager.setAttribution(view, new DynamicFromObject(value));
+        break;
+      case "sourceBounds":
+        mViewManager.setSourceBounds(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterSourceManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterSourceManagerInterface.java
new file mode 100644
index 0000000..c566f07
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXRasterSourceManagerInterface.java
@@ -0,0 +1,27 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXRasterSourceManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setUrl(T view, Dynamic value);
+  void setTileUrlTemplates(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setTileSize(T view, Dynamic value);
+  void setTms(T view, Dynamic value);
+  void setAttribution(T view, Dynamic value);
+  void setSourceBounds(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXShapeSourceManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXShapeSourceManagerDelegate.java
new file mode 100644
index 0000000..c780e69
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXShapeSourceManagerDelegate.java
@@ -0,0 +1,72 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXShapeSourceManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXShapeSourceManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXShapeSourceManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "url":
+        mViewManager.setUrl(view, new DynamicFromObject(value));
+        break;
+      case "shape":
+        mViewManager.setShape(view, new DynamicFromObject(value));
+        break;
+      case "cluster":
+        mViewManager.setCluster(view, new DynamicFromObject(value));
+        break;
+      case "clusterRadius":
+        mViewManager.setClusterRadius(view, new DynamicFromObject(value));
+        break;
+      case "clusterMaxZoomLevel":
+        mViewManager.setClusterMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "clusterProperties":
+        mViewManager.setClusterProperties(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "buffer":
+        mViewManager.setBuffer(view, new DynamicFromObject(value));
+        break;
+      case "tolerance":
+        mViewManager.setTolerance(view, new DynamicFromObject(value));
+        break;
+      case "lineMetrics":
+        mViewManager.setLineMetrics(view, new DynamicFromObject(value));
+        break;
+      case "hasPressListener":
+        mViewManager.setHasPressListener(view, new DynamicFromObject(value));
+        break;
+      case "hitbox":
+        mViewManager.setHitbox(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXShapeSourceManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXShapeSourceManagerInterface.java
new file mode 100644
index 0000000..6a15c2b
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXShapeSourceManagerInterface.java
@@ -0,0 +1,31 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXShapeSourceManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setUrl(T view, Dynamic value);
+  void setShape(T view, Dynamic value);
+  void setCluster(T view, Dynamic value);
+  void setClusterRadius(T view, Dynamic value);
+  void setClusterMaxZoomLevel(T view, Dynamic value);
+  void setClusterProperties(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setBuffer(T view, Dynamic value);
+  void setTolerance(T view, Dynamic value);
+  void setLineMetrics(T view, Dynamic value);
+  void setHasPressListener(T view, Dynamic value);
+  void setHitbox(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSkyLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSkyLayerManagerDelegate.java
new file mode 100644
index 0000000..2cda3e9
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSkyLayerManagerDelegate.java
@@ -0,0 +1,60 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXSkyLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXSkyLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXSkyLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSkyLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSkyLayerManagerInterface.java
new file mode 100644
index 0000000..3f42220
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSkyLayerManagerInterface.java
@@ -0,0 +1,27 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXSkyLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXStyleImportManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXStyleImportManagerDelegate.java
new file mode 100644
index 0000000..d6eaf98
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXStyleImportManagerDelegate.java
@@ -0,0 +1,39 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXStyleImportManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXStyleImportManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXStyleImportManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, value == null ? null : (String) value);
+        break;
+      case "existing":
+        mViewManager.setExisting(view, value == null ? false : (boolean) value);
+        break;
+      case "config":
+        mViewManager.setConfig(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXStyleImportManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXStyleImportManagerInterface.java
new file mode 100644
index 0000000..323c65a
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXStyleImportManagerInterface.java
@@ -0,0 +1,21 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXStyleImportManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, @Nullable String value);
+  void setExisting(T view, boolean value);
+  void setConfig(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSymbolLayerManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSymbolLayerManagerDelegate.java
new file mode 100644
index 0000000..ca81653
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSymbolLayerManagerDelegate.java
@@ -0,0 +1,66 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXSymbolLayerManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXSymbolLayerManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXSymbolLayerManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "filter":
+        mViewManager.setFilter(view, new DynamicFromObject(value));
+        break;
+      case "aboveLayerID":
+        mViewManager.setAboveLayerID(view, new DynamicFromObject(value));
+        break;
+      case "belowLayerID":
+        mViewManager.setBelowLayerID(view, new DynamicFromObject(value));
+        break;
+      case "layerIndex":
+        mViewManager.setLayerIndex(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "sourceLayerID":
+        mViewManager.setSourceLayerID(view, new DynamicFromObject(value));
+        break;
+      case "slot":
+        mViewManager.setSlot(view, new DynamicFromObject(value));
+        break;
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSymbolLayerManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSymbolLayerManagerInterface.java
new file mode 100644
index 0000000..fa2b754
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXSymbolLayerManagerInterface.java
@@ -0,0 +1,29 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXSymbolLayerManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setFilter(T view, Dynamic value);
+  void setAboveLayerID(T view, Dynamic value);
+  void setBelowLayerID(T view, Dynamic value);
+  void setLayerIndex(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setSourceLayerID(T view, Dynamic value);
+  void setSlot(T view, Dynamic value);
+  void setId(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXTerrainManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXTerrainManagerDelegate.java
new file mode 100644
index 0000000..89a55a8
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXTerrainManagerDelegate.java
@@ -0,0 +1,36 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXTerrainManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXTerrainManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXTerrainManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "sourceID":
+        mViewManager.setSourceID(view, new DynamicFromObject(value));
+        break;
+      case "reactStyle":
+        mViewManager.setReactStyle(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXTerrainManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXTerrainManagerInterface.java
new file mode 100644
index 0000000..f23b719
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXTerrainManagerInterface.java
@@ -0,0 +1,19 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXTerrainManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setSourceID(T view, Dynamic value);
+  void setReactStyle(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXVectorSourceManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXVectorSourceManagerDelegate.java
new file mode 100644
index 0000000..7252671
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXVectorSourceManagerDelegate.java
@@ -0,0 +1,60 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXVectorSourceManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXVectorSourceManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXVectorSourceManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "id":
+        mViewManager.setId(view, new DynamicFromObject(value));
+        break;
+      case "existing":
+        mViewManager.setExisting(view, new DynamicFromObject(value));
+        break;
+      case "url":
+        mViewManager.setUrl(view, new DynamicFromObject(value));
+        break;
+      case "tileUrlTemplates":
+        mViewManager.setTileUrlTemplates(view, new DynamicFromObject(value));
+        break;
+      case "attribution":
+        mViewManager.setAttribution(view, new DynamicFromObject(value));
+        break;
+      case "maxZoomLevel":
+        mViewManager.setMaxZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "minZoomLevel":
+        mViewManager.setMinZoomLevel(view, new DynamicFromObject(value));
+        break;
+      case "tms":
+        mViewManager.setTms(view, new DynamicFromObject(value));
+        break;
+      case "hasPressListener":
+        mViewManager.setHasPressListener(view, new DynamicFromObject(value));
+        break;
+      case "hitbox":
+        mViewManager.setHitbox(view, new DynamicFromObject(value));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXVectorSourceManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXVectorSourceManagerInterface.java
new file mode 100644
index 0000000..739c6cd
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXVectorSourceManagerInterface.java
@@ -0,0 +1,27 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXVectorSourceManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setId(T view, Dynamic value);
+  void setExisting(T view, Dynamic value);
+  void setUrl(T view, Dynamic value);
+  void setTileUrlTemplates(T view, Dynamic value);
+  void setAttribution(T view, Dynamic value);
+  void setMaxZoomLevel(T view, Dynamic value);
+  void setMinZoomLevel(T view, Dynamic value);
+  void setTms(T view, Dynamic value);
+  void setHasPressListener(T view, Dynamic value);
+  void setHitbox(T view, Dynamic value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXViewportManagerDelegate.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXViewportManagerDelegate.java
new file mode 100644
index 0000000..c652f46
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXViewportManagerDelegate.java
@@ -0,0 +1,36 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.DynamicFromObject;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class RNMBXViewportManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & RNMBXViewportManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public RNMBXViewportManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "transitionsToIdleUponUserInteraction":
+        mViewManager.setTransitionsToIdleUponUserInteraction(view, new DynamicFromObject(value));
+        break;
+      case "hasStatusChanged":
+        mViewManager.setHasStatusChanged(view, value == null ? false : (boolean) value);
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXViewportManagerInterface.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXViewportManagerInterface.java
new file mode 100644
index 0000000..408680e
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/facebook/react/viewmanagers/RNMBXViewportManagerInterface.java
@@ -0,0 +1,19 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface RNMBXViewportManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setTransitionsToIdleUponUserInteraction(T view, Dynamic value);
+  void setHasStatusChanged(T view, boolean value);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeMapViewModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeMapViewModuleSpec.java
new file mode 100644
index 0000000..59e5df3
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeMapViewModuleSpec.java
@@ -0,0 +1,101 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeMapViewModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXMapViewModule";
+
+  public NativeMapViewModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void takeSnap(@Nullable Double viewRef, boolean writeToDisk, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void queryTerrainElevation(@Nullable Double viewRef, ReadableArray coordinates, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setSourceVisibility(@Nullable Double viewRef, boolean visible, String sourceId, String sourceLayerId, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCenter(@Nullable Double viewRef, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCoordinateFromView(@Nullable Double viewRef, ReadableArray atPoint, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getPointInView(@Nullable Double viewRef, ReadableArray atCoordinate, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getZoom(@Nullable Double viewRef, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getVisibleBounds(@Nullable Double viewRef, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void queryRenderedFeaturesAtPoint(@Nullable Double viewRef, ReadableArray atPoint, ReadableArray withFilter, ReadableArray withLayerIDs, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void queryRenderedFeaturesInRect(@Nullable Double viewRef, ReadableArray withBBox, ReadableArray withFilter, ReadableArray withLayerIDs, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setHandledMapChangedEvents(@Nullable Double viewRef, ReadableArray events, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void clearData(@Nullable Double viewRef, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void querySourceFeatures(@Nullable Double viewRef, String sourceId, ReadableArray withFilter, ReadableArray withSourceLayerIDs, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setFeatureState(@Nullable Double viewRef, String featureId, ReadableMap state, String sourceId, @Nullable String sourceLayerId, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getFeatureState(@Nullable Double viewRef, String featureId, String sourceId, @Nullable String sourceLayerId, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeFeatureState(@Nullable Double viewRef, String featureId, @Nullable String stateKey, String sourceId, @Nullable String sourceLayerId, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXCameraModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXCameraModuleSpec.java
new file mode 100644
index 0000000..282288d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXCameraModuleSpec.java
@@ -0,0 +1,48 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeRNMBXCameraModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXCameraModule";
+
+  public NativeRNMBXCameraModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void updateCameraStop(@Nullable Double viewRef, ReadableMap stop, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void moveBy(@Nullable Double viewRef, double x, double y, double animationMode, double animationDuration, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void scaleBy(@Nullable Double viewRef, double x, double y, double animationMode, double animationDuration, double scaleFactor, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpec.java
new file mode 100644
index 0000000..3f32e1a
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpec.java
@@ -0,0 +1,51 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXChangeLineOffsetsShapeAnimatorModule";
+
+  public NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void generate(double tag, ReadableArray coordinates, double startOffset, double endOffset, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setLineString(double tag, ReadableArray coordinates, double startOffset, double endOffset, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setStartOffset(double tag, double offset, double duration, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setEndOffset(double tag, double offset, double duration, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXImageModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXImageModuleSpec.java
new file mode 100644
index 0000000..942ea74
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXImageModuleSpec.java
@@ -0,0 +1,39 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeRNMBXImageModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXImageModule";
+
+  public NativeRNMBXImageModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void refresh(@Nullable Double viewRef, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXLocationModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXLocationModuleSpec.java
new file mode 100644
index 0000000..693488d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXLocationModuleSpec.java
@@ -0,0 +1,67 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeRNMBXLocationModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXLocationModule";
+
+  public NativeRNMBXLocationModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected final void emitOnLocationUpdate(ReadableMap value) {
+    mEventEmitterCallback.invoke("onLocationUpdate", value);
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void start(double minDisplacement);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void stop();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setRequestsAlwaysUse(boolean requestsAlwaysUse);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setMinDisplacement(double minDisplacement);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getLastKnownLocation(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void simulateHeading(double changesPerSecond, double increment);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setLocationEventThrottle(double throttle);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXMovePointShapeAnimatorModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXMovePointShapeAnimatorModuleSpec.java
new file mode 100644
index 0000000..b9a0497
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXMovePointShapeAnimatorModuleSpec.java
@@ -0,0 +1,43 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeRNMBXMovePointShapeAnimatorModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXMovePointShapeAnimatorModule";
+
+  public NativeRNMBXMovePointShapeAnimatorModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void generate(double tag, ReadableArray coordinate, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void moveTo(double tag, ReadableArray coordinate, double duration, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXPointAnnotationModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXPointAnnotationModuleSpec.java
new file mode 100644
index 0000000..195a10a
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXPointAnnotationModuleSpec.java
@@ -0,0 +1,39 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeRNMBXPointAnnotationModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXPointAnnotationModule";
+
+  public NativeRNMBXPointAnnotationModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void refresh(@Nullable Double viewRef, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXShapeSourceModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXShapeSourceModuleSpec.java
new file mode 100644
index 0000000..4b7bc27
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXShapeSourceModuleSpec.java
@@ -0,0 +1,47 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeRNMBXShapeSourceModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXShapeSourceModule";
+
+  public NativeRNMBXShapeSourceModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getClusterExpansionZoom(@Nullable Double viewRef, String featureJSON, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getClusterLeaves(@Nullable Double viewRef, String featureJSON, double number, double offset, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getClusterChildren(@Nullable Double viewRef, String featureJSON, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXTileStoreModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXTileStoreModuleSpec.java
new file mode 100644
index 0000000..1153db1
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXTileStoreModuleSpec.java
@@ -0,0 +1,44 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeRNMBXTileStoreModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXTileStoreModule";
+
+  public NativeRNMBXTileStoreModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void shared(@Nullable String path, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setOption(double tag, String key, String domain, ReadableMap value, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXViewportModuleSpec.java b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXViewportModuleSpec.java
new file mode 100644
index 0000000..bdc8339
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/java/com/rnmapbox/rnmbx/NativeRNMBXViewportModuleSpec.java
@@ -0,0 +1,48 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.rnmapbox.rnmbx;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeRNMBXViewportModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RNMBXViewportModule";
+
+  public NativeRNMBXViewportModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getState(@Nullable Double viewRef, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void transitionTo(@Nullable Double viewRef, ReadableMap state, ReadableMap transition, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void idle(@Nullable Double viewRef, Promise promise);
+}
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/CMakeLists.txt b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/CMakeLists.txt
new file mode 100644
index 0000000..6fae723
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/CMakeLists.txt
@@ -0,0 +1,36 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+cmake_minimum_required(VERSION 3.13)
+set(CMAKE_VERBOSE_MAKEFILE on)
+
+file(GLOB react_codegen_SRCS CONFIGURE_DEPENDS *.cpp react/renderer/components/rnmapbox_maps_specs/*.cpp)
+
+add_library(
+  react_codegen_rnmapbox_maps_specs
+  OBJECT
+  ${react_codegen_SRCS}
+)
+
+target_include_directories(react_codegen_rnmapbox_maps_specs PUBLIC . react/renderer/components/rnmapbox_maps_specs)
+
+target_link_libraries(
+  react_codegen_rnmapbox_maps_specs
+  fbjni
+  jsi
+  # We need to link different libraries based on whether we are building rncore or not, that's necessary
+  # because we want to break a circular dependency between react_codegen_rncore and reactnative
+  reactnative
+)
+
+target_compile_options(
+  react_codegen_rnmapbox_maps_specs
+  PRIVATE
+  -DLOG_TAG=\"ReactNative\"
+  -fexceptions
+  -frtti
+  -std=c++20
+  -Wall
+)
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.cpp
new file mode 100644
index 0000000..9076492
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.cpp
@@ -0,0 +1,55 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorCpp.js
+ */
+
+#include <react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+void rnmapbox_maps_specs_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry) {
+registry->add(concreteComponentDescriptorProvider<RNMBXAtmosphereComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXBackgroundLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXCalloutComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXCameraGestureObserverComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXCameraComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXCircleLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXCustomLocationProviderComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXFillExtrusionLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXFillLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXHeatmapLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXImageComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXImagesComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXImageSourceComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXLightComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXLineLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXMapViewComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXMarkerViewContentComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXMarkerViewComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXModelLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXModelsComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXNativeUserLocationComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXPointAnnotationComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXRasterArraySourceComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXRasterDemSourceComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXRasterLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXRasterParticleLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXRasterSourceComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXShapeSourceComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXSkyLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXStyleImportComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXSymbolLayerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXTerrainComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXVectorSourceComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMBXViewportComponentDescriptor>());
+}
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.h
new file mode 100644
index 0000000..0aeb5ed
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ComponentDescriptors.h
@@ -0,0 +1,57 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/rnmapbox_maps_specs/ShadowNodes.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+using RNMBXAtmosphereComponentDescriptor = ConcreteComponentDescriptor<RNMBXAtmosphereShadowNode>;
+using RNMBXBackgroundLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXBackgroundLayerShadowNode>;
+using RNMBXCalloutComponentDescriptor = ConcreteComponentDescriptor<RNMBXCalloutShadowNode>;
+using RNMBXCameraGestureObserverComponentDescriptor = ConcreteComponentDescriptor<RNMBXCameraGestureObserverShadowNode>;
+using RNMBXCameraComponentDescriptor = ConcreteComponentDescriptor<RNMBXCameraShadowNode>;
+using RNMBXCircleLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXCircleLayerShadowNode>;
+using RNMBXCustomLocationProviderComponentDescriptor = ConcreteComponentDescriptor<RNMBXCustomLocationProviderShadowNode>;
+using RNMBXFillExtrusionLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXFillExtrusionLayerShadowNode>;
+using RNMBXFillLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXFillLayerShadowNode>;
+using RNMBXHeatmapLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXHeatmapLayerShadowNode>;
+using RNMBXImageComponentDescriptor = ConcreteComponentDescriptor<RNMBXImageShadowNode>;
+using RNMBXImagesComponentDescriptor = ConcreteComponentDescriptor<RNMBXImagesShadowNode>;
+using RNMBXImageSourceComponentDescriptor = ConcreteComponentDescriptor<RNMBXImageSourceShadowNode>;
+using RNMBXLightComponentDescriptor = ConcreteComponentDescriptor<RNMBXLightShadowNode>;
+using RNMBXLineLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXLineLayerShadowNode>;
+using RNMBXMapViewComponentDescriptor = ConcreteComponentDescriptor<RNMBXMapViewShadowNode>;
+using RNMBXMarkerViewContentComponentDescriptor = ConcreteComponentDescriptor<RNMBXMarkerViewContentShadowNode>;
+using RNMBXMarkerViewComponentDescriptor = ConcreteComponentDescriptor<RNMBXMarkerViewShadowNode>;
+using RNMBXModelLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXModelLayerShadowNode>;
+using RNMBXModelsComponentDescriptor = ConcreteComponentDescriptor<RNMBXModelsShadowNode>;
+using RNMBXNativeUserLocationComponentDescriptor = ConcreteComponentDescriptor<RNMBXNativeUserLocationShadowNode>;
+using RNMBXPointAnnotationComponentDescriptor = ConcreteComponentDescriptor<RNMBXPointAnnotationShadowNode>;
+using RNMBXRasterArraySourceComponentDescriptor = ConcreteComponentDescriptor<RNMBXRasterArraySourceShadowNode>;
+using RNMBXRasterDemSourceComponentDescriptor = ConcreteComponentDescriptor<RNMBXRasterDemSourceShadowNode>;
+using RNMBXRasterLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXRasterLayerShadowNode>;
+using RNMBXRasterParticleLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXRasterParticleLayerShadowNode>;
+using RNMBXRasterSourceComponentDescriptor = ConcreteComponentDescriptor<RNMBXRasterSourceShadowNode>;
+using RNMBXShapeSourceComponentDescriptor = ConcreteComponentDescriptor<RNMBXShapeSourceShadowNode>;
+using RNMBXSkyLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXSkyLayerShadowNode>;
+using RNMBXStyleImportComponentDescriptor = ConcreteComponentDescriptor<RNMBXStyleImportShadowNode>;
+using RNMBXSymbolLayerComponentDescriptor = ConcreteComponentDescriptor<RNMBXSymbolLayerShadowNode>;
+using RNMBXTerrainComponentDescriptor = ConcreteComponentDescriptor<RNMBXTerrainShadowNode>;
+using RNMBXVectorSourceComponentDescriptor = ConcreteComponentDescriptor<RNMBXVectorSourceShadowNode>;
+using RNMBXViewportComponentDescriptor = ConcreteComponentDescriptor<RNMBXViewportShadowNode>;
+
+void rnmapbox_maps_specs_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry);
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/EventEmitters.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/EventEmitters.cpp
new file mode 100644
index 0000000..6843f29
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/EventEmitters.cpp
@@ -0,0 +1,202 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterCpp.js
+ */
+
+#include <react/renderer/components/rnmapbox_maps_specs/EventEmitters.h>
+
+
+namespace facebook::react {
+
+
+
+
+void RNMBXCameraGestureObserverEventEmitter::onMapSteady(OnMapSteady $event) const {
+  dispatchEvent("mapSteady", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "reason", toString($event.reason));
+$payload.setProperty(runtime, "idleDurationMs", $event.idleDurationMs);
+$payload.setProperty(runtime, "lastGestureType", $event.lastGestureType);
+$payload.setProperty(runtime, "timestamp", $event.timestamp);
+    return $payload;
+  });
+}
+
+
+void RNMBXCameraEventEmitter::onUserTrackingModeChange(OnUserTrackingModeChange $event) const {
+  dispatchEvent("userTrackingModeChange", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+{
+  auto payloadRenamed = jsi::Object(runtime);
+  payloadRenamed.setProperty(runtime, "followUserLocation", $event.payloadRenamed.followUserLocation);
+  payloadRenamed.setProperty(runtime, "followUserMode", $event.payloadRenamed.followUserMode);
+  $payload.setProperty(runtime, "payloadRenamed", payloadRenamed);
+}
+    return $payload;
+  });
+}
+
+
+
+
+
+
+
+
+void RNMBXImagesEventEmitter::onImageMissing(OnImageMissing $event) const {
+  dispatchEvent("imageMissing", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+{
+  auto payloadRenamed = jsi::Object(runtime);
+  payloadRenamed.setProperty(runtime, "imageKey", $event.payloadRenamed.imageKey);
+  $payload.setProperty(runtime, "payloadRenamed", payloadRenamed);
+}
+    return $payload;
+  });
+}
+
+
+
+
+
+void RNMBXMapViewEventEmitter::onPress(OnPress $event) const {
+  dispatchEvent("press", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXMapViewEventEmitter::onLongPress(OnLongPress $event) const {
+  dispatchEvent("longPress", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXMapViewEventEmitter::onMapChange(OnMapChange $event) const {
+  dispatchEvent("mapChange", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXMapViewEventEmitter::onCameraChanged(OnCameraChanged $event) const {
+  dispatchEvent("cameraChanged", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+
+
+
+
+
+void RNMBXPointAnnotationEventEmitter::onMapboxPointAnnotationDeselected(OnMapboxPointAnnotationDeselected $event) const {
+  dispatchEvent("mapboxPointAnnotationDeselected", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXPointAnnotationEventEmitter::onMapboxPointAnnotationDrag(OnMapboxPointAnnotationDrag $event) const {
+  dispatchEvent("mapboxPointAnnotationDrag", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXPointAnnotationEventEmitter::onMapboxPointAnnotationDragEnd(OnMapboxPointAnnotationDragEnd $event) const {
+  dispatchEvent("mapboxPointAnnotationDragEnd", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXPointAnnotationEventEmitter::onMapboxPointAnnotationDragStart(OnMapboxPointAnnotationDragStart $event) const {
+  dispatchEvent("mapboxPointAnnotationDragStart", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXPointAnnotationEventEmitter::onMapboxPointAnnotationSelected(OnMapboxPointAnnotationSelected $event) const {
+  dispatchEvent("mapboxPointAnnotationSelected", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+
+
+
+
+
+void RNMBXShapeSourceEventEmitter::onMapboxShapeSourcePress(OnMapboxShapeSourcePress $event) const {
+  dispatchEvent("mapboxShapeSourcePress", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+
+
+
+
+void RNMBXVectorSourceEventEmitter::onMapboxVectorSourcePress(OnMapboxVectorSourcePress $event) const {
+  dispatchEvent("mapboxVectorSourcePress", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+
+void RNMBXViewportEventEmitter::onStatusChanged(OnStatusChanged $event) const {
+  dispatchEvent("statusChanged", [$event=std::move($event)](jsi::Runtime &runtime) {
+    auto $payload = jsi::Object(runtime);
+    $payload.setProperty(runtime, "type", $event.type);
+$payload.setProperty(runtime, "payload", $event.payload);
+    return $payload;
+  });
+}
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/EventEmitters.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/EventEmitters.h
new file mode 100644
index 0000000..714d019
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/EventEmitters.h
@@ -0,0 +1,350 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewEventEmitter.h>
+
+
+namespace facebook::react {
+class RNMBXAtmosphereEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXBackgroundLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXCalloutEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXCameraGestureObserverEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  enum class OnMapSteadyReason {
+    Steady,
+    Timeout
+  };
+
+  static char const *toString(const OnMapSteadyReason value) {
+    switch (value) {
+      case OnMapSteadyReason::Steady: return "steady";
+      case OnMapSteadyReason::Timeout: return "timeout";
+    }
+  }
+
+  struct OnMapSteady {
+      OnMapSteadyReason reason;
+    double idleDurationMs;
+    std::string lastGestureType;
+    double timestamp;
+    };
+  void onMapSteady(OnMapSteady value) const;
+};
+class RNMBXCameraEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnUserTrackingModeChangePayloadRenamed {
+      bool followUserLocation;
+    std::string followUserMode;
+    };
+
+  struct OnUserTrackingModeChange {
+      std::string type;
+    OnUserTrackingModeChangePayloadRenamed payloadRenamed;
+    };
+  void onUserTrackingModeChange(OnUserTrackingModeChange value) const;
+};
+class RNMBXCircleLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXCustomLocationProviderEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXFillExtrusionLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXFillLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXHeatmapLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXImageEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXImagesEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnImageMissingPayloadRenamed {
+      std::string imageKey;
+    };
+
+  struct OnImageMissing {
+      std::string type;
+    OnImageMissingPayloadRenamed payloadRenamed;
+    };
+  void onImageMissing(OnImageMissing value) const;
+};
+class RNMBXImageSourceEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXLightEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXLineLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXMapViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnPress {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnLongPress {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnMapChange {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnCameraChanged {
+      std::string type;
+    std::string payload;
+    };
+  void onPress(OnPress value) const;
+
+  void onLongPress(OnLongPress value) const;
+
+  void onMapChange(OnMapChange value) const;
+
+  void onCameraChanged(OnCameraChanged value) const;
+};
+class RNMBXMarkerViewContentEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXMarkerViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXModelLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXModelsEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXNativeUserLocationEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXPointAnnotationEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnMapboxPointAnnotationDeselected {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnMapboxPointAnnotationDrag {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnMapboxPointAnnotationDragEnd {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnMapboxPointAnnotationDragStart {
+      std::string type;
+    std::string payload;
+    };
+
+  struct OnMapboxPointAnnotationSelected {
+      std::string type;
+    std::string payload;
+    };
+  void onMapboxPointAnnotationDeselected(OnMapboxPointAnnotationDeselected value) const;
+
+  void onMapboxPointAnnotationDrag(OnMapboxPointAnnotationDrag value) const;
+
+  void onMapboxPointAnnotationDragEnd(OnMapboxPointAnnotationDragEnd value) const;
+
+  void onMapboxPointAnnotationDragStart(OnMapboxPointAnnotationDragStart value) const;
+
+  void onMapboxPointAnnotationSelected(OnMapboxPointAnnotationSelected value) const;
+};
+class RNMBXRasterArraySourceEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXRasterDemSourceEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXRasterLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXRasterParticleLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXRasterSourceEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXShapeSourceEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnMapboxShapeSourcePress {
+      std::string type;
+    std::string payload;
+    };
+  void onMapboxShapeSourcePress(OnMapboxShapeSourcePress value) const;
+};
+class RNMBXSkyLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXStyleImportEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXSymbolLayerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXTerrainEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMBXVectorSourceEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnMapboxVectorSourcePress {
+      std::string type;
+    std::string payload;
+    };
+  void onMapboxVectorSourcePress(OnMapboxVectorSourcePress value) const;
+};
+class RNMBXViewportEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnStatusChanged {
+      std::string type;
+    std::string payload;
+    };
+  void onStatusChanged(OnStatusChanged value) const;
+};
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/Props.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/Props.cpp
new file mode 100644
index 0000000..fabf5e9
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/Props.cpp
@@ -0,0 +1,491 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsCpp.js
+ */
+
+#include <react/renderer/components/rnmapbox_maps_specs/Props.h>
+#include <folly/dynamic.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/core/propsConversions.h>
+
+namespace facebook::react {
+
+RNMBXAtmosphereProps::RNMBXAtmosphereProps(
+    const PropsParserContext &context,
+    const RNMBXAtmosphereProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXBackgroundLayerProps::RNMBXBackgroundLayerProps(
+    const PropsParserContext &context,
+    const RNMBXBackgroundLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {}))
+      {}
+RNMBXCalloutProps::RNMBXCalloutProps(
+    const PropsParserContext &context,
+    const RNMBXCalloutProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps)
+
+    
+      {}
+RNMBXCameraGestureObserverProps::RNMBXCameraGestureObserverProps(
+    const PropsParserContext &context,
+    const RNMBXCameraGestureObserverProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    quietPeriodMs(convertRawProp(context, rawProps, "quietPeriodMs", sourceProps.quietPeriodMs, {})),
+    maxIntervalMs(convertRawProp(context, rawProps, "maxIntervalMs", sourceProps.maxIntervalMs, {})),
+    hasOnMapSteady(convertRawProp(context, rawProps, "hasOnMapSteady", sourceProps.hasOnMapSteady, {}))
+      {}
+RNMBXCameraProps::RNMBXCameraProps(
+    const PropsParserContext &context,
+    const RNMBXCameraProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    maxBounds(convertRawProp(context, rawProps, "maxBounds", sourceProps.maxBounds, {})),
+    animationDuration(convertRawProp(context, rawProps, "animationDuration", sourceProps.animationDuration, {})),
+    animationMode(convertRawProp(context, rawProps, "animationMode", sourceProps.animationMode, {})),
+    defaultStop(convertRawProp(context, rawProps, "defaultStop", sourceProps.defaultStop, {})),
+    userTrackingMode(convertRawProp(context, rawProps, "userTrackingMode", sourceProps.userTrackingMode, {})),
+    followUserLocation(convertRawProp(context, rawProps, "followUserLocation", sourceProps.followUserLocation, {})),
+    followUserMode(convertRawProp(context, rawProps, "followUserMode", sourceProps.followUserMode, {})),
+    followZoomLevel(convertRawProp(context, rawProps, "followZoomLevel", sourceProps.followZoomLevel, {})),
+    followPitch(convertRawProp(context, rawProps, "followPitch", sourceProps.followPitch, {})),
+    followHeading(convertRawProp(context, rawProps, "followHeading", sourceProps.followHeading, {})),
+    followPadding(convertRawProp(context, rawProps, "followPadding", sourceProps.followPadding, {})),
+    zoomLevel(convertRawProp(context, rawProps, "zoomLevel", sourceProps.zoomLevel, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    stop(convertRawProp(context, rawProps, "stop", sourceProps.stop, {}))
+      {}
+RNMBXCircleLayerProps::RNMBXCircleLayerProps(
+    const PropsParserContext &context,
+    const RNMBXCircleLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXCustomLocationProviderProps::RNMBXCustomLocationProviderProps(
+    const PropsParserContext &context,
+    const RNMBXCustomLocationProviderProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    coordinate(convertRawProp(context, rawProps, "coordinate", sourceProps.coordinate, {})),
+    heading(convertRawProp(context, rawProps, "heading", sourceProps.heading, {}))
+      {}
+RNMBXFillExtrusionLayerProps::RNMBXFillExtrusionLayerProps(
+    const PropsParserContext &context,
+    const RNMBXFillExtrusionLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {}))
+      {}
+RNMBXFillLayerProps::RNMBXFillLayerProps(
+    const PropsParserContext &context,
+    const RNMBXFillLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXHeatmapLayerProps::RNMBXHeatmapLayerProps(
+    const PropsParserContext &context,
+    const RNMBXHeatmapLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXImageProps::RNMBXImageProps(
+    const PropsParserContext &context,
+    const RNMBXImageProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    stretchX(convertRawProp(context, rawProps, "stretchX", sourceProps.stretchX, {})),
+    stretchY(convertRawProp(context, rawProps, "stretchY", sourceProps.stretchY, {})),
+    content(convertRawProp(context, rawProps, "content", sourceProps.content, {})),
+    sdf(convertRawProp(context, rawProps, "sdf", sourceProps.sdf, {})),
+    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
+    scale(convertRawProp(context, rawProps, "scale", sourceProps.scale, {}))
+      {}
+RNMBXImagesProps::RNMBXImagesProps(
+    const PropsParserContext &context,
+    const RNMBXImagesProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    images(convertRawProp(context, rawProps, "images", sourceProps.images, {})),
+    nativeImages(convertRawProp(context, rawProps, "nativeImages", sourceProps.nativeImages, {})),
+    hasOnImageMissing(convertRawProp(context, rawProps, "hasOnImageMissing", sourceProps.hasOnImageMissing, {}))
+      {}
+RNMBXImageSourceProps::RNMBXImageSourceProps(
+    const PropsParserContext &context,
+    const RNMBXImageSourceProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    url(convertRawProp(context, rawProps, "url", sourceProps.url, {})),
+    coordinates(convertRawProp(context, rawProps, "coordinates", sourceProps.coordinates, {}))
+      {}
+RNMBXLightProps::RNMBXLightProps(
+    const PropsParserContext &context,
+    const RNMBXLightProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXLineLayerProps::RNMBXLineLayerProps(
+    const PropsParserContext &context,
+    const RNMBXLineLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXMapViewProps::RNMBXMapViewProps(
+    const PropsParserContext &context,
+    const RNMBXMapViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    attributionEnabled(convertRawProp(context, rawProps, "attributionEnabled", sourceProps.attributionEnabled, {})),
+    attributionPosition(convertRawProp(context, rawProps, "attributionPosition", sourceProps.attributionPosition, {})),
+    logoEnabled(convertRawProp(context, rawProps, "logoEnabled", sourceProps.logoEnabled, {})),
+    logoPosition(convertRawProp(context, rawProps, "logoPosition", sourceProps.logoPosition, {})),
+    compassEnabled(convertRawProp(context, rawProps, "compassEnabled", sourceProps.compassEnabled, {})),
+    compassFadeWhenNorth(convertRawProp(context, rawProps, "compassFadeWhenNorth", sourceProps.compassFadeWhenNorth, {})),
+    compassPosition(convertRawProp(context, rawProps, "compassPosition", sourceProps.compassPosition, {})),
+    compassViewPosition(convertRawProp(context, rawProps, "compassViewPosition", sourceProps.compassViewPosition, {})),
+    compassViewMargins(convertRawProp(context, rawProps, "compassViewMargins", sourceProps.compassViewMargins, {})),
+    scaleBarEnabled(convertRawProp(context, rawProps, "scaleBarEnabled", sourceProps.scaleBarEnabled, {})),
+    scaleBarPosition(convertRawProp(context, rawProps, "scaleBarPosition", sourceProps.scaleBarPosition, {})),
+    zoomEnabled(convertRawProp(context, rawProps, "zoomEnabled", sourceProps.zoomEnabled, {})),
+    scrollEnabled(convertRawProp(context, rawProps, "scrollEnabled", sourceProps.scrollEnabled, {})),
+    rotateEnabled(convertRawProp(context, rawProps, "rotateEnabled", sourceProps.rotateEnabled, {})),
+    pitchEnabled(convertRawProp(context, rawProps, "pitchEnabled", sourceProps.pitchEnabled, {})),
+    maxPitch(convertRawProp(context, rawProps, "maxPitch", sourceProps.maxPitch, {})),
+    deselectAnnotationOnTap(convertRawProp(context, rawProps, "deselectAnnotationOnTap", sourceProps.deselectAnnotationOnTap, {})),
+    requestDisallowInterceptTouchEvent(convertRawProp(context, rawProps, "requestDisallowInterceptTouchEvent", sourceProps.requestDisallowInterceptTouchEvent, {})),
+    projection(convertRawProp(context, rawProps, "projection", sourceProps.projection, {})),
+    localizeLabels(convertRawProp(context, rawProps, "localizeLabels", sourceProps.localizeLabels, {})),
+    styleURL(convertRawProp(context, rawProps, "styleURL", sourceProps.styleURL, {})),
+    gestureSettings(convertRawProp(context, rawProps, "gestureSettings", sourceProps.gestureSettings, {})),
+    surfaceView(convertRawProp(context, rawProps, "surfaceView", sourceProps.surfaceView, {})),
+    scaleBarViewMargins(convertRawProp(context, rawProps, "scaleBarViewMargins", sourceProps.scaleBarViewMargins, {})),
+    attributionViewMargins(convertRawProp(context, rawProps, "attributionViewMargins", sourceProps.attributionViewMargins, {})),
+    attributionViewPosition(convertRawProp(context, rawProps, "attributionViewPosition", sourceProps.attributionViewPosition, {})),
+    compassImage(convertRawProp(context, rawProps, "compassImage", sourceProps.compassImage, {})),
+    mapViewImpl(convertRawProp(context, rawProps, "mapViewImpl", sourceProps.mapViewImpl, {})),
+    preferredFramesPerSecond(convertRawProp(context, rawProps, "preferredFramesPerSecond", sourceProps.preferredFramesPerSecond, {}))
+      {}
+RNMBXMarkerViewContentProps::RNMBXMarkerViewContentProps(
+    const PropsParserContext &context,
+    const RNMBXMarkerViewContentProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps)
+
+    
+      {}
+RNMBXMarkerViewProps::RNMBXMarkerViewProps(
+    const PropsParserContext &context,
+    const RNMBXMarkerViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    coordinate(convertRawProp(context, rawProps, "coordinate", sourceProps.coordinate, {})),
+    anchor(convertRawProp(context, rawProps, "anchor", sourceProps.anchor, {})),
+    allowOverlap(convertRawProp(context, rawProps, "allowOverlap", sourceProps.allowOverlap, {})),
+    allowOverlapWithPuck(convertRawProp(context, rawProps, "allowOverlapWithPuck", sourceProps.allowOverlapWithPuck, {})),
+    isSelected(convertRawProp(context, rawProps, "isSelected", sourceProps.isSelected, {}))
+      {}
+RNMBXModelLayerProps::RNMBXModelLayerProps(
+    const PropsParserContext &context,
+    const RNMBXModelLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXModelsProps::RNMBXModelsProps(
+    const PropsParserContext &context,
+    const RNMBXModelsProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    models(convertRawProp(context, rawProps, "models", sourceProps.models, {}))
+      {}
+RNMBXNativeUserLocationProps::RNMBXNativeUserLocationProps(
+    const PropsParserContext &context,
+    const RNMBXNativeUserLocationProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    androidRenderMode(convertRawProp(context, rawProps, "androidRenderMode", sourceProps.androidRenderMode, {})),
+    puckBearing(convertRawProp(context, rawProps, "puckBearing", sourceProps.puckBearing, {})),
+    puckBearingEnabled(convertRawProp(context, rawProps, "puckBearingEnabled", sourceProps.puckBearingEnabled, {})),
+    bearingImage(convertRawProp(context, rawProps, "bearingImage", sourceProps.bearingImage, {})),
+    shadowImage(convertRawProp(context, rawProps, "shadowImage", sourceProps.shadowImage, {})),
+    topImage(convertRawProp(context, rawProps, "topImage", sourceProps.topImage, {})),
+    scale(convertRawProp(context, rawProps, "scale", sourceProps.scale, {})),
+    visible(convertRawProp(context, rawProps, "visible", sourceProps.visible, {false})),
+    pulsing(convertRawProp(context, rawProps, "pulsing", sourceProps.pulsing, {}))
+      {}
+RNMBXPointAnnotationProps::RNMBXPointAnnotationProps(
+    const PropsParserContext &context,
+    const RNMBXPointAnnotationProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    coordinate(convertRawProp(context, rawProps, "coordinate", sourceProps.coordinate, {})),
+    draggable(convertRawProp(context, rawProps, "draggable", sourceProps.draggable, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    anchor(convertRawProp(context, rawProps, "anchor", sourceProps.anchor, {}))
+      {}
+RNMBXRasterArraySourceProps::RNMBXRasterArraySourceProps(
+    const PropsParserContext &context,
+    const RNMBXRasterArraySourceProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    url(convertRawProp(context, rawProps, "url", sourceProps.url, {})),
+    tileUrlTemplates(convertRawProp(context, rawProps, "tileUrlTemplates", sourceProps.tileUrlTemplates, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    tileSize(convertRawProp(context, rawProps, "tileSize", sourceProps.tileSize, {})),
+    sourceBounds(convertRawProp(context, rawProps, "sourceBounds", sourceProps.sourceBounds, {}))
+      {}
+RNMBXRasterDemSourceProps::RNMBXRasterDemSourceProps(
+    const PropsParserContext &context,
+    const RNMBXRasterDemSourceProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    url(convertRawProp(context, rawProps, "url", sourceProps.url, {})),
+    tileUrlTemplates(convertRawProp(context, rawProps, "tileUrlTemplates", sourceProps.tileUrlTemplates, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    tileSize(convertRawProp(context, rawProps, "tileSize", sourceProps.tileSize, {}))
+      {}
+RNMBXRasterLayerProps::RNMBXRasterLayerProps(
+    const PropsParserContext &context,
+    const RNMBXRasterLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXRasterParticleLayerProps::RNMBXRasterParticleLayerProps(
+    const PropsParserContext &context,
+    const RNMBXRasterParticleLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXRasterSourceProps::RNMBXRasterSourceProps(
+    const PropsParserContext &context,
+    const RNMBXRasterSourceProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    url(convertRawProp(context, rawProps, "url", sourceProps.url, {})),
+    tileUrlTemplates(convertRawProp(context, rawProps, "tileUrlTemplates", sourceProps.tileUrlTemplates, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    tileSize(convertRawProp(context, rawProps, "tileSize", sourceProps.tileSize, {})),
+    tms(convertRawProp(context, rawProps, "tms", sourceProps.tms, {})),
+    attribution(convertRawProp(context, rawProps, "attribution", sourceProps.attribution, {})),
+    sourceBounds(convertRawProp(context, rawProps, "sourceBounds", sourceProps.sourceBounds, {}))
+      {}
+RNMBXShapeSourceProps::RNMBXShapeSourceProps(
+    const PropsParserContext &context,
+    const RNMBXShapeSourceProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    url(convertRawProp(context, rawProps, "url", sourceProps.url, {})),
+    shape(convertRawProp(context, rawProps, "shape", sourceProps.shape, {})),
+    cluster(convertRawProp(context, rawProps, "cluster", sourceProps.cluster, {})),
+    clusterRadius(convertRawProp(context, rawProps, "clusterRadius", sourceProps.clusterRadius, {})),
+    clusterMaxZoomLevel(convertRawProp(context, rawProps, "clusterMaxZoomLevel", sourceProps.clusterMaxZoomLevel, {})),
+    clusterProperties(convertRawProp(context, rawProps, "clusterProperties", sourceProps.clusterProperties, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    buffer(convertRawProp(context, rawProps, "buffer", sourceProps.buffer, {})),
+    tolerance(convertRawProp(context, rawProps, "tolerance", sourceProps.tolerance, {})),
+    lineMetrics(convertRawProp(context, rawProps, "lineMetrics", sourceProps.lineMetrics, {})),
+    hasPressListener(convertRawProp(context, rawProps, "hasPressListener", sourceProps.hasPressListener, {})),
+    hitbox(convertRawProp(context, rawProps, "hitbox", sourceProps.hitbox, {}))
+      {}
+RNMBXSkyLayerProps::RNMBXSkyLayerProps(
+    const PropsParserContext &context,
+    const RNMBXSkyLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {}))
+      {}
+RNMBXStyleImportProps::RNMBXStyleImportProps(
+    const PropsParserContext &context,
+    const RNMBXStyleImportProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {false})),
+    config(convertRawProp(context, rawProps, "config", sourceProps.config, {}))
+      {}
+RNMBXSymbolLayerProps::RNMBXSymbolLayerProps(
+    const PropsParserContext &context,
+    const RNMBXSymbolLayerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
+    aboveLayerID(convertRawProp(context, rawProps, "aboveLayerID", sourceProps.aboveLayerID, {})),
+    belowLayerID(convertRawProp(context, rawProps, "belowLayerID", sourceProps.belowLayerID, {})),
+    layerIndex(convertRawProp(context, rawProps, "layerIndex", sourceProps.layerIndex, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    sourceLayerID(convertRawProp(context, rawProps, "sourceLayerID", sourceProps.sourceLayerID, {})),
+    slot(convertRawProp(context, rawProps, "slot", sourceProps.slot, {})),
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXTerrainProps::RNMBXTerrainProps(
+    const PropsParserContext &context,
+    const RNMBXTerrainProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    sourceID(convertRawProp(context, rawProps, "sourceID", sourceProps.sourceID, {})),
+    reactStyle(convertRawProp(context, rawProps, "reactStyle", sourceProps.reactStyle, {}))
+      {}
+RNMBXVectorSourceProps::RNMBXVectorSourceProps(
+    const PropsParserContext &context,
+    const RNMBXVectorSourceProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    id(convertRawProp(context, rawProps, "id", sourceProps.id, {})),
+    existing(convertRawProp(context, rawProps, "existing", sourceProps.existing, {})),
+    url(convertRawProp(context, rawProps, "url", sourceProps.url, {})),
+    tileUrlTemplates(convertRawProp(context, rawProps, "tileUrlTemplates", sourceProps.tileUrlTemplates, {})),
+    attribution(convertRawProp(context, rawProps, "attribution", sourceProps.attribution, {})),
+    maxZoomLevel(convertRawProp(context, rawProps, "maxZoomLevel", sourceProps.maxZoomLevel, {})),
+    minZoomLevel(convertRawProp(context, rawProps, "minZoomLevel", sourceProps.minZoomLevel, {})),
+    tms(convertRawProp(context, rawProps, "tms", sourceProps.tms, {})),
+    hasPressListener(convertRawProp(context, rawProps, "hasPressListener", sourceProps.hasPressListener, {})),
+    hitbox(convertRawProp(context, rawProps, "hitbox", sourceProps.hitbox, {}))
+      {}
+RNMBXViewportProps::RNMBXViewportProps(
+    const PropsParserContext &context,
+    const RNMBXViewportProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    transitionsToIdleUponUserInteraction(convertRawProp(context, rawProps, "transitionsToIdleUponUserInteraction", sourceProps.transitionsToIdleUponUserInteraction, {})),
+    hasStatusChanged(convertRawProp(context, rawProps, "hasStatusChanged", sourceProps.hasStatusChanged, {false}))
+      {}
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/Props.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/Props.h
new file mode 100644
index 0000000..43b35b2
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/Props.h
@@ -0,0 +1,591 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewProps.h>
+#include <react/renderer/core/PropsParserContext.h>
+
+namespace facebook::react {
+
+class RNMBXAtmosphereProps final : public ViewProps {
+ public:
+  RNMBXAtmosphereProps() = default;
+  RNMBXAtmosphereProps(const PropsParserContext& context, const RNMBXAtmosphereProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXBackgroundLayerProps final : public ViewProps {
+ public:
+  RNMBXBackgroundLayerProps() = default;
+  RNMBXBackgroundLayerProps(const PropsParserContext& context, const RNMBXBackgroundLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic reactStyle{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+};
+
+class RNMBXCalloutProps final : public ViewProps {
+ public:
+  RNMBXCalloutProps() = default;
+  RNMBXCalloutProps(const PropsParserContext& context, const RNMBXCalloutProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  
+};
+
+class RNMBXCameraGestureObserverProps final : public ViewProps {
+ public:
+  RNMBXCameraGestureObserverProps() = default;
+  RNMBXCameraGestureObserverProps(const PropsParserContext& context, const RNMBXCameraGestureObserverProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic quietPeriodMs{};
+  folly::dynamic maxIntervalMs{};
+  folly::dynamic hasOnMapSteady{};
+};
+
+class RNMBXCameraProps final : public ViewProps {
+ public:
+  RNMBXCameraProps() = default;
+  RNMBXCameraProps(const PropsParserContext& context, const RNMBXCameraProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic maxBounds{};
+  folly::dynamic animationDuration{};
+  folly::dynamic animationMode{};
+  folly::dynamic defaultStop{};
+  folly::dynamic userTrackingMode{};
+  folly::dynamic followUserLocation{};
+  folly::dynamic followUserMode{};
+  folly::dynamic followZoomLevel{};
+  folly::dynamic followPitch{};
+  folly::dynamic followHeading{};
+  folly::dynamic followPadding{};
+  folly::dynamic zoomLevel{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic stop{};
+};
+
+class RNMBXCircleLayerProps final : public ViewProps {
+ public:
+  RNMBXCircleLayerProps() = default;
+  RNMBXCircleLayerProps(const PropsParserContext& context, const RNMBXCircleLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXCustomLocationProviderProps final : public ViewProps {
+ public:
+  RNMBXCustomLocationProviderProps() = default;
+  RNMBXCustomLocationProviderProps(const PropsParserContext& context, const RNMBXCustomLocationProviderProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic coordinate{};
+  folly::dynamic heading{};
+};
+
+class RNMBXFillExtrusionLayerProps final : public ViewProps {
+ public:
+  RNMBXFillExtrusionLayerProps() = default;
+  RNMBXFillExtrusionLayerProps(const PropsParserContext& context, const RNMBXFillExtrusionLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic reactStyle{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+};
+
+class RNMBXFillLayerProps final : public ViewProps {
+ public:
+  RNMBXFillLayerProps() = default;
+  RNMBXFillLayerProps(const PropsParserContext& context, const RNMBXFillLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXHeatmapLayerProps final : public ViewProps {
+ public:
+  RNMBXHeatmapLayerProps() = default;
+  RNMBXHeatmapLayerProps(const PropsParserContext& context, const RNMBXHeatmapLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXImageProps final : public ViewProps {
+ public:
+  RNMBXImageProps() = default;
+  RNMBXImageProps(const PropsParserContext& context, const RNMBXImageProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic stretchX{};
+  folly::dynamic stretchY{};
+  folly::dynamic content{};
+  folly::dynamic sdf{};
+  folly::dynamic name{};
+  folly::dynamic scale{};
+};
+
+class RNMBXImagesProps final : public ViewProps {
+ public:
+  RNMBXImagesProps() = default;
+  RNMBXImagesProps(const PropsParserContext& context, const RNMBXImagesProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic images{};
+  folly::dynamic nativeImages{};
+  folly::dynamic hasOnImageMissing{};
+};
+
+class RNMBXImageSourceProps final : public ViewProps {
+ public:
+  RNMBXImageSourceProps() = default;
+  RNMBXImageSourceProps(const PropsParserContext& context, const RNMBXImageSourceProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic existing{};
+  folly::dynamic url{};
+  folly::dynamic coordinates{};
+};
+
+class RNMBXLightProps final : public ViewProps {
+ public:
+  RNMBXLightProps() = default;
+  RNMBXLightProps(const PropsParserContext& context, const RNMBXLightProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXLineLayerProps final : public ViewProps {
+ public:
+  RNMBXLineLayerProps() = default;
+  RNMBXLineLayerProps(const PropsParserContext& context, const RNMBXLineLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXMapViewProps final : public ViewProps {
+ public:
+  RNMBXMapViewProps() = default;
+  RNMBXMapViewProps(const PropsParserContext& context, const RNMBXMapViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic attributionEnabled{};
+  folly::dynamic attributionPosition{};
+  folly::dynamic logoEnabled{};
+  folly::dynamic logoPosition{};
+  folly::dynamic compassEnabled{};
+  folly::dynamic compassFadeWhenNorth{};
+  folly::dynamic compassPosition{};
+  folly::dynamic compassViewPosition{};
+  folly::dynamic compassViewMargins{};
+  folly::dynamic scaleBarEnabled{};
+  folly::dynamic scaleBarPosition{};
+  folly::dynamic zoomEnabled{};
+  folly::dynamic scrollEnabled{};
+  folly::dynamic rotateEnabled{};
+  folly::dynamic pitchEnabled{};
+  folly::dynamic maxPitch{};
+  folly::dynamic deselectAnnotationOnTap{};
+  folly::dynamic requestDisallowInterceptTouchEvent{};
+  folly::dynamic projection{};
+  folly::dynamic localizeLabels{};
+  folly::dynamic styleURL{};
+  folly::dynamic gestureSettings{};
+  folly::dynamic surfaceView{};
+  folly::dynamic scaleBarViewMargins{};
+  folly::dynamic attributionViewMargins{};
+  folly::dynamic attributionViewPosition{};
+  folly::dynamic compassImage{};
+  folly::dynamic mapViewImpl{};
+  folly::dynamic preferredFramesPerSecond{};
+};
+
+class RNMBXMarkerViewContentProps final : public ViewProps {
+ public:
+  RNMBXMarkerViewContentProps() = default;
+  RNMBXMarkerViewContentProps(const PropsParserContext& context, const RNMBXMarkerViewContentProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  
+};
+
+class RNMBXMarkerViewProps final : public ViewProps {
+ public:
+  RNMBXMarkerViewProps() = default;
+  RNMBXMarkerViewProps(const PropsParserContext& context, const RNMBXMarkerViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic coordinate{};
+  folly::dynamic anchor{};
+  folly::dynamic allowOverlap{};
+  folly::dynamic allowOverlapWithPuck{};
+  folly::dynamic isSelected{};
+};
+
+class RNMBXModelLayerProps final : public ViewProps {
+ public:
+  RNMBXModelLayerProps() = default;
+  RNMBXModelLayerProps(const PropsParserContext& context, const RNMBXModelLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXModelsProps final : public ViewProps {
+ public:
+  RNMBXModelsProps() = default;
+  RNMBXModelsProps(const PropsParserContext& context, const RNMBXModelsProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic models{};
+};
+
+class RNMBXNativeUserLocationProps final : public ViewProps {
+ public:
+  RNMBXNativeUserLocationProps() = default;
+  RNMBXNativeUserLocationProps(const PropsParserContext& context, const RNMBXNativeUserLocationProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic androidRenderMode{};
+  folly::dynamic puckBearing{};
+  folly::dynamic puckBearingEnabled{};
+  folly::dynamic bearingImage{};
+  folly::dynamic shadowImage{};
+  folly::dynamic topImage{};
+  folly::dynamic scale{};
+  bool visible{false};
+  folly::dynamic pulsing{};
+};
+
+class RNMBXPointAnnotationProps final : public ViewProps {
+ public:
+  RNMBXPointAnnotationProps() = default;
+  RNMBXPointAnnotationProps(const PropsParserContext& context, const RNMBXPointAnnotationProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic coordinate{};
+  folly::dynamic draggable{};
+  folly::dynamic id{};
+  folly::dynamic anchor{};
+};
+
+class RNMBXRasterArraySourceProps final : public ViewProps {
+ public:
+  RNMBXRasterArraySourceProps() = default;
+  RNMBXRasterArraySourceProps(const PropsParserContext& context, const RNMBXRasterArraySourceProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic existing{};
+  folly::dynamic url{};
+  folly::dynamic tileUrlTemplates{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic tileSize{};
+  folly::dynamic sourceBounds{};
+};
+
+class RNMBXRasterDemSourceProps final : public ViewProps {
+ public:
+  RNMBXRasterDemSourceProps() = default;
+  RNMBXRasterDemSourceProps(const PropsParserContext& context, const RNMBXRasterDemSourceProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic existing{};
+  folly::dynamic url{};
+  folly::dynamic tileUrlTemplates{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic tileSize{};
+};
+
+class RNMBXRasterLayerProps final : public ViewProps {
+ public:
+  RNMBXRasterLayerProps() = default;
+  RNMBXRasterLayerProps(const PropsParserContext& context, const RNMBXRasterLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXRasterParticleLayerProps final : public ViewProps {
+ public:
+  RNMBXRasterParticleLayerProps() = default;
+  RNMBXRasterParticleLayerProps(const PropsParserContext& context, const RNMBXRasterParticleLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXRasterSourceProps final : public ViewProps {
+ public:
+  RNMBXRasterSourceProps() = default;
+  RNMBXRasterSourceProps(const PropsParserContext& context, const RNMBXRasterSourceProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic existing{};
+  folly::dynamic url{};
+  folly::dynamic tileUrlTemplates{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic tileSize{};
+  folly::dynamic tms{};
+  folly::dynamic attribution{};
+  folly::dynamic sourceBounds{};
+};
+
+class RNMBXShapeSourceProps final : public ViewProps {
+ public:
+  RNMBXShapeSourceProps() = default;
+  RNMBXShapeSourceProps(const PropsParserContext& context, const RNMBXShapeSourceProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic existing{};
+  folly::dynamic url{};
+  folly::dynamic shape{};
+  folly::dynamic cluster{};
+  folly::dynamic clusterRadius{};
+  folly::dynamic clusterMaxZoomLevel{};
+  folly::dynamic clusterProperties{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic buffer{};
+  folly::dynamic tolerance{};
+  folly::dynamic lineMetrics{};
+  folly::dynamic hasPressListener{};
+  folly::dynamic hitbox{};
+};
+
+class RNMBXSkyLayerProps final : public ViewProps {
+ public:
+  RNMBXSkyLayerProps() = default;
+  RNMBXSkyLayerProps(const PropsParserContext& context, const RNMBXSkyLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic reactStyle{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+};
+
+class RNMBXStyleImportProps final : public ViewProps {
+ public:
+  RNMBXStyleImportProps() = default;
+  RNMBXStyleImportProps(const PropsParserContext& context, const RNMBXStyleImportProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  std::string id{};
+  bool existing{false};
+  folly::dynamic config{};
+};
+
+class RNMBXSymbolLayerProps final : public ViewProps {
+ public:
+  RNMBXSymbolLayerProps() = default;
+  RNMBXSymbolLayerProps(const PropsParserContext& context, const RNMBXSymbolLayerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic existing{};
+  folly::dynamic filter{};
+  folly::dynamic aboveLayerID{};
+  folly::dynamic belowLayerID{};
+  folly::dynamic layerIndex{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic sourceLayerID{};
+  folly::dynamic slot{};
+  folly::dynamic id{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXTerrainProps final : public ViewProps {
+ public:
+  RNMBXTerrainProps() = default;
+  RNMBXTerrainProps(const PropsParserContext& context, const RNMBXTerrainProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic sourceID{};
+  folly::dynamic reactStyle{};
+};
+
+class RNMBXVectorSourceProps final : public ViewProps {
+ public:
+  RNMBXVectorSourceProps() = default;
+  RNMBXVectorSourceProps(const PropsParserContext& context, const RNMBXVectorSourceProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic id{};
+  folly::dynamic existing{};
+  folly::dynamic url{};
+  folly::dynamic tileUrlTemplates{};
+  folly::dynamic attribution{};
+  folly::dynamic maxZoomLevel{};
+  folly::dynamic minZoomLevel{};
+  folly::dynamic tms{};
+  folly::dynamic hasPressListener{};
+  folly::dynamic hitbox{};
+};
+
+class RNMBXViewportProps final : public ViewProps {
+ public:
+  RNMBXViewportProps() = default;
+  RNMBXViewportProps(const PropsParserContext& context, const RNMBXViewportProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  folly::dynamic transitionsToIdleUponUserInteraction{};
+  bool hasStatusChanged{false};
+};
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ShadowNodes.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ShadowNodes.cpp
new file mode 100644
index 0000000..3184379
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ShadowNodes.cpp
@@ -0,0 +1,50 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeCpp.js
+ */
+
+#include <react/renderer/components/rnmapbox_maps_specs/ShadowNodes.h>
+
+namespace facebook::react {
+
+extern const char RNMBXAtmosphereComponentName[] = "RNMBXAtmosphere";
+extern const char RNMBXBackgroundLayerComponentName[] = "RNMBXBackgroundLayer";
+extern const char RNMBXCalloutComponentName[] = "RNMBXCallout";
+extern const char RNMBXCameraGestureObserverComponentName[] = "RNMBXCameraGestureObserver";
+extern const char RNMBXCameraComponentName[] = "RNMBXCamera";
+extern const char RNMBXCircleLayerComponentName[] = "RNMBXCircleLayer";
+extern const char RNMBXCustomLocationProviderComponentName[] = "RNMBXCustomLocationProvider";
+extern const char RNMBXFillExtrusionLayerComponentName[] = "RNMBXFillExtrusionLayer";
+extern const char RNMBXFillLayerComponentName[] = "RNMBXFillLayer";
+extern const char RNMBXHeatmapLayerComponentName[] = "RNMBXHeatmapLayer";
+extern const char RNMBXImageComponentName[] = "RNMBXImage";
+extern const char RNMBXImagesComponentName[] = "RNMBXImages";
+extern const char RNMBXImageSourceComponentName[] = "RNMBXImageSource";
+extern const char RNMBXLightComponentName[] = "RNMBXLight";
+extern const char RNMBXLineLayerComponentName[] = "RNMBXLineLayer";
+extern const char RNMBXMapViewComponentName[] = "RNMBXMapView";
+extern const char RNMBXMarkerViewContentComponentName[] = "RNMBXMarkerViewContent";
+extern const char RNMBXMarkerViewComponentName[] = "RNMBXMarkerView";
+extern const char RNMBXModelLayerComponentName[] = "RNMBXModelLayer";
+extern const char RNMBXModelsComponentName[] = "RNMBXModels";
+extern const char RNMBXNativeUserLocationComponentName[] = "RNMBXNativeUserLocation";
+extern const char RNMBXPointAnnotationComponentName[] = "RNMBXPointAnnotation";
+extern const char RNMBXRasterArraySourceComponentName[] = "RNMBXRasterArraySource";
+extern const char RNMBXRasterDemSourceComponentName[] = "RNMBXRasterDemSource";
+extern const char RNMBXRasterLayerComponentName[] = "RNMBXRasterLayer";
+extern const char RNMBXRasterParticleLayerComponentName[] = "RNMBXRasterParticleLayer";
+extern const char RNMBXRasterSourceComponentName[] = "RNMBXRasterSource";
+extern const char RNMBXShapeSourceComponentName[] = "RNMBXShapeSource";
+extern const char RNMBXSkyLayerComponentName[] = "RNMBXSkyLayer";
+extern const char RNMBXStyleImportComponentName[] = "RNMBXStyleImport";
+extern const char RNMBXSymbolLayerComponentName[] = "RNMBXSymbolLayer";
+extern const char RNMBXTerrainComponentName[] = "RNMBXTerrain";
+extern const char RNMBXVectorSourceComponentName[] = "RNMBXVectorSource";
+extern const char RNMBXViewportComponentName[] = "RNMBXViewport";
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ShadowNodes.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ShadowNodes.h
new file mode 100644
index 0000000..7d9a6e6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/ShadowNodes.h
@@ -0,0 +1,395 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/rnmapbox_maps_specs/EventEmitters.h>
+#include <react/renderer/components/rnmapbox_maps_specs/Props.h>
+#include <react/renderer/components/rnmapbox_maps_specs/States.h>
+#include <react/renderer/components/view/ConcreteViewShadowNode.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+JSI_EXPORT extern const char RNMBXAtmosphereComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXAtmosphere> component.
+ */
+using RNMBXAtmosphereShadowNode = ConcreteViewShadowNode<
+    RNMBXAtmosphereComponentName,
+    RNMBXAtmosphereProps,
+    RNMBXAtmosphereEventEmitter,
+    RNMBXAtmosphereState>;
+
+JSI_EXPORT extern const char RNMBXBackgroundLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXBackgroundLayer> component.
+ */
+using RNMBXBackgroundLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXBackgroundLayerComponentName,
+    RNMBXBackgroundLayerProps,
+    RNMBXBackgroundLayerEventEmitter,
+    RNMBXBackgroundLayerState>;
+
+JSI_EXPORT extern const char RNMBXCalloutComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXCallout> component.
+ */
+using RNMBXCalloutShadowNode = ConcreteViewShadowNode<
+    RNMBXCalloutComponentName,
+    RNMBXCalloutProps,
+    RNMBXCalloutEventEmitter,
+    RNMBXCalloutState>;
+
+JSI_EXPORT extern const char RNMBXCameraGestureObserverComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXCameraGestureObserver> component.
+ */
+using RNMBXCameraGestureObserverShadowNode = ConcreteViewShadowNode<
+    RNMBXCameraGestureObserverComponentName,
+    RNMBXCameraGestureObserverProps,
+    RNMBXCameraGestureObserverEventEmitter,
+    RNMBXCameraGestureObserverState>;
+
+JSI_EXPORT extern const char RNMBXCameraComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXCamera> component.
+ */
+using RNMBXCameraShadowNode = ConcreteViewShadowNode<
+    RNMBXCameraComponentName,
+    RNMBXCameraProps,
+    RNMBXCameraEventEmitter,
+    RNMBXCameraState>;
+
+JSI_EXPORT extern const char RNMBXCircleLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXCircleLayer> component.
+ */
+using RNMBXCircleLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXCircleLayerComponentName,
+    RNMBXCircleLayerProps,
+    RNMBXCircleLayerEventEmitter,
+    RNMBXCircleLayerState>;
+
+JSI_EXPORT extern const char RNMBXCustomLocationProviderComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXCustomLocationProvider> component.
+ */
+using RNMBXCustomLocationProviderShadowNode = ConcreteViewShadowNode<
+    RNMBXCustomLocationProviderComponentName,
+    RNMBXCustomLocationProviderProps,
+    RNMBXCustomLocationProviderEventEmitter,
+    RNMBXCustomLocationProviderState>;
+
+JSI_EXPORT extern const char RNMBXFillExtrusionLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXFillExtrusionLayer> component.
+ */
+using RNMBXFillExtrusionLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXFillExtrusionLayerComponentName,
+    RNMBXFillExtrusionLayerProps,
+    RNMBXFillExtrusionLayerEventEmitter,
+    RNMBXFillExtrusionLayerState>;
+
+JSI_EXPORT extern const char RNMBXFillLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXFillLayer> component.
+ */
+using RNMBXFillLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXFillLayerComponentName,
+    RNMBXFillLayerProps,
+    RNMBXFillLayerEventEmitter,
+    RNMBXFillLayerState>;
+
+JSI_EXPORT extern const char RNMBXHeatmapLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXHeatmapLayer> component.
+ */
+using RNMBXHeatmapLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXHeatmapLayerComponentName,
+    RNMBXHeatmapLayerProps,
+    RNMBXHeatmapLayerEventEmitter,
+    RNMBXHeatmapLayerState>;
+
+JSI_EXPORT extern const char RNMBXImageComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXImage> component.
+ */
+using RNMBXImageShadowNode = ConcreteViewShadowNode<
+    RNMBXImageComponentName,
+    RNMBXImageProps,
+    RNMBXImageEventEmitter,
+    RNMBXImageState>;
+
+JSI_EXPORT extern const char RNMBXImagesComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXImages> component.
+ */
+using RNMBXImagesShadowNode = ConcreteViewShadowNode<
+    RNMBXImagesComponentName,
+    RNMBXImagesProps,
+    RNMBXImagesEventEmitter,
+    RNMBXImagesState>;
+
+JSI_EXPORT extern const char RNMBXImageSourceComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXImageSource> component.
+ */
+using RNMBXImageSourceShadowNode = ConcreteViewShadowNode<
+    RNMBXImageSourceComponentName,
+    RNMBXImageSourceProps,
+    RNMBXImageSourceEventEmitter,
+    RNMBXImageSourceState>;
+
+JSI_EXPORT extern const char RNMBXLightComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXLight> component.
+ */
+using RNMBXLightShadowNode = ConcreteViewShadowNode<
+    RNMBXLightComponentName,
+    RNMBXLightProps,
+    RNMBXLightEventEmitter,
+    RNMBXLightState>;
+
+JSI_EXPORT extern const char RNMBXLineLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXLineLayer> component.
+ */
+using RNMBXLineLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXLineLayerComponentName,
+    RNMBXLineLayerProps,
+    RNMBXLineLayerEventEmitter,
+    RNMBXLineLayerState>;
+
+JSI_EXPORT extern const char RNMBXMapViewComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXMapView> component.
+ */
+using RNMBXMapViewShadowNode = ConcreteViewShadowNode<
+    RNMBXMapViewComponentName,
+    RNMBXMapViewProps,
+    RNMBXMapViewEventEmitter,
+    RNMBXMapViewState>;
+
+JSI_EXPORT extern const char RNMBXMarkerViewContentComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXMarkerViewContent> component.
+ */
+using RNMBXMarkerViewContentShadowNode = ConcreteViewShadowNode<
+    RNMBXMarkerViewContentComponentName,
+    RNMBXMarkerViewContentProps,
+    RNMBXMarkerViewContentEventEmitter,
+    RNMBXMarkerViewContentState>;
+
+JSI_EXPORT extern const char RNMBXMarkerViewComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXMarkerView> component.
+ */
+using RNMBXMarkerViewShadowNode = ConcreteViewShadowNode<
+    RNMBXMarkerViewComponentName,
+    RNMBXMarkerViewProps,
+    RNMBXMarkerViewEventEmitter,
+    RNMBXMarkerViewState>;
+
+JSI_EXPORT extern const char RNMBXModelLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXModelLayer> component.
+ */
+using RNMBXModelLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXModelLayerComponentName,
+    RNMBXModelLayerProps,
+    RNMBXModelLayerEventEmitter,
+    RNMBXModelLayerState>;
+
+JSI_EXPORT extern const char RNMBXModelsComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXModels> component.
+ */
+using RNMBXModelsShadowNode = ConcreteViewShadowNode<
+    RNMBXModelsComponentName,
+    RNMBXModelsProps,
+    RNMBXModelsEventEmitter,
+    RNMBXModelsState>;
+
+JSI_EXPORT extern const char RNMBXNativeUserLocationComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXNativeUserLocation> component.
+ */
+using RNMBXNativeUserLocationShadowNode = ConcreteViewShadowNode<
+    RNMBXNativeUserLocationComponentName,
+    RNMBXNativeUserLocationProps,
+    RNMBXNativeUserLocationEventEmitter,
+    RNMBXNativeUserLocationState>;
+
+JSI_EXPORT extern const char RNMBXPointAnnotationComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXPointAnnotation> component.
+ */
+using RNMBXPointAnnotationShadowNode = ConcreteViewShadowNode<
+    RNMBXPointAnnotationComponentName,
+    RNMBXPointAnnotationProps,
+    RNMBXPointAnnotationEventEmitter,
+    RNMBXPointAnnotationState>;
+
+JSI_EXPORT extern const char RNMBXRasterArraySourceComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXRasterArraySource> component.
+ */
+using RNMBXRasterArraySourceShadowNode = ConcreteViewShadowNode<
+    RNMBXRasterArraySourceComponentName,
+    RNMBXRasterArraySourceProps,
+    RNMBXRasterArraySourceEventEmitter,
+    RNMBXRasterArraySourceState>;
+
+JSI_EXPORT extern const char RNMBXRasterDemSourceComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXRasterDemSource> component.
+ */
+using RNMBXRasterDemSourceShadowNode = ConcreteViewShadowNode<
+    RNMBXRasterDemSourceComponentName,
+    RNMBXRasterDemSourceProps,
+    RNMBXRasterDemSourceEventEmitter,
+    RNMBXRasterDemSourceState>;
+
+JSI_EXPORT extern const char RNMBXRasterLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXRasterLayer> component.
+ */
+using RNMBXRasterLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXRasterLayerComponentName,
+    RNMBXRasterLayerProps,
+    RNMBXRasterLayerEventEmitter,
+    RNMBXRasterLayerState>;
+
+JSI_EXPORT extern const char RNMBXRasterParticleLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXRasterParticleLayer> component.
+ */
+using RNMBXRasterParticleLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXRasterParticleLayerComponentName,
+    RNMBXRasterParticleLayerProps,
+    RNMBXRasterParticleLayerEventEmitter,
+    RNMBXRasterParticleLayerState>;
+
+JSI_EXPORT extern const char RNMBXRasterSourceComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXRasterSource> component.
+ */
+using RNMBXRasterSourceShadowNode = ConcreteViewShadowNode<
+    RNMBXRasterSourceComponentName,
+    RNMBXRasterSourceProps,
+    RNMBXRasterSourceEventEmitter,
+    RNMBXRasterSourceState>;
+
+JSI_EXPORT extern const char RNMBXShapeSourceComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXShapeSource> component.
+ */
+using RNMBXShapeSourceShadowNode = ConcreteViewShadowNode<
+    RNMBXShapeSourceComponentName,
+    RNMBXShapeSourceProps,
+    RNMBXShapeSourceEventEmitter,
+    RNMBXShapeSourceState>;
+
+JSI_EXPORT extern const char RNMBXSkyLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXSkyLayer> component.
+ */
+using RNMBXSkyLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXSkyLayerComponentName,
+    RNMBXSkyLayerProps,
+    RNMBXSkyLayerEventEmitter,
+    RNMBXSkyLayerState>;
+
+JSI_EXPORT extern const char RNMBXStyleImportComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXStyleImport> component.
+ */
+using RNMBXStyleImportShadowNode = ConcreteViewShadowNode<
+    RNMBXStyleImportComponentName,
+    RNMBXStyleImportProps,
+    RNMBXStyleImportEventEmitter,
+    RNMBXStyleImportState>;
+
+JSI_EXPORT extern const char RNMBXSymbolLayerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXSymbolLayer> component.
+ */
+using RNMBXSymbolLayerShadowNode = ConcreteViewShadowNode<
+    RNMBXSymbolLayerComponentName,
+    RNMBXSymbolLayerProps,
+    RNMBXSymbolLayerEventEmitter,
+    RNMBXSymbolLayerState>;
+
+JSI_EXPORT extern const char RNMBXTerrainComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXTerrain> component.
+ */
+using RNMBXTerrainShadowNode = ConcreteViewShadowNode<
+    RNMBXTerrainComponentName,
+    RNMBXTerrainProps,
+    RNMBXTerrainEventEmitter,
+    RNMBXTerrainState>;
+
+JSI_EXPORT extern const char RNMBXVectorSourceComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXVectorSource> component.
+ */
+using RNMBXVectorSourceShadowNode = ConcreteViewShadowNode<
+    RNMBXVectorSourceComponentName,
+    RNMBXVectorSourceProps,
+    RNMBXVectorSourceEventEmitter,
+    RNMBXVectorSourceState>;
+
+JSI_EXPORT extern const char RNMBXViewportComponentName[];
+
+/*
+ * `ShadowNode` for <RNMBXViewport> component.
+ */
+using RNMBXViewportShadowNode = ConcreteViewShadowNode<
+    RNMBXViewportComponentName,
+    RNMBXViewportProps,
+    RNMBXViewportEventEmitter,
+    RNMBXViewportState>;
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/States.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/States.cpp
new file mode 100644
index 0000000..914333f
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/States.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateCpp.js
+ */
+#include <react/renderer/components/rnmapbox_maps_specs/States.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/States.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/States.h
new file mode 100644
index 0000000..0d3ab65
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/States.h
@@ -0,0 +1,425 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateH.js
+ */
+#pragma once
+
+#ifdef ANDROID
+#include <folly/dynamic.h>
+#endif
+
+namespace facebook::react {
+
+class RNMBXAtmosphereState {
+public:
+  RNMBXAtmosphereState() = default;
+
+#ifdef ANDROID
+  RNMBXAtmosphereState(RNMBXAtmosphereState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXBackgroundLayerState {
+public:
+  RNMBXBackgroundLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXBackgroundLayerState(RNMBXBackgroundLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXCalloutState {
+public:
+  RNMBXCalloutState() = default;
+
+#ifdef ANDROID
+  RNMBXCalloutState(RNMBXCalloutState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXCameraGestureObserverState {
+public:
+  RNMBXCameraGestureObserverState() = default;
+
+#ifdef ANDROID
+  RNMBXCameraGestureObserverState(RNMBXCameraGestureObserverState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXCameraState {
+public:
+  RNMBXCameraState() = default;
+
+#ifdef ANDROID
+  RNMBXCameraState(RNMBXCameraState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXCircleLayerState {
+public:
+  RNMBXCircleLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXCircleLayerState(RNMBXCircleLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXCustomLocationProviderState {
+public:
+  RNMBXCustomLocationProviderState() = default;
+
+#ifdef ANDROID
+  RNMBXCustomLocationProviderState(RNMBXCustomLocationProviderState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXFillExtrusionLayerState {
+public:
+  RNMBXFillExtrusionLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXFillExtrusionLayerState(RNMBXFillExtrusionLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXFillLayerState {
+public:
+  RNMBXFillLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXFillLayerState(RNMBXFillLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXHeatmapLayerState {
+public:
+  RNMBXHeatmapLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXHeatmapLayerState(RNMBXHeatmapLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXImageState {
+public:
+  RNMBXImageState() = default;
+
+#ifdef ANDROID
+  RNMBXImageState(RNMBXImageState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXImagesState {
+public:
+  RNMBXImagesState() = default;
+
+#ifdef ANDROID
+  RNMBXImagesState(RNMBXImagesState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXImageSourceState {
+public:
+  RNMBXImageSourceState() = default;
+
+#ifdef ANDROID
+  RNMBXImageSourceState(RNMBXImageSourceState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXLightState {
+public:
+  RNMBXLightState() = default;
+
+#ifdef ANDROID
+  RNMBXLightState(RNMBXLightState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXLineLayerState {
+public:
+  RNMBXLineLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXLineLayerState(RNMBXLineLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXMapViewState {
+public:
+  RNMBXMapViewState() = default;
+
+#ifdef ANDROID
+  RNMBXMapViewState(RNMBXMapViewState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXMarkerViewContentState {
+public:
+  RNMBXMarkerViewContentState() = default;
+
+#ifdef ANDROID
+  RNMBXMarkerViewContentState(RNMBXMarkerViewContentState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXMarkerViewState {
+public:
+  RNMBXMarkerViewState() = default;
+
+#ifdef ANDROID
+  RNMBXMarkerViewState(RNMBXMarkerViewState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXModelLayerState {
+public:
+  RNMBXModelLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXModelLayerState(RNMBXModelLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXModelsState {
+public:
+  RNMBXModelsState() = default;
+
+#ifdef ANDROID
+  RNMBXModelsState(RNMBXModelsState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXNativeUserLocationState {
+public:
+  RNMBXNativeUserLocationState() = default;
+
+#ifdef ANDROID
+  RNMBXNativeUserLocationState(RNMBXNativeUserLocationState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXPointAnnotationState {
+public:
+  RNMBXPointAnnotationState() = default;
+
+#ifdef ANDROID
+  RNMBXPointAnnotationState(RNMBXPointAnnotationState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXRasterArraySourceState {
+public:
+  RNMBXRasterArraySourceState() = default;
+
+#ifdef ANDROID
+  RNMBXRasterArraySourceState(RNMBXRasterArraySourceState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXRasterDemSourceState {
+public:
+  RNMBXRasterDemSourceState() = default;
+
+#ifdef ANDROID
+  RNMBXRasterDemSourceState(RNMBXRasterDemSourceState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXRasterLayerState {
+public:
+  RNMBXRasterLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXRasterLayerState(RNMBXRasterLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXRasterParticleLayerState {
+public:
+  RNMBXRasterParticleLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXRasterParticleLayerState(RNMBXRasterParticleLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXRasterSourceState {
+public:
+  RNMBXRasterSourceState() = default;
+
+#ifdef ANDROID
+  RNMBXRasterSourceState(RNMBXRasterSourceState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXShapeSourceState {
+public:
+  RNMBXShapeSourceState() = default;
+
+#ifdef ANDROID
+  RNMBXShapeSourceState(RNMBXShapeSourceState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXSkyLayerState {
+public:
+  RNMBXSkyLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXSkyLayerState(RNMBXSkyLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXStyleImportState {
+public:
+  RNMBXStyleImportState() = default;
+
+#ifdef ANDROID
+  RNMBXStyleImportState(RNMBXStyleImportState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXSymbolLayerState {
+public:
+  RNMBXSymbolLayerState() = default;
+
+#ifdef ANDROID
+  RNMBXSymbolLayerState(RNMBXSymbolLayerState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXTerrainState {
+public:
+  RNMBXTerrainState() = default;
+
+#ifdef ANDROID
+  RNMBXTerrainState(RNMBXTerrainState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXVectorSourceState {
+public:
+  RNMBXVectorSourceState() = default;
+
+#ifdef ANDROID
+  RNMBXVectorSourceState(RNMBXVectorSourceState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class RNMBXViewportState {
+public:
+  RNMBXViewportState() = default;
+
+#ifdef ANDROID
+  RNMBXViewportState(RNMBXViewportState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+} // namespace facebook::react
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/rnmapbox_maps_specsJSI-generated.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/rnmapbox_maps_specsJSI-generated.cpp
new file mode 100644
index 0000000..ac4e424
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/rnmapbox_maps_specsJSI-generated.cpp
@@ -0,0 +1,416 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleCpp.js
+ */
+
+#include "rnmapbox_maps_specsJSI.h"
+
+namespace facebook::react {
+
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_takeSnap(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->takeSnap(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool()
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_queryTerrainElevation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->queryTerrainElevation(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_setSourceVisibility(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->setSourceVisibility(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asString(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_getCenter(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->getCenter(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_getCoordinateFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->getCoordinateFromView(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_getPointInView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->getPointInView(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_getZoom(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->getZoom(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_getVisibleBounds(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->getVisibleBounds(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_queryRenderedFeaturesAtPoint(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->queryRenderedFeaturesAtPoint(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asArray(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_queryRenderedFeaturesInRect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->queryRenderedFeaturesInRect(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asArray(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_setHandledMapChangedEvents(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->setHandledMapChangedEvents(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_clearData(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->clearData(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_querySourceFeatures(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->querySourceFeatures(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asArray(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_setFeatureState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->setFeatureState(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asString(rt),
+    count <= 4 || args[4].isNull() || args[4].isUndefined() ? std::nullopt : std::make_optional(args[4].asString(rt))
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_getFeatureState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->getFeatureState(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asString(rt),
+    count <= 3 || args[3].isNull() || args[3].isUndefined() ? std::nullopt : std::make_optional(args[3].asString(rt))
+  );
+}
+static jsi::Value __hostFunction_NativeMapViewModuleCxxSpecJSI_removeFeatureState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMapViewModuleCxxSpecJSI *>(&turboModule)->removeFeatureState(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asString(rt)),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asString(rt),
+    count <= 4 || args[4].isNull() || args[4].isUndefined() ? std::nullopt : std::make_optional(args[4].asString(rt))
+  );
+}
+
+NativeMapViewModuleCxxSpecJSI::NativeMapViewModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXMapViewModule", jsInvoker) {
+  methodMap_["takeSnap"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleCxxSpecJSI_takeSnap};
+  methodMap_["queryTerrainElevation"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleCxxSpecJSI_queryTerrainElevation};
+  methodMap_["setSourceVisibility"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleCxxSpecJSI_setSourceVisibility};
+  methodMap_["getCenter"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleCxxSpecJSI_getCenter};
+  methodMap_["getCoordinateFromView"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleCxxSpecJSI_getCoordinateFromView};
+  methodMap_["getPointInView"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleCxxSpecJSI_getPointInView};
+  methodMap_["getZoom"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleCxxSpecJSI_getZoom};
+  methodMap_["getVisibleBounds"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleCxxSpecJSI_getVisibleBounds};
+  methodMap_["queryRenderedFeaturesAtPoint"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleCxxSpecJSI_queryRenderedFeaturesAtPoint};
+  methodMap_["queryRenderedFeaturesInRect"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleCxxSpecJSI_queryRenderedFeaturesInRect};
+  methodMap_["setHandledMapChangedEvents"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleCxxSpecJSI_setHandledMapChangedEvents};
+  methodMap_["clearData"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleCxxSpecJSI_clearData};
+  methodMap_["querySourceFeatures"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleCxxSpecJSI_querySourceFeatures};
+  methodMap_["setFeatureState"] = MethodMetadata {5, __hostFunction_NativeMapViewModuleCxxSpecJSI_setFeatureState};
+  methodMap_["getFeatureState"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleCxxSpecJSI_getFeatureState};
+  methodMap_["removeFeatureState"] = MethodMetadata {5, __hostFunction_NativeMapViewModuleCxxSpecJSI_removeFeatureState};
+}
+static jsi::Value __hostFunction_NativeRNMBXCameraModuleCxxSpecJSI_updateCameraStop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXCameraModuleCxxSpecJSI *>(&turboModule)->updateCameraStop(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXCameraModuleCxxSpecJSI_moveBy(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXCameraModuleCxxSpecJSI *>(&turboModule)->moveBy(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber(),
+    count <= 4 ? throw jsi::JSError(rt, "Expected argument in position 4 to be passed") : args[4].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXCameraModuleCxxSpecJSI_scaleBy(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXCameraModuleCxxSpecJSI *>(&turboModule)->scaleBy(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber(),
+    count <= 4 ? throw jsi::JSError(rt, "Expected argument in position 4 to be passed") : args[4].asNumber(),
+    count <= 5 ? throw jsi::JSError(rt, "Expected argument in position 5 to be passed") : args[5].asNumber()
+  );
+}
+
+NativeRNMBXCameraModuleCxxSpecJSI::NativeRNMBXCameraModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXCameraModule", jsInvoker) {
+  methodMap_["updateCameraStop"] = MethodMetadata {2, __hostFunction_NativeRNMBXCameraModuleCxxSpecJSI_updateCameraStop};
+  methodMap_["moveBy"] = MethodMetadata {5, __hostFunction_NativeRNMBXCameraModuleCxxSpecJSI_moveBy};
+  methodMap_["scaleBy"] = MethodMetadata {6, __hostFunction_NativeRNMBXCameraModuleCxxSpecJSI_scaleBy};
+}
+static jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_generate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI *>(&turboModule)->generate(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_setLineString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI *>(&turboModule)->setLineString(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_setStartOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI *>(&turboModule)->setStartOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_setEndOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI *>(&turboModule)->setEndOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+}
+
+NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI::NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXChangeLineOffsetsShapeAnimatorModule", jsInvoker) {
+  methodMap_["generate"] = MethodMetadata {4, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_generate};
+  methodMap_["setLineString"] = MethodMetadata {4, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_setLineString};
+  methodMap_["setStartOffset"] = MethodMetadata {3, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_setStartOffset};
+  methodMap_["setEndOffset"] = MethodMetadata {3, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI_setEndOffset};
+}
+static jsi::Value __hostFunction_NativeRNMBXImageModuleCxxSpecJSI_refresh(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXImageModuleCxxSpecJSI *>(&turboModule)->refresh(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+
+NativeRNMBXImageModuleCxxSpecJSI::NativeRNMBXImageModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXImageModule", jsInvoker) {
+  methodMap_["refresh"] = MethodMetadata {1, __hostFunction_NativeRNMBXImageModuleCxxSpecJSI_refresh};
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_start(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->start(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_stop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->stop(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_setRequestsAlwaysUse(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->setRequestsAlwaysUse(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_setMinDisplacement(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->setMinDisplacement(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_getLastKnownLocation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->getLastKnownLocation(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_simulateHeading(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->simulateHeading(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_setLocationEventThrottle(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRNMBXLocationModuleCxxSpecJSI *>(&turboModule)->setLocationEventThrottle(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeRNMBXLocationModuleCxxSpecJSI::NativeRNMBXLocationModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXLocationModule", jsInvoker) {
+  methodMap_["start"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_start};
+  methodMap_["stop"] = MethodMetadata {0, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_stop};
+  methodMap_["setRequestsAlwaysUse"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_setRequestsAlwaysUse};
+  methodMap_["setMinDisplacement"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_setMinDisplacement};
+  methodMap_["getLastKnownLocation"] = MethodMetadata {0, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_getLastKnownLocation};
+  methodMap_["simulateHeading"] = MethodMetadata {2, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_simulateHeading};
+  methodMap_["setLocationEventThrottle"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleCxxSpecJSI_setLocationEventThrottle};
+}
+static jsi::Value __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI_generate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI *>(&turboModule)->generate(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI_moveTo(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI *>(&turboModule)->moveTo(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+}
+
+NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI::NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXMovePointShapeAnimatorModule", jsInvoker) {
+  methodMap_["generate"] = MethodMetadata {2, __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI_generate};
+  methodMap_["moveTo"] = MethodMetadata {3, __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI_moveTo};
+}
+static jsi::Value __hostFunction_NativeRNMBXPointAnnotationModuleCxxSpecJSI_refresh(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXPointAnnotationModuleCxxSpecJSI *>(&turboModule)->refresh(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+
+NativeRNMBXPointAnnotationModuleCxxSpecJSI::NativeRNMBXPointAnnotationModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXPointAnnotationModule", jsInvoker) {
+  methodMap_["refresh"] = MethodMetadata {1, __hostFunction_NativeRNMBXPointAnnotationModuleCxxSpecJSI_refresh};
+}
+static jsi::Value __hostFunction_NativeRNMBXShapeSourceModuleCxxSpecJSI_getClusterExpansionZoom(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXShapeSourceModuleCxxSpecJSI *>(&turboModule)->getClusterExpansionZoom(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXShapeSourceModuleCxxSpecJSI_getClusterLeaves(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXShapeSourceModuleCxxSpecJSI *>(&turboModule)->getClusterLeaves(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXShapeSourceModuleCxxSpecJSI_getClusterChildren(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXShapeSourceModuleCxxSpecJSI *>(&turboModule)->getClusterChildren(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+
+NativeRNMBXShapeSourceModuleCxxSpecJSI::NativeRNMBXShapeSourceModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXShapeSourceModule", jsInvoker) {
+  methodMap_["getClusterExpansionZoom"] = MethodMetadata {2, __hostFunction_NativeRNMBXShapeSourceModuleCxxSpecJSI_getClusterExpansionZoom};
+  methodMap_["getClusterLeaves"] = MethodMetadata {4, __hostFunction_NativeRNMBXShapeSourceModuleCxxSpecJSI_getClusterLeaves};
+  methodMap_["getClusterChildren"] = MethodMetadata {2, __hostFunction_NativeRNMBXShapeSourceModuleCxxSpecJSI_getClusterChildren};
+}
+static jsi::Value __hostFunction_NativeRNMBXTileStoreModuleCxxSpecJSI_shared(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXTileStoreModuleCxxSpecJSI *>(&turboModule)->shared(
+    rt,
+    count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt))
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXTileStoreModuleCxxSpecJSI_setOption(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXTileStoreModuleCxxSpecJSI *>(&turboModule)->setOption(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asString(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt)
+  );
+}
+
+NativeRNMBXTileStoreModuleCxxSpecJSI::NativeRNMBXTileStoreModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXTileStoreModule", jsInvoker) {
+  methodMap_["shared"] = MethodMetadata {1, __hostFunction_NativeRNMBXTileStoreModuleCxxSpecJSI_shared};
+  methodMap_["setOption"] = MethodMetadata {4, __hostFunction_NativeRNMBXTileStoreModuleCxxSpecJSI_setOption};
+}
+static jsi::Value __hostFunction_NativeRNMBXViewportModuleCxxSpecJSI_getState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXViewportModuleCxxSpecJSI *>(&turboModule)->getState(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXViewportModuleCxxSpecJSI_transitionTo(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXViewportModuleCxxSpecJSI *>(&turboModule)->transitionTo(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeRNMBXViewportModuleCxxSpecJSI_idle(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeRNMBXViewportModuleCxxSpecJSI *>(&turboModule)->idle(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber())
+  );
+}
+
+NativeRNMBXViewportModuleCxxSpecJSI::NativeRNMBXViewportModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMBXViewportModule", jsInvoker) {
+  methodMap_["getState"] = MethodMetadata {1, __hostFunction_NativeRNMBXViewportModuleCxxSpecJSI_getState};
+  methodMap_["transitionTo"] = MethodMetadata {3, __hostFunction_NativeRNMBXViewportModuleCxxSpecJSI_transitionTo};
+  methodMap_["idle"] = MethodMetadata {1, __hostFunction_NativeRNMBXViewportModuleCxxSpecJSI_idle};
+}
+
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/rnmapbox_maps_specsJSI.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/rnmapbox_maps_specsJSI.h
new file mode 100644
index 0000000..e3e86b6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/react/renderer/components/rnmapbox_maps_specs/rnmapbox_maps_specsJSI.h
@@ -0,0 +1,898 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/TurboModule.h>
+#include <react/bridging/Bridging.h>
+
+namespace facebook::react {
+
+
+  class JSI_EXPORT NativeMapViewModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeMapViewModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value takeSnap(jsi::Runtime &rt, std::optional<int> viewRef, bool writeToDisk) = 0;
+  virtual jsi::Value queryTerrainElevation(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array coordinates) = 0;
+  virtual jsi::Value setSourceVisibility(jsi::Runtime &rt, std::optional<int> viewRef, bool visible, jsi::String sourceId, jsi::String sourceLayerId) = 0;
+  virtual jsi::Value getCenter(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+  virtual jsi::Value getCoordinateFromView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint) = 0;
+  virtual jsi::Value getPointInView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atCoordinate) = 0;
+  virtual jsi::Value getZoom(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+  virtual jsi::Value getVisibleBounds(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+  virtual jsi::Value queryRenderedFeaturesAtPoint(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint, jsi::Array withFilter, jsi::Array withLayerIDs) = 0;
+  virtual jsi::Value queryRenderedFeaturesInRect(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array withBBox, jsi::Array withFilter, jsi::Array withLayerIDs) = 0;
+  virtual jsi::Value setHandledMapChangedEvents(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array events) = 0;
+  virtual jsi::Value clearData(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+  virtual jsi::Value querySourceFeatures(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String sourceId, jsi::Array withFilter, jsi::Array withSourceLayerIDs) = 0;
+  virtual jsi::Value setFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::Object state, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) = 0;
+  virtual jsi::Value getFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) = 0;
+  virtual jsi::Value removeFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, std::optional<jsi::String> stateKey, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeMapViewModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXMapViewModule";
+
+protected:
+  NativeMapViewModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeMapViewModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeMapViewModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeMapViewModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value takeSnap(jsi::Runtime &rt, std::optional<int> viewRef, bool writeToDisk) override {
+      static_assert(
+          bridging::getParameterCount(&T::takeSnap) == 3,
+          "Expected takeSnap(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::takeSnap, jsInvoker_, instance_, std::move(viewRef), std::move(writeToDisk));
+    }
+    jsi::Value queryTerrainElevation(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array coordinates) override {
+      static_assert(
+          bridging::getParameterCount(&T::queryTerrainElevation) == 3,
+          "Expected queryTerrainElevation(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::queryTerrainElevation, jsInvoker_, instance_, std::move(viewRef), std::move(coordinates));
+    }
+    jsi::Value setSourceVisibility(jsi::Runtime &rt, std::optional<int> viewRef, bool visible, jsi::String sourceId, jsi::String sourceLayerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::setSourceVisibility) == 5,
+          "Expected setSourceVisibility(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setSourceVisibility, jsInvoker_, instance_, std::move(viewRef), std::move(visible), std::move(sourceId), std::move(sourceLayerId));
+    }
+    jsi::Value getCenter(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCenter) == 2,
+          "Expected getCenter(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getCenter, jsInvoker_, instance_, std::move(viewRef));
+    }
+    jsi::Value getCoordinateFromView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCoordinateFromView) == 3,
+          "Expected getCoordinateFromView(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getCoordinateFromView, jsInvoker_, instance_, std::move(viewRef), std::move(atPoint));
+    }
+    jsi::Value getPointInView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atCoordinate) override {
+      static_assert(
+          bridging::getParameterCount(&T::getPointInView) == 3,
+          "Expected getPointInView(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getPointInView, jsInvoker_, instance_, std::move(viewRef), std::move(atCoordinate));
+    }
+    jsi::Value getZoom(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::getZoom) == 2,
+          "Expected getZoom(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getZoom, jsInvoker_, instance_, std::move(viewRef));
+    }
+    jsi::Value getVisibleBounds(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::getVisibleBounds) == 2,
+          "Expected getVisibleBounds(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getVisibleBounds, jsInvoker_, instance_, std::move(viewRef));
+    }
+    jsi::Value queryRenderedFeaturesAtPoint(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint, jsi::Array withFilter, jsi::Array withLayerIDs) override {
+      static_assert(
+          bridging::getParameterCount(&T::queryRenderedFeaturesAtPoint) == 5,
+          "Expected queryRenderedFeaturesAtPoint(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::queryRenderedFeaturesAtPoint, jsInvoker_, instance_, std::move(viewRef), std::move(atPoint), std::move(withFilter), std::move(withLayerIDs));
+    }
+    jsi::Value queryRenderedFeaturesInRect(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array withBBox, jsi::Array withFilter, jsi::Array withLayerIDs) override {
+      static_assert(
+          bridging::getParameterCount(&T::queryRenderedFeaturesInRect) == 5,
+          "Expected queryRenderedFeaturesInRect(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::queryRenderedFeaturesInRect, jsInvoker_, instance_, std::move(viewRef), std::move(withBBox), std::move(withFilter), std::move(withLayerIDs));
+    }
+    jsi::Value setHandledMapChangedEvents(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array events) override {
+      static_assert(
+          bridging::getParameterCount(&T::setHandledMapChangedEvents) == 3,
+          "Expected setHandledMapChangedEvents(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setHandledMapChangedEvents, jsInvoker_, instance_, std::move(viewRef), std::move(events));
+    }
+    jsi::Value clearData(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::clearData) == 2,
+          "Expected clearData(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::clearData, jsInvoker_, instance_, std::move(viewRef));
+    }
+    jsi::Value querySourceFeatures(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String sourceId, jsi::Array withFilter, jsi::Array withSourceLayerIDs) override {
+      static_assert(
+          bridging::getParameterCount(&T::querySourceFeatures) == 5,
+          "Expected querySourceFeatures(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::querySourceFeatures, jsInvoker_, instance_, std::move(viewRef), std::move(sourceId), std::move(withFilter), std::move(withSourceLayerIDs));
+    }
+    jsi::Value setFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::Object state, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::setFeatureState) == 6,
+          "Expected setFeatureState(...) to have 6 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setFeatureState, jsInvoker_, instance_, std::move(viewRef), std::move(featureId), std::move(state), std::move(sourceId), std::move(sourceLayerId));
+    }
+    jsi::Value getFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::getFeatureState) == 5,
+          "Expected getFeatureState(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getFeatureState, jsInvoker_, instance_, std::move(viewRef), std::move(featureId), std::move(sourceId), std::move(sourceLayerId));
+    }
+    jsi::Value removeFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, std::optional<jsi::String> stateKey, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeFeatureState) == 6,
+          "Expected removeFeatureState(...) to have 6 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::removeFeatureState, jsInvoker_, instance_, std::move(viewRef), std::move(featureId), std::move(stateKey), std::move(sourceId), std::move(sourceLayerId));
+    }
+
+  private:
+    friend class NativeMapViewModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXCameraModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXCameraModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value updateCameraStop(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object stop) = 0;
+  virtual jsi::Value moveBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration) = 0;
+  virtual jsi::Value scaleBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration, double scaleFactor) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXCameraModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXCameraModule";
+
+protected:
+  NativeRNMBXCameraModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXCameraModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXCameraModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXCameraModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value updateCameraStop(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object stop) override {
+      static_assert(
+          bridging::getParameterCount(&T::updateCameraStop) == 3,
+          "Expected updateCameraStop(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::updateCameraStop, jsInvoker_, instance_, std::move(viewRef), std::move(stop));
+    }
+    jsi::Value moveBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration) override {
+      static_assert(
+          bridging::getParameterCount(&T::moveBy) == 6,
+          "Expected moveBy(...) to have 6 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::moveBy, jsInvoker_, instance_, std::move(viewRef), std::move(x), std::move(y), std::move(animationMode), std::move(animationDuration));
+    }
+    jsi::Value scaleBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration, double scaleFactor) override {
+      static_assert(
+          bridging::getParameterCount(&T::scaleBy) == 7,
+          "Expected scaleBy(...) to have 7 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::scaleBy, jsInvoker_, instance_, std::move(viewRef), std::move(x), std::move(y), std::move(animationMode), std::move(animationDuration), std::move(scaleFactor));
+    }
+
+  private:
+    friend class NativeRNMBXCameraModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) = 0;
+  virtual jsi::Value setLineString(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) = 0;
+  virtual jsi::Value setStartOffset(jsi::Runtime &rt, int tag, double offset, double duration) = 0;
+  virtual jsi::Value setEndOffset(jsi::Runtime &rt, int tag, double offset, double duration) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXChangeLineOffsetsShapeAnimatorModule";
+
+protected:
+  NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) override {
+      static_assert(
+          bridging::getParameterCount(&T::generate) == 5,
+          "Expected generate(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::generate, jsInvoker_, instance_, std::move(tag), std::move(coordinates), std::move(startOffset), std::move(endOffset));
+    }
+    jsi::Value setLineString(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) override {
+      static_assert(
+          bridging::getParameterCount(&T::setLineString) == 5,
+          "Expected setLineString(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setLineString, jsInvoker_, instance_, std::move(tag), std::move(coordinates), std::move(startOffset), std::move(endOffset));
+    }
+    jsi::Value setStartOffset(jsi::Runtime &rt, int tag, double offset, double duration) override {
+      static_assert(
+          bridging::getParameterCount(&T::setStartOffset) == 4,
+          "Expected setStartOffset(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setStartOffset, jsInvoker_, instance_, std::move(tag), std::move(offset), std::move(duration));
+    }
+    jsi::Value setEndOffset(jsi::Runtime &rt, int tag, double offset, double duration) override {
+      static_assert(
+          bridging::getParameterCount(&T::setEndOffset) == 4,
+          "Expected setEndOffset(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setEndOffset, jsInvoker_, instance_, std::move(tag), std::move(offset), std::move(duration));
+    }
+
+  private:
+    friend class NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXImageModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXImageModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXImageModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXImageModule";
+
+protected:
+  NativeRNMBXImageModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXImageModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXImageModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXImageModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::refresh) == 2,
+          "Expected refresh(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::refresh, jsInvoker_, instance_, std::move(viewRef));
+    }
+
+  private:
+    friend class NativeRNMBXImageModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeRNMBXLocationModuleLocationEvent
+
+template <typename P0, typename P1>
+struct NativeRNMBXLocationModuleLocationEvent {
+  P0 type;
+  P1 payload;
+  bool operator==(const NativeRNMBXLocationModuleLocationEvent &other) const {
+    return type == other.type && payload == other.payload;
+  }
+};
+
+template <typename T>
+struct NativeRNMBXLocationModuleLocationEventBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
+      bridging::fromJs<decltype(types.payload)>(rt, value.getProperty(rt, "payload"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object payloadToJs(jsi::Runtime &rt, decltype(types.payload) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
+    result.setProperty(rt, "payload", bridging::toJs(rt, value.payload, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeRNMBXLocationModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXLocationModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void start(jsi::Runtime &rt, double minDisplacement) = 0;
+  virtual void stop(jsi::Runtime &rt) = 0;
+  virtual void setRequestsAlwaysUse(jsi::Runtime &rt, bool requestsAlwaysUse) = 0;
+  virtual void setMinDisplacement(jsi::Runtime &rt, double minDisplacement) = 0;
+  virtual jsi::Value getLastKnownLocation(jsi::Runtime &rt) = 0;
+  virtual void simulateHeading(jsi::Runtime &rt, double changesPerSecond, double increment) = 0;
+  virtual void setLocationEventThrottle(jsi::Runtime &rt, double throttle) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXLocationModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXLocationModule";
+
+protected:
+  NativeRNMBXLocationModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXLocationModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+  template <typename OnLocationUpdateType> void emitOnLocationUpdate(OnLocationUpdateType value) {
+    static_assert(bridging::supportsFromJs<OnLocationUpdateType, jsi::Object>, "value cannnot be converted to jsi::Object");
+    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onLocationUpdate"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
+      return bridging::toJs(rt, eventValue, jsInvoker);
+    });
+  }
+
+private:
+  class Delegate : public NativeRNMBXLocationModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXLocationModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+      eventEmitterMap_["onLocationUpdate"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
+    }
+
+    void start(jsi::Runtime &rt, double minDisplacement) override {
+      static_assert(
+          bridging::getParameterCount(&T::start) == 2,
+          "Expected start(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::start, jsInvoker_, instance_, std::move(minDisplacement));
+    }
+    void stop(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::stop) == 1,
+          "Expected stop(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::stop, jsInvoker_, instance_);
+    }
+    void setRequestsAlwaysUse(jsi::Runtime &rt, bool requestsAlwaysUse) override {
+      static_assert(
+          bridging::getParameterCount(&T::setRequestsAlwaysUse) == 2,
+          "Expected setRequestsAlwaysUse(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setRequestsAlwaysUse, jsInvoker_, instance_, std::move(requestsAlwaysUse));
+    }
+    void setMinDisplacement(jsi::Runtime &rt, double minDisplacement) override {
+      static_assert(
+          bridging::getParameterCount(&T::setMinDisplacement) == 2,
+          "Expected setMinDisplacement(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setMinDisplacement, jsInvoker_, instance_, std::move(minDisplacement));
+    }
+    jsi::Value getLastKnownLocation(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getLastKnownLocation) == 1,
+          "Expected getLastKnownLocation(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getLastKnownLocation, jsInvoker_, instance_);
+    }
+    void simulateHeading(jsi::Runtime &rt, double changesPerSecond, double increment) override {
+      static_assert(
+          bridging::getParameterCount(&T::simulateHeading) == 3,
+          "Expected simulateHeading(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::simulateHeading, jsInvoker_, instance_, std::move(changesPerSecond), std::move(increment));
+    }
+    void setLocationEventThrottle(jsi::Runtime &rt, double throttle) override {
+      static_assert(
+          bridging::getParameterCount(&T::setLocationEventThrottle) == 2,
+          "Expected setLocationEventThrottle(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setLocationEventThrottle, jsInvoker_, instance_, std::move(throttle));
+    }
+
+  private:
+    friend class NativeRNMBXLocationModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinate) = 0;
+  virtual jsi::Value moveTo(jsi::Runtime &rt, int tag, jsi::Array coordinate, double duration) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXMovePointShapeAnimatorModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXMovePointShapeAnimatorModule";
+
+protected:
+  NativeRNMBXMovePointShapeAnimatorModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXMovePointShapeAnimatorModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinate) override {
+      static_assert(
+          bridging::getParameterCount(&T::generate) == 3,
+          "Expected generate(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::generate, jsInvoker_, instance_, std::move(tag), std::move(coordinate));
+    }
+    jsi::Value moveTo(jsi::Runtime &rt, int tag, jsi::Array coordinate, double duration) override {
+      static_assert(
+          bridging::getParameterCount(&T::moveTo) == 4,
+          "Expected moveTo(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::moveTo, jsInvoker_, instance_, std::move(tag), std::move(coordinate), std::move(duration));
+    }
+
+  private:
+    friend class NativeRNMBXMovePointShapeAnimatorModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXPointAnnotationModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXPointAnnotationModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXPointAnnotationModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXPointAnnotationModule";
+
+protected:
+  NativeRNMBXPointAnnotationModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXPointAnnotationModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXPointAnnotationModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXPointAnnotationModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::refresh) == 2,
+          "Expected refresh(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::refresh, jsInvoker_, instance_, std::move(viewRef));
+    }
+
+  private:
+    friend class NativeRNMBXPointAnnotationModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXShapeSourceModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXShapeSourceModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getClusterExpansionZoom(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) = 0;
+  virtual jsi::Value getClusterLeaves(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON, int number, int offset) = 0;
+  virtual jsi::Value getClusterChildren(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXShapeSourceModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXShapeSourceModule";
+
+protected:
+  NativeRNMBXShapeSourceModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXShapeSourceModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXShapeSourceModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXShapeSourceModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getClusterExpansionZoom(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) override {
+      static_assert(
+          bridging::getParameterCount(&T::getClusterExpansionZoom) == 3,
+          "Expected getClusterExpansionZoom(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getClusterExpansionZoom, jsInvoker_, instance_, std::move(viewRef), std::move(featureJSON));
+    }
+    jsi::Value getClusterLeaves(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON, int number, int offset) override {
+      static_assert(
+          bridging::getParameterCount(&T::getClusterLeaves) == 5,
+          "Expected getClusterLeaves(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getClusterLeaves, jsInvoker_, instance_, std::move(viewRef), std::move(featureJSON), std::move(number), std::move(offset));
+    }
+    jsi::Value getClusterChildren(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) override {
+      static_assert(
+          bridging::getParameterCount(&T::getClusterChildren) == 3,
+          "Expected getClusterChildren(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getClusterChildren, jsInvoker_, instance_, std::move(viewRef), std::move(featureJSON));
+    }
+
+  private:
+    friend class NativeRNMBXShapeSourceModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXTileStoreModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXTileStoreModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value shared(jsi::Runtime &rt, std::optional<jsi::String> path) = 0;
+  virtual jsi::Value setOption(jsi::Runtime &rt, int tag, jsi::String key, jsi::String domain, jsi::Object value) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXTileStoreModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXTileStoreModule";
+
+protected:
+  NativeRNMBXTileStoreModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXTileStoreModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXTileStoreModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXTileStoreModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value shared(jsi::Runtime &rt, std::optional<jsi::String> path) override {
+      static_assert(
+          bridging::getParameterCount(&T::shared) == 2,
+          "Expected shared(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::shared, jsInvoker_, instance_, std::move(path));
+    }
+    jsi::Value setOption(jsi::Runtime &rt, int tag, jsi::String key, jsi::String domain, jsi::Object value) override {
+      static_assert(
+          bridging::getParameterCount(&T::setOption) == 5,
+          "Expected setOption(...) to have 5 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::setOption, jsInvoker_, instance_, std::move(tag), std::move(key), std::move(domain), std::move(value));
+    }
+
+  private:
+    friend class NativeRNMBXTileStoreModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRNMBXViewportModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeRNMBXViewportModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getState(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+  virtual jsi::Value transitionTo(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object state, jsi::Object transition) = 0;
+  virtual jsi::Value idle(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRNMBXViewportModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMBXViewportModule";
+
+protected:
+  NativeRNMBXViewportModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRNMBXViewportModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRNMBXViewportModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRNMBXViewportModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getState(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::getState) == 2,
+          "Expected getState(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getState, jsInvoker_, instance_, std::move(viewRef));
+    }
+    jsi::Value transitionTo(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object state, jsi::Object transition) override {
+      static_assert(
+          bridging::getParameterCount(&T::transitionTo) == 4,
+          "Expected transitionTo(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::transitionTo, jsInvoker_, instance_, std::move(viewRef), std::move(state), std::move(transition));
+    }
+    jsi::Value idle(jsi::Runtime &rt, std::optional<int> viewRef) override {
+      static_assert(
+          bridging::getParameterCount(&T::idle) == 2,
+          "Expected idle(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::idle, jsInvoker_, instance_, std::move(viewRef));
+    }
+
+  private:
+    friend class NativeRNMBXViewportModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/rnmapbox_maps_specs-generated.cpp b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/rnmapbox_maps_specs-generated.cpp
new file mode 100644
index 0000000..25fd400
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/rnmapbox_maps_specs-generated.cpp
@@ -0,0 +1,334 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniCpp.js
+ */
+
+#include "rnmapbox_maps_specs.h"
+
+namespace facebook::react {
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_takeSnap(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "takeSnap", "(Ljava/lang/Double;ZLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_queryTerrainElevation(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "queryTerrainElevation", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_setSourceVisibility(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setSourceVisibility", "(Ljava/lang/Double;ZLjava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_getCenter(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getCenter", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_getCoordinateFromView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getCoordinateFromView", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_getPointInView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getPointInView", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_getZoom(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getZoom", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_getVisibleBounds(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getVisibleBounds", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_queryRenderedFeaturesAtPoint(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "queryRenderedFeaturesAtPoint", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_queryRenderedFeaturesInRect(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "queryRenderedFeaturesInRect", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_setHandledMapChangedEvents(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setHandledMapChangedEvents", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_clearData(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "clearData", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_querySourceFeatures(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "querySourceFeatures", "(Ljava/lang/Double;Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_setFeatureState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setFeatureState", "(Ljava/lang/Double;Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Ljava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_getFeatureState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getFeatureState", "(Ljava/lang/Double;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeMapViewModuleSpecJSI_removeFeatureState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "removeFeatureState", "(Ljava/lang/Double;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeMapViewModuleSpecJSI::NativeMapViewModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["takeSnap"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleSpecJSI_takeSnap};
+  methodMap_["queryTerrainElevation"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleSpecJSI_queryTerrainElevation};
+  methodMap_["setSourceVisibility"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleSpecJSI_setSourceVisibility};
+  methodMap_["getCenter"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleSpecJSI_getCenter};
+  methodMap_["getCoordinateFromView"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleSpecJSI_getCoordinateFromView};
+  methodMap_["getPointInView"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleSpecJSI_getPointInView};
+  methodMap_["getZoom"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleSpecJSI_getZoom};
+  methodMap_["getVisibleBounds"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleSpecJSI_getVisibleBounds};
+  methodMap_["queryRenderedFeaturesAtPoint"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleSpecJSI_queryRenderedFeaturesAtPoint};
+  methodMap_["queryRenderedFeaturesInRect"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleSpecJSI_queryRenderedFeaturesInRect};
+  methodMap_["setHandledMapChangedEvents"] = MethodMetadata {2, __hostFunction_NativeMapViewModuleSpecJSI_setHandledMapChangedEvents};
+  methodMap_["clearData"] = MethodMetadata {1, __hostFunction_NativeMapViewModuleSpecJSI_clearData};
+  methodMap_["querySourceFeatures"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleSpecJSI_querySourceFeatures};
+  methodMap_["setFeatureState"] = MethodMetadata {5, __hostFunction_NativeMapViewModuleSpecJSI_setFeatureState};
+  methodMap_["getFeatureState"] = MethodMetadata {4, __hostFunction_NativeMapViewModuleSpecJSI_getFeatureState};
+  methodMap_["removeFeatureState"] = MethodMetadata {5, __hostFunction_NativeMapViewModuleSpecJSI_removeFeatureState};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXCameraModuleSpecJSI_updateCameraStop(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "updateCameraStop", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXCameraModuleSpecJSI_moveBy(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "moveBy", "(Ljava/lang/Double;DDDDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXCameraModuleSpecJSI_scaleBy(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "scaleBy", "(Ljava/lang/Double;DDDDDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXCameraModuleSpecJSI::NativeRNMBXCameraModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["updateCameraStop"] = MethodMetadata {2, __hostFunction_NativeRNMBXCameraModuleSpecJSI_updateCameraStop};
+  methodMap_["moveBy"] = MethodMetadata {5, __hostFunction_NativeRNMBXCameraModuleSpecJSI_moveBy};
+  methodMap_["scaleBy"] = MethodMetadata {6, __hostFunction_NativeRNMBXCameraModuleSpecJSI_scaleBy};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_generate(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "generate", "(DLcom/facebook/react/bridge/ReadableArray;DDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_setLineString(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setLineString", "(DLcom/facebook/react/bridge/ReadableArray;DDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_setStartOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setStartOffset", "(DDDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_setEndOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setEndOffset", "(DDDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI::NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["generate"] = MethodMetadata {4, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_generate};
+  methodMap_["setLineString"] = MethodMetadata {4, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_setLineString};
+  methodMap_["setStartOffset"] = MethodMetadata {3, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_setStartOffset};
+  methodMap_["setEndOffset"] = MethodMetadata {3, __hostFunction_NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI_setEndOffset};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXImageModuleSpecJSI_refresh(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "refresh", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXImageModuleSpecJSI::NativeRNMBXImageModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["refresh"] = MethodMetadata {1, __hostFunction_NativeRNMBXImageModuleSpecJSI_refresh};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_start(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "start", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_stop(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "stop", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_setRequestsAlwaysUse(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setRequestsAlwaysUse", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_setMinDisplacement(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setMinDisplacement", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_getLastKnownLocation(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getLastKnownLocation", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_simulateHeading(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "simulateHeading", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXLocationModuleSpecJSI_setLocationEventThrottle(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setLocationEventThrottle", "(D)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXLocationModuleSpecJSI::NativeRNMBXLocationModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["start"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleSpecJSI_start};
+  methodMap_["stop"] = MethodMetadata {0, __hostFunction_NativeRNMBXLocationModuleSpecJSI_stop};
+  methodMap_["setRequestsAlwaysUse"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleSpecJSI_setRequestsAlwaysUse};
+  methodMap_["setMinDisplacement"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleSpecJSI_setMinDisplacement};
+  methodMap_["getLastKnownLocation"] = MethodMetadata {0, __hostFunction_NativeRNMBXLocationModuleSpecJSI_getLastKnownLocation};
+  methodMap_["simulateHeading"] = MethodMetadata {2, __hostFunction_NativeRNMBXLocationModuleSpecJSI_simulateHeading};
+  methodMap_["setLocationEventThrottle"] = MethodMetadata {1, __hostFunction_NativeRNMBXLocationModuleSpecJSI_setLocationEventThrottle};
+  eventEmitterMap_["onLocationUpdate"] = std::make_shared<AsyncEventEmitter<folly::dynamic>>();
+  setEventEmitterCallback(params.instance);
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleSpecJSI_generate(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "generate", "(DLcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleSpecJSI_moveTo(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "moveTo", "(DLcom/facebook/react/bridge/ReadableArray;DLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXMovePointShapeAnimatorModuleSpecJSI::NativeRNMBXMovePointShapeAnimatorModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["generate"] = MethodMetadata {2, __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleSpecJSI_generate};
+  methodMap_["moveTo"] = MethodMetadata {3, __hostFunction_NativeRNMBXMovePointShapeAnimatorModuleSpecJSI_moveTo};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXPointAnnotationModuleSpecJSI_refresh(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "refresh", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXPointAnnotationModuleSpecJSI::NativeRNMBXPointAnnotationModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["refresh"] = MethodMetadata {1, __hostFunction_NativeRNMBXPointAnnotationModuleSpecJSI_refresh};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXShapeSourceModuleSpecJSI_getClusterExpansionZoom(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getClusterExpansionZoom", "(Ljava/lang/Double;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXShapeSourceModuleSpecJSI_getClusterLeaves(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getClusterLeaves", "(Ljava/lang/Double;Ljava/lang/String;DDLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXShapeSourceModuleSpecJSI_getClusterChildren(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getClusterChildren", "(Ljava/lang/Double;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXShapeSourceModuleSpecJSI::NativeRNMBXShapeSourceModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getClusterExpansionZoom"] = MethodMetadata {2, __hostFunction_NativeRNMBXShapeSourceModuleSpecJSI_getClusterExpansionZoom};
+  methodMap_["getClusterLeaves"] = MethodMetadata {4, __hostFunction_NativeRNMBXShapeSourceModuleSpecJSI_getClusterLeaves};
+  methodMap_["getClusterChildren"] = MethodMetadata {2, __hostFunction_NativeRNMBXShapeSourceModuleSpecJSI_getClusterChildren};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXTileStoreModuleSpecJSI_shared(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "shared", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXTileStoreModuleSpecJSI_setOption(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "setOption", "(DLjava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXTileStoreModuleSpecJSI::NativeRNMBXTileStoreModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["shared"] = MethodMetadata {1, __hostFunction_NativeRNMBXTileStoreModuleSpecJSI_shared};
+  methodMap_["setOption"] = MethodMetadata {4, __hostFunction_NativeRNMBXTileStoreModuleSpecJSI_setOption};
+}
+static facebook::jsi::Value __hostFunction_NativeRNMBXViewportModuleSpecJSI_getState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getState", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXViewportModuleSpecJSI_transitionTo(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "transitionTo", "(Ljava/lang/Double;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRNMBXViewportModuleSpecJSI_idle(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "idle", "(Ljava/lang/Double;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeRNMBXViewportModuleSpecJSI::NativeRNMBXViewportModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getState"] = MethodMetadata {1, __hostFunction_NativeRNMBXViewportModuleSpecJSI_getState};
+  methodMap_["transitionTo"] = MethodMetadata {3, __hostFunction_NativeRNMBXViewportModuleSpecJSI_transitionTo};
+  methodMap_["idle"] = MethodMetadata {1, __hostFunction_NativeRNMBXViewportModuleSpecJSI_idle};
+}
+
+std::shared_ptr<TurboModule> rnmapbox_maps_specs_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params) {
+  if (moduleName == "RNMBXCameraModule") {
+    return std::make_shared<NativeRNMBXCameraModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXChangeLineOffsetsShapeAnimatorModule") {
+    return std::make_shared<NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXImageModule") {
+    return std::make_shared<NativeRNMBXImageModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXLocationModule") {
+    return std::make_shared<NativeRNMBXLocationModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXMapViewModule") {
+    return std::make_shared<NativeMapViewModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXMovePointShapeAnimatorModule") {
+    return std::make_shared<NativeRNMBXMovePointShapeAnimatorModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXPointAnnotationModule") {
+    return std::make_shared<NativeRNMBXPointAnnotationModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXShapeSourceModule") {
+    return std::make_shared<NativeRNMBXShapeSourceModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXTileStoreModule") {
+    return std::make_shared<NativeRNMBXTileStoreModuleSpecJSI>(params);
+  }
+  if (moduleName == "RNMBXViewportModule") {
+    return std::make_shared<NativeRNMBXViewportModuleSpecJSI>(params);
+  }
+  return nullptr;
+}
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/rnmapbox_maps_specs.h b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/rnmapbox_maps_specs.h
new file mode 100644
index 0000000..c1c63de
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/jni/rnmapbox_maps_specs.h
@@ -0,0 +1,103 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/JavaTurboModule.h>
+#include <ReactCommon/TurboModule.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+/**
+ * JNI C++ class for module 'NativeMapViewModule'
+ */
+class JSI_EXPORT NativeMapViewModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeMapViewModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXCameraModule'
+ */
+class JSI_EXPORT NativeRNMBXCameraModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXCameraModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXChangeLineOffsetsShapeAnimatorModule'
+ */
+class JSI_EXPORT NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXChangeLineOffsetsShapeAnimatorModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXImageModule'
+ */
+class JSI_EXPORT NativeRNMBXImageModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXImageModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXLocationModule'
+ */
+class JSI_EXPORT NativeRNMBXLocationModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXLocationModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXMovePointShapeAnimatorModule'
+ */
+class JSI_EXPORT NativeRNMBXMovePointShapeAnimatorModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXMovePointShapeAnimatorModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXPointAnnotationModule'
+ */
+class JSI_EXPORT NativeRNMBXPointAnnotationModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXPointAnnotationModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXShapeSourceModule'
+ */
+class JSI_EXPORT NativeRNMBXShapeSourceModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXShapeSourceModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXTileStoreModule'
+ */
+class JSI_EXPORT NativeRNMBXTileStoreModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXTileStoreModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRNMBXViewportModule'
+ */
+class JSI_EXPORT NativeRNMBXViewportModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeRNMBXViewportModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+
+JSI_EXPORT
+std::shared_ptr<TurboModule> rnmapbox_maps_specs_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);
+
+} // namespace facebook::react
diff --git a/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/schema.json b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/schema.json
new file mode 100644
index 0000000..7441548
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/generated/source/codegen/schema.json
@@ -0,0 +1 @@
+{"modules":{"NativeMapViewModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"takeSnap","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"writeToDisk","optional":false,"typeAnnotation":{"type":"BooleanTypeAnnotation"}}]}},{"name":"queryTerrainElevation","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"coordinates","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}}}]}},{"name":"setSourceVisibility","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"visible","optional":false,"typeAnnotation":{"type":"BooleanTypeAnnotation"}},{"name":"sourceId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"sourceLayerId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"getCenter","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}},{"name":"getCoordinateFromView","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"atPoint","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}}}]}},{"name":"getPointInView","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"atCoordinate","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}}}]}},{"name":"getZoom","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}},{"name":"getVisibleBounds","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}},{"name":"queryRenderedFeaturesAtPoint","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"atPoint","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}}},{"name":"withFilter","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}}},{"name":"withLayerIDs","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}}]}},{"name":"queryRenderedFeaturesInRect","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"withBBox","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}}},{"name":"withFilter","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}}},{"name":"withLayerIDs","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}}]}},{"name":"setHandledMapChangedEvents","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"events","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}}]}},{"name":"clearData","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}},{"name":"querySourceFeatures","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"sourceId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"withFilter","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}}},{"name":"withSourceLayerIDs","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}}]}},{"name":"setFeatureState","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"featureId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"state","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}},{"name":"sourceId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"sourceLayerId","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"StringTypeAnnotation"}}}]}},{"name":"getFeatureState","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"featureId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"sourceId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"sourceLayerId","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"StringTypeAnnotation"}}}]}},{"name":"removeFeatureState","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"featureId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"stateKey","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"StringTypeAnnotation"}}},{"name":"sourceId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"sourceLayerId","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"StringTypeAnnotation"}}}]}}]},"moduleName":"RNMBXMapViewModule"},"NativeRNMBXCameraModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"updateCameraStop","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"stop","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}}]}},{"name":"moveBy","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"x","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"y","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"animationMode","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"animationDuration","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}},{"name":"scaleBy","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"x","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"y","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"animationMode","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"animationDuration","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"scaleFactor","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}}]},"moduleName":"RNMBXCameraModule"},"NativeRNMBXChangeLineOffsetsShapeAnimatorModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"generate","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"coordinates","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},{"name":"startOffset","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}},{"name":"endOffset","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}}]}},{"name":"setLineString","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"coordinates","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},{"name":"startOffset","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"endOffset","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}},{"name":"setStartOffset","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"offset","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}},{"name":"duration","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}}]}},{"name":"setEndOffset","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"offset","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}},{"name":"duration","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}}]}}]},"moduleName":"RNMBXChangeLineOffsetsShapeAnimatorModule"},"NativeRNMBXImageModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"refresh","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}}]},"moduleName":"RNMBXImageModule"},"NativeRNMBXLocationModule":{"type":"NativeModule","aliasMap":{"LocationEvent":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"ObjectTypeAnnotation","properties":[{"name":"coords","optional":false,"typeAnnotation":{"type":"ObjectTypeAnnotation","properties":[{"name":"latitude","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"longitude","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"altitude","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"accuracy","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"speed","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"heading","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}},{"name":"timestamp","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}}]}},"enumMap":{},"spec":{"eventEmitters":[{"name":"onLocationUpdate","optional":false,"typeAnnotation":{"type":"EventEmitterTypeAnnotation","typeAnnotation":{"type":"TypeAliasTypeAnnotation","name":"LocationEvent"}}}],"methods":[{"name":"start","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"minDisplacement","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}},{"name":"stop","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[]}},{"name":"setRequestsAlwaysUse","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"requestsAlwaysUse","optional":false,"typeAnnotation":{"type":"BooleanTypeAnnotation"}}]}},{"name":"setMinDisplacement","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"minDisplacement","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}},{"name":"getLastKnownLocation","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[]}},{"name":"simulateHeading","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"changesPerSecond","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"increment","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}},{"name":"setLocationEventThrottle","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"throttle","optional":false,"typeAnnotation":{"type":"NumberTypeAnnotation"}}]}}]},"moduleName":"RNMBXLocationModule"},"NativeRNMBXMovePointShapeAnimatorModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"generate","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"coordinate","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"DoubleTypeAnnotation"}}}]}},{"name":"moveTo","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"coordinate","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"DoubleTypeAnnotation"}}},{"name":"duration","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}}]}}]},"moduleName":"RNMBXMovePointShapeAnimatorModule"},"NativeRNMBXPointAnnotationModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"refresh","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}}]},"moduleName":"RNMBXPointAnnotationModule"},"NativeRNMBXShapeSourceModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"getClusterExpansionZoom","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"featureJSON","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"getClusterLeaves","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"featureJSON","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"number","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"offset","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}}]}},{"name":"getClusterChildren","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"GenericObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"featureJSON","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}]},"moduleName":"RNMBXShapeSourceModule"},"NativeRNMBXTileStoreModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"shared","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"Int32TypeAnnotation"}},"params":[{"name":"path","optional":true,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"setOption","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"tag","optional":false,"typeAnnotation":{"type":"Int32TypeAnnotation"}},{"name":"key","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"domain","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"value","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}}]}}]},"moduleName":"RNMBXTileStoreModule"},"NativeRNMBXViewportModule":{"type":"NativeModule","aliasMap":{},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"getState","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"UnionTypeAnnotation","memberType":"ObjectTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}},{"name":"transitionTo","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}},{"name":"state","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}},{"name":"transition","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}}]}},{"name":"idle","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"viewRef","optional":false,"typeAnnotation":{"type":"NullableTypeAnnotation","typeAnnotation":{"type":"Int32TypeAnnotation"}}}]}}]},"moduleName":"RNMBXViewportModule"},"RNMBXAtmosphere":{"type":"Component","components":{"RNMBXAtmosphere":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXBackgroundLayer":{"type":"Component","components":{"RNMBXBackgroundLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceID","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXCallout":{"type":"Component","components":{"RNMBXCallout":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[],"commands":[]}}},"RNMBXCameraGestureObserver":{"type":"Component","components":{"RNMBXCameraGestureObserver":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onMapSteady","optional":true,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"reason","optional":false,"typeAnnotation":{"type":"StringLiteralUnionTypeAnnotation","types":[{"type":"StringLiteralTypeAnnotation","value":"steady"},{"type":"StringLiteralTypeAnnotation","value":"timeout"}]}},{"name":"idleDurationMs","optional":true,"typeAnnotation":{"type":"DoubleTypeAnnotation"}},{"name":"lastGestureType","optional":true,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"timestamp","optional":false,"typeAnnotation":{"type":"DoubleTypeAnnotation"}}]}}}],"props":[{"name":"quietPeriodMs","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxIntervalMs","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hasOnMapSteady","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXCamera":{"type":"Component","components":{"RNMBXCamera":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onUserTrackingModeChange","optional":true,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payloadRenamed","optional":false,"typeAnnotation":{"type":"ObjectTypeAnnotation","properties":[{"name":"followUserLocation","optional":false,"typeAnnotation":{"type":"BooleanTypeAnnotation"}},{"name":"followUserMode","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}]}}}],"props":[{"name":"maxBounds","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"animationDuration","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"animationMode","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"defaultStop","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"userTrackingMode","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"followUserLocation","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"followUserMode","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"followZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"followPitch","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"followHeading","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"followPadding","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"zoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"stop","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXCircleLayer":{"type":"Component","components":{"RNMBXCircleLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXCustomLocationProvider":{"type":"Component","components":{"RNMBXCustomLocationProvider":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"coordinate","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"heading","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXFillExtrusionLayer":{"type":"Component","components":{"RNMBXFillExtrusionLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXFillLayer":{"type":"Component","components":{"RNMBXFillLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXHeatmapLayer":{"type":"Component","components":{"RNMBXHeatmapLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXImage":{"type":"Component","components":{"RNMBXImage":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"stretchX","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"stretchY","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"content","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sdf","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"name","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"scale","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXImages":{"type":"Component","components":{"RNMBXImages":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onImageMissing","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payloadRenamed","optional":false,"typeAnnotation":{"type":"ObjectTypeAnnotation","properties":[{"name":"imageKey","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}]}}}],"props":[{"name":"images","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"nativeImages","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hasOnImageMissing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXImageSource":{"type":"Component","components":{"RNMBXImageSource":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"url","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"coordinates","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXLight":{"type":"Component","components":{"RNMBXLight":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXLineLayer":{"type":"Component","components":{"RNMBXLineLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXMapView":{"type":"Component","components":{"RNMBXMapView":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onPress","optional":true,"bubblingType":"bubble","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onLongPress","optional":true,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onMapChange","optional":true,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onCameraChanged","optional":true,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}}],"props":[{"name":"attributionEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"attributionPosition","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"logoEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"logoPosition","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"compassEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"compassFadeWhenNorth","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"compassPosition","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"compassViewPosition","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"compassViewMargins","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"scaleBarEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"scaleBarPosition","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"zoomEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"scrollEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"rotateEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"pitchEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxPitch","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"deselectAnnotationOnTap","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"requestDisallowInterceptTouchEvent","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"projection","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"localizeLabels","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"styleURL","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"gestureSettings","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"surfaceView","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"scaleBarViewMargins","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"attributionViewMargins","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"attributionViewPosition","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"compassImage","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"mapViewImpl","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"preferredFramesPerSecond","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXMarkerViewContent":{"type":"Component","components":{"RNMBXMarkerViewContent":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[],"commands":[]}}},"RNMBXMarkerView":{"type":"Component","components":{"RNMBXMarkerView":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"coordinate","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"anchor","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"allowOverlap","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"allowOverlapWithPuck","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"isSelected","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXModelLayer":{"type":"Component","components":{"RNMBXModelLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXModels":{"type":"Component","components":{"RNMBXModels":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"models","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXNativeUserLocation":{"type":"Component","components":{"RNMBXNativeUserLocation":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"androidRenderMode","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"puckBearing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"puckBearingEnabled","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"bearingImage","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"shadowImage","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"topImage","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"scale","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"visible","optional":true,"typeAnnotation":{"type":"BooleanTypeAnnotation","default":false}},{"name":"pulsing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXPointAnnotation":{"type":"Component","components":{"RNMBXPointAnnotation":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onMapboxPointAnnotationDeselected","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onMapboxPointAnnotationDrag","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onMapboxPointAnnotationDragEnd","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onMapboxPointAnnotationDragStart","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}},{"name":"onMapboxPointAnnotationSelected","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}}],"props":[{"name":"coordinate","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"draggable","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"anchor","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXRasterArraySource":{"type":"Component","components":{"RNMBXRasterArraySource":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"url","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileUrlTemplates","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileSize","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceBounds","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXRasterDemSource":{"type":"Component","components":{"RNMBXRasterDemSource":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"url","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileUrlTemplates","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileSize","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXRasterLayer":{"type":"Component","components":{"RNMBXRasterLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXRasterParticleLayer":{"type":"Component","components":{"RNMBXRasterParticleLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXRasterSource":{"type":"Component","components":{"RNMBXRasterSource":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"url","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileUrlTemplates","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileSize","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tms","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"attribution","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceBounds","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXShapeSource":{"type":"Component","components":{"RNMBXShapeSource":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onMapboxShapeSourcePress","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}}],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"url","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"shape","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"cluster","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"clusterRadius","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"clusterMaxZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"clusterProperties","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"buffer","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tolerance","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"lineMetrics","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hasPressListener","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hitbox","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXSkyLayer":{"type":"Component","components":{"RNMBXSkyLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXStyleImport":{"type":"Component","components":{"RNMBXStyleImport":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation","default":null}},{"name":"existing","optional":false,"typeAnnotation":{"type":"BooleanTypeAnnotation","default":false}},{"name":"config","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXSymbolLayer":{"type":"Component","components":{"RNMBXSymbolLayer":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"filter","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"aboveLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"belowLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"layerIndex","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"sourceLayerID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"slot","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"id","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXTerrain":{"type":"Component","components":{"RNMBXTerrain":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[],"props":[{"name":"sourceID","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"reactStyle","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXVectorSource":{"type":"Component","components":{"RNMBXVectorSource":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onMapboxVectorSourcePress","optional":false,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}}],"props":[{"name":"id","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"existing","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"url","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tileUrlTemplates","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"attribution","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"maxZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"minZoomLevel","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"tms","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hasPressListener","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hitbox","optional":false,"typeAnnotation":{"type":"MixedTypeAnnotation"}}],"commands":[]}}},"RNMBXViewport":{"type":"Component","components":{"RNMBXViewport":{"extendsProps":[{"type":"ReactNativeBuiltInType","knownTypeName":"ReactNativeCoreViewProps"}],"events":[{"name":"onStatusChanged","optional":true,"bubblingType":"direct","typeAnnotation":{"type":"EventTypeAnnotation","argument":{"type":"ObjectTypeAnnotation","properties":[{"name":"type","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"payload","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}}],"props":[{"name":"transitionsToIdleUponUserInteraction","optional":true,"typeAnnotation":{"type":"MixedTypeAnnotation"}},{"name":"hasStatusChanged","optional":false,"typeAnnotation":{"type":"BooleanTypeAnnotation","default":false}}],"commands":[]}}}}}
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/AndroidManifest.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..c8865b5
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rnmapbox.rnmbx" >
+
+    <uses-sdk android:minSdkVersion="24" />
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/output-metadata.json b/node_modules/@rnmapbox/maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/output-metadata.json
new file mode 100644
index 0000000..545af46
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/output-metadata.json
@@ -0,0 +1,18 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "AAPT_FRIENDLY_MERGED_MANIFESTS",
+    "kind": "Directory"
+  },
+  "applicationId": "com.rnmapbox.rnmbx",
+  "variantName": "debug",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "outputFile": "AndroidManifest.xml"
+    }
+  ],
+  "elementType": "File"
+}
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/aar_metadata/debug/writeDebugAarMetadata/aar-metadata.properties b/node_modules/@rnmapbox/maps/android/build/intermediates/aar_metadata/debug/writeDebugAarMetadata/aar-metadata.properties
new file mode 100644
index 0000000..1211b1e
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/aar_metadata/debug/writeDebugAarMetadata/aar-metadata.properties
@@ -0,0 +1,6 @@
+aarFormatVersion=1.0
+aarMetadataVersion=1.0
+minCompileSdk=1
+minCompileSdkExtension=0
+minAndroidGradlePluginVersion=1.0.0
+coreLibraryDesugaringEnabled=false
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/annotation_processor_list/debug/javaPreCompileDebug/annotationProcessors.json b/node_modules/@rnmapbox/maps/android/build/intermediates/annotation_processor_list/debug/javaPreCompileDebug/annotationProcessors.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/annotation_processor_list/debug/javaPreCompileDebug/annotationProcessors.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar b/node_modules/@rnmapbox/maps/android/build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar
new file mode 100644
index 0000000..5788a59
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/compile_symbol_list/debug/generateDebugRFile/R.txt b/node_modules/@rnmapbox/maps/android/build/intermediates/compile_symbol_list/debug/generateDebugRFile/R.txt
new file mode 100644
index 0000000..e6bb791
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/compile_symbol_list/debug/generateDebugRFile/R.txt
@@ -0,0 +1,8 @@
+int drawable empty 0x0
+int drawable empty_drawable 0x0
+int drawable red_marker 0x0
+int id annotation_img 0x0
+int id annotation_layout 0x0
+int id annotation_view_container 0x0
+int layout annotation 0x0
+int string app_name 0x0
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable-xxhdpi-v4_red_marker.png.flat b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable-xxhdpi-v4_red_marker.png.flat
new file mode 100644
index 0000000..f933260
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable-xxhdpi-v4_red_marker.png.flat differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable_empty.xml.flat b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable_empty.xml.flat
new file mode 100644
index 0000000..09a611d
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable_empty.xml.flat differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable_empty_drawable.png.flat b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable_empty_drawable.png.flat
new file mode 100644
index 0000000..23e5b37
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/drawable_empty_drawable.png.flat differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/layout_annotation.xml.flat b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/layout_annotation.xml.flat
new file mode 100644
index 0000000..2017d6a
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/compiled_local_resources/debug/compileDebugLibraryResources/out/layout_annotation.xml.flat differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
new file mode 100644
index 0000000..58e7ae6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
@@ -0,0 +1,5 @@
+#Thu Jan 15 21:03:54 PST 2026
+com.rnmapbox.rnmbx.rnmapbox_maps-main-6\:/drawable-xxhdpi/red_marker.png=/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable-xxhdpi-v4/red_marker.png
+com.rnmapbox.rnmbx.rnmapbox_maps-main-6\:/drawable/empty_drawable.png=/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty_drawable.png
+com.rnmapbox.rnmbx.rnmapbox_maps-main-6\:/drawable/empty.xml=/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty.xml
+com.rnmapbox.rnmbx.rnmapbox_maps-main-6\:/layout/annotation.xml=/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/layout/annotation.xml
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/merged.dir/values/values.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/merged.dir/values/values.xml
new file mode 100644
index 0000000..9c03766
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/merged.dir/values/values.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">RNMBX</string>
+</resources>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
new file mode 100644
index 0000000..e5ca650
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main" generated-set="main$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res"><file name="empty" path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res/drawable/empty.xml" qualifiers="" type="drawable"/><file name="empty_drawable" path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res/drawable/empty_drawable.png" qualifiers="" type="drawable"/><file name="annotation" path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res/layout/annotation.xml" qualifiers="" type="layout"/><file path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res/values/strings.xml" qualifiers=""><string name="app_name">RNMBX</string></file><file name="red_marker" path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/res/drawable-xxhdpi/red_marker.png" qualifiers="xxhdpi-v4" type="drawable"/></source></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug" generated-set="debug$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/generated/res/resValues/debug"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated" generated-set="generated$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/generated/res/resValues/debug"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/mergeDebugShaders/merger.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/mergeDebugShaders/merger.xml
new file mode 100644
index 0000000..0a1ec1d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/mergeDebugShaders/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/shaders"/></dataSet><dataSet config="debug" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/debug/shaders"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/packageDebugAssets/merger.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/packageDebugAssets/merger.xml
new file mode 100644
index 0000000..7e900b4
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/incremental/packageDebugAssets/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/assets"/></dataSet><dataSet config="debug" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/debug/assets"/></dataSet><dataSet config="generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/build/intermediates/shader_assets/debug/compileDebugShaders/out"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/local_only_symbol_list/debug/parseDebugLocalResources/R-def.txt b/node_modules/@rnmapbox/maps/android/build/intermediates/local_only_symbol_list/debug/parseDebugLocalResources/R-def.txt
new file mode 100644
index 0000000..826dbbd
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/local_only_symbol_list/debug/parseDebugLocalResources/R-def.txt
@@ -0,0 +1,10 @@
+R_DEF: Internal format may change without notice
+local
+drawable empty
+drawable empty_drawable
+drawable red_marker
+id annotation_img
+id annotation_layout
+id annotation_view_container
+layout annotation
+string app_name
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/manifest_merge_blame_file/debug/processDebugManifest/manifest-merger-blame-debug-report.txt b/node_modules/@rnmapbox/maps/android/build/intermediates/manifest_merge_blame_file/debug/processDebugManifest/manifest-merger-blame-debug-report.txt
new file mode 100644
index 0000000..d7f7958
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/manifest_merge_blame_file/debug/processDebugManifest/manifest-merger-blame-debug-report.txt
@@ -0,0 +1,17 @@
+1<?xml version="1.0" encoding="utf-8"?>
+2<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+3    package="com.rnmapbox.rnmbx" >
+4
+5    <uses-sdk android:minSdkVersion="24" />
+6
+7    <uses-permission android:name="android.permission.INTERNET" />
+7-->/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:2:5-67
+7-->/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:2:22-64
+8    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+8-->/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:3:5-80
+8-->/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:3:22-78
+9    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+9-->/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:4:5-78
+9-->/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:4:22-76
+10
+11</manifest>
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/merged_manifest/debug/processDebugManifest/AndroidManifest.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/merged_manifest/debug/processDebugManifest/AndroidManifest.xml
new file mode 100644
index 0000000..c8865b5
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/merged_manifest/debug/processDebugManifest/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rnmapbox.rnmbx" >
+
+    <uses-sdk android:minSdkVersion="24" />
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/navigation_json/debug/extractDeepLinksDebug/navigation.json b/node_modules/@rnmapbox/maps/android/build/intermediates/navigation_json/debug/extractDeepLinksDebug/navigation.json
new file mode 100644
index 0000000..0637a08
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/navigation_json/debug/extractDeepLinksDebug/navigation.json
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/nested_resources_validation_report/debug/generateDebugResources/nestedResourcesValidationReport.txt b/node_modules/@rnmapbox/maps/android/build/intermediates/nested_resources_validation_report/debug/generateDebugResources/nestedResourcesValidationReport.txt
new file mode 100644
index 0000000..08f4ebe
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/nested_resources_validation_report/debug/generateDebugResources/nestedResourcesValidationReport.txt
@@ -0,0 +1 @@
+0 Warning/Error
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable-xxhdpi-v4/red_marker.png b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable-xxhdpi-v4/red_marker.png
new file mode 100644
index 0000000..be782e1
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable-xxhdpi-v4/red_marker.png differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty.xml
new file mode 100644
index 0000000..1f83bff
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
+  <size android:height="1dp" android:width="1dp" />
+  <solid android:color="@android:color/transparent" />
+</shape>
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty_drawable.png b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty_drawable.png
new file mode 100644
index 0000000..9da19ea
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/drawable/empty_drawable.png differ
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/layout/annotation.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/layout/annotation.xml
new file mode 100644
index 0000000..4994bd0
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/layout/annotation.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/annotation_layout"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content">
+
+    <ImageView
+        android:id="@+id/annotation_img"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+
+    <LinearLayout
+        android:orientation="vertical"
+        android:id="@+id/annotation_view_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+</RelativeLayout>
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/values/values.xml b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/values/values.xml
new file mode 100644
index 0000000..9c03766
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/packaged_res/debug/packageDebugResources/values/values.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">RNMBX</string>
+</resources>
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/intermediates/symbol_list_with_package_name/debug/generateDebugRFile/package-aware-r.txt b/node_modules/@rnmapbox/maps/android/build/intermediates/symbol_list_with_package_name/debug/generateDebugRFile/package-aware-r.txt
new file mode 100644
index 0000000..af46f7d
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/intermediates/symbol_list_with_package_name/debug/generateDebugRFile/package-aware-r.txt
@@ -0,0 +1,9 @@
+com.rnmapbox.rnmbx
+drawable empty
+drawable empty_drawable
+drawable red_marker
+id annotation_img
+id annotation_layout
+id annotation_view_container
+layout annotation
+string app_name
diff --git a/node_modules/@rnmapbox/maps/android/build/kotlin/compileDebugKotlin/cacheable/dirty-sources.txt b/node_modules/@rnmapbox/maps/android/build/kotlin/compileDebugKotlin/cacheable/dirty-sources.txt
new file mode 100644
index 0000000..b01c535
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/kotlin/compileDebugKotlin/cacheable/dirty-sources.txt
@@ -0,0 +1,154 @@
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/location/RNMBXNativeUserLocationManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/MapUserTrackingModeEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/HttpInterceptor.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleValue.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXMarkerViewManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXLogging.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/JSONObject.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/mapview/NativeMapViewModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/RNMBXVIewportManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXBackgroundLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/Logger.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/MapboxMap.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/StyleFactory.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/Point.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/RNMBXViewportModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXPointAnnotationManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXFillLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXSnapshotModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/MapSteadyEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXSkyLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXLineLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/writeableMapArrayOf.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXVectorSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/constants/EventKeys.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/images/RNMBXImage.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXHeatmapLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXHeatmapLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/location/LocationManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXLocationModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/RNMBXCamera.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/CameraStop.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/location/LocationComponentManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXModelLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/location/UserTrackingMode.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXModelLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/LatLngBounds.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/AbstractMapFeature.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXOfflineModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXShapeSourceModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXFillExtrusionLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/location/RNMBXCustomLocationProvider.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/components/styles/layers/RNMBXRasterParticleLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/constants/EventTypes.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/mapview/RNMBXMapView.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXLineLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Event.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/images/RNMBXImageModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/RNMBXCameraModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/GeoJSONUtils.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/location/RNMBXCustomLocationProviderManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXImageSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/PropertyChanges.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXCircleLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyle.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXRasterLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/light/RNMBXLightManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/BitmapUtils.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXTileStoreModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Snapshot.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXPointAnnotation.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXRasterLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/RNMBXCameraManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/light/RNMBXLight.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/mapview/RNMBXMapViewManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/mapview/helpers/CameraChangeTracker.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/atmosphere/RNMBXAtmosphere.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/style.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/shapeAnimators/AnimatableElement.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/ReadableMap.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXRasterDemSourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/components/styles/sources/RNMBXRasterArraySourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXCallout.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXRasterDemSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/RNMBXOfflineModuleLegacy.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXRasterSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/RNMBXCameraGestureObserverManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/AbstractEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/rn-compat/rn75/com/rnmapbox/rnmbx/rncompat/ReadableMap.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/Dynamic.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/images/RNMBXImageManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/components/styles/layers/RNMBXRasterParticleLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/AbstractEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/ResourceOption.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/FeatureCollection.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/RNMBXCameraGestureObserver.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/components/styles/sources/RNMBXRasterArraySource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXTileSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/modules/CustomHttpHeaders.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/shapeAnimators/RNMBXChangeLineOffsetsShapeAnimatorModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/terrain/RNMBXTerrain.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXMarkerViewContent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/DownloadMapImageTask.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXPointAnnotationCoordinator.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/terrain/RNMBXTerrainManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/ImageEntry.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Layer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/MapChangeEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXImageSourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/images/RNMBXImagesManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/CoordinateBounds.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXRasterSourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXSkyLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXBackgroundLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Annotation.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXSymbolLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/atmosphere/RNMBXAtmosphereManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXShapeSource.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXMarkerView.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/Geometry.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/IEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Image.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/images/RNMBXImages.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/shapeAnimators/RNMBXMovePointShapeAnimatorModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXCalloutManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/AbstractSourceConsumer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/Map.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/ConvertUtils.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Feature.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXSymbolLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/events/LocationEvent.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/AbstractEventEmitter.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleImportManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/RNMBXPackage.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXCircleLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/OfflineManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXFillLayer.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/shapeAnimators/ShapeAnimatorCommon.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/lifecycle-compat/v26/com/rnmapbox/rnmbx/components/mapview/LifecycleCompat.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/model/RNMBXModelsManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/Value.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXVectorSourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXTileSourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/model/RNMBXModels.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/images/ImageManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/layers/RNMBXFillExtrusionLayerManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/CameraUpdateItem.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/CameraUpdateQueue.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/location/RNMBXNativeUserLocation.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleImport.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/OrnamentSettings.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/ViewTagResolver.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Light.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/utils/extensions/ReadableArray.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Location.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/camera/RNMBXViewport.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/rn-compat/rn75/com/rnmapbox/rnmbx/rncompat/Dynamic.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/sources/RNMBXShapeSourceManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXPointAnnotationModule.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/annotation/RNMBXMarkerViewContentManager.kt
+/Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/mapbox-v11-compat/v11/com/rnmapbox/rnmbx/v11compat/Cancelable.kt
\ No newline at end of file
diff --git a/node_modules/@rnmapbox/maps/android/build/kotlin/compileDebugKotlin/local-state/build-history.bin b/node_modules/@rnmapbox/maps/android/build/kotlin/compileDebugKotlin/local-state/build-history.bin
new file mode 100644
index 0000000..a25f828
Binary files /dev/null and b/node_modules/@rnmapbox/maps/android/build/kotlin/compileDebugKotlin/local-state/build-history.bin differ
diff --git a/node_modules/@rnmapbox/maps/android/build/outputs/logs/manifest-merger-debug-report.txt b/node_modules/@rnmapbox/maps/android/build/outputs/logs/manifest-merger-debug-report.txt
new file mode 100644
index 0000000..4743190
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/build/outputs/logs/manifest-merger-debug-report.txt
@@ -0,0 +1,29 @@
+-- Merging decision tree log ---
+manifest
+ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:1:1-5:12
+INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:1:1-5:12
+	package
+		ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:1:70-98
+		INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml
+	xmlns:android
+		ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:1:11-69
+uses-permission#android.permission.INTERNET
+ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:2:5-67
+	android:name
+		ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:2:22-64
+uses-permission#android.permission.ACCESS_COARSE_LOCATION
+ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:3:5-80
+	android:name
+		ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:3:22-78
+uses-permission#android.permission.ACCESS_FINE_LOCATION
+ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:4:5-78
+	android:name
+		ADDED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml:4:22-76
+uses-sdk
+INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml reason: use-sdk injection requested
+INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml
+INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml
+	android:targetSdkVersion
+		INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml
+	android:minSdkVersion
+		INJECTED from /Volumes/USBSSD/dev/Resgrid/Responder/node_modules/@rnmapbox/maps/android/src/main/AndroidManifest.xml
diff --git a/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt
index a8456b6..ae270dc 100644
--- a/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt
+++ b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt
@@ -85,16 +85,16 @@ object RNMBXStyleFactory {
                         }
                     }
                 })
-              "fillPatternCrossFade" ->
-                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
-                    override fun onAllImagesLoaded() {
-                        try {
-                            setFillPatternCrossFade(layer, styleValue)
-                        } catch (exception: RuntimeException) {
-                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPatternCrossFade: %s", exception.message))
-                        }
-                    }
-                })
+              // "fillPatternCrossFade" -> // Deprecated in Mapbox SDK 11.8+
+                // style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    // override fun onAllImagesLoaded() {
+                        // try {
+                            // setFillPatternCrossFade(layer, styleValue)
+                        // } catch (exception: RuntimeException) {
+                            // Logger.e("RNMBXFill",String.format("Exception failed during setFillPatternCrossFade: %s", exception.message))
+                        // }
+                    // }
+                // })
               "fillEmissiveStrength" ->
                 setFillEmissiveStrength(layer, styleValue)
                 "fillEmissiveStrengthTransition" ->
@@ -177,20 +177,20 @@ object RNMBXStyleFactory {
                 setLineTrimOffset(layer, styleValue)
               "lineZOffset" ->
                 setLineZOffset(layer, styleValue)
-              "lineElevationReference" ->
-                setLineElevationReference(layer, styleValue)
-              "lineCrossSlope" ->
-                setLineCrossSlope(layer, styleValue)
-              "linePatternCrossFade" ->
-                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
-                    override fun onAllImagesLoaded() {
-                        try {
-                            setLinePatternCrossFade(layer, styleValue)
-                        } catch (exception: RuntimeException) {
-                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePatternCrossFade: %s", exception.message))
-                        }
-                    }
-                })
+              // "lineElevationReference" -> // Deprecated in Mapbox SDK 11.8+
+                // setLineElevationReference(layer, styleValue)
+              // "lineCrossSlope" -> // Deprecated in Mapbox SDK 11.8+
+                // setLineCrossSlope(layer, styleValue)
+              // "linePatternCrossFade" -> // Deprecated in Mapbox SDK 11.8+
+                // style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    // override fun onAllImagesLoaded() {
+                        // try {
+                            // setLinePatternCrossFade(layer, styleValue)
+                        // } catch (exception: RuntimeException) {
+                            // Logger.e("RNMBXLine",String.format("Exception failed during setLinePatternCrossFade: %s", exception.message))
+                        // }
+                    // }
+                // })
               "lineTrimFadeRange" ->
                 setLineTrimFadeRange(layer, styleValue)
               "lineTrimColor" ->
@@ -463,8 +463,8 @@ object RNMBXStyleFactory {
                 setCircleStrokeOpacity(layer, styleValue)
                 "circleStrokeOpacityTransition" ->
                 setCircleStrokeOpacityTransition(layer, styleValue)
-              "circleElevationReference" ->
-                setCircleElevationReference(layer, styleValue)
+              // "circleElevationReference" -> // Deprecated in Mapbox SDK 11.8+
+                // setCircleElevationReference(layer, styleValue)
               "circleEmissiveStrength" ->
                 setCircleEmissiveStrength(layer, styleValue)
                 "circleEmissiveStrengthTransition" ->
@@ -571,20 +571,20 @@ object RNMBXStyleFactory {
                 setFillExtrusionAmbientOcclusionRadiusTransition(layer, styleValue)
               "fillExtrusionRoundedRoof" ->
                 setFillExtrusionRoundedRoof(layer, styleValue)
-              "fillExtrusionPatternCrossFade" ->
-                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
-                    override fun onAllImagesLoaded() {
-                        try {
-                            setFillExtrusionPatternCrossFade(layer, styleValue)
-                        } catch (exception: RuntimeException) {
-                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPatternCrossFade: %s", exception.message))
-                        }
-                    }
-                })
-              "fillExtrusionHeightAlignment" ->
-                setFillExtrusionHeightAlignment(layer, styleValue)
-              "fillExtrusionBaseAlignment" ->
-                setFillExtrusionBaseAlignment(layer, styleValue)
+              // "fillExtrusionPatternCrossFade" -> // Deprecated in Mapbox SDK 11.8+
+                // style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    // override fun onAllImagesLoaded() {
+                        // try {
+                            // setFillExtrusionPatternCrossFade(layer, styleValue)
+                        // } catch (exception: RuntimeException) {
+                            // Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPatternCrossFade: %s", exception.message))
+                        // }
+                    // }
+                // })
+              // "fillExtrusionHeightAlignment" -> // Deprecated in Mapbox SDK 11.8+
+                // setFillExtrusionHeightAlignment(layer, styleValue)
+              // "fillExtrusionBaseAlignment" -> // Deprecated in Mapbox SDK 11.8+
+                // setFillExtrusionBaseAlignment(layer, styleValue)
               "fillExtrusionAmbientOcclusionWallRadius" ->
                 setFillExtrusionAmbientOcclusionWallRadius(layer, styleValue)
                 "fillExtrusionAmbientOcclusionWallRadiusTransition" ->
@@ -885,8 +885,8 @@ object RNMBXStyleFactory {
                 setBackgroundOpacity(layer, styleValue)
                 "backgroundOpacityTransition" ->
                 setBackgroundOpacityTransition(layer, styleValue)
-              "backgroundPitchAlignment" ->
-                setBackgroundPitchAlignment(layer, styleValue)
+              // "backgroundPitchAlignment" -> // Deprecated in Mapbox SDK 11.8+
+                // setBackgroundPitchAlignment(layer, styleValue)
               "backgroundEmissiveStrength" ->
                 setBackgroundEmissiveStrength(layer, styleValue)
                 "backgroundEmissiveStrengthTransition" ->
@@ -1220,23 +1220,23 @@ object RNMBXStyleFactory {
       }
     }
 
-    fun setFillPatternCrossFade(layer: FillLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.fillPatternCrossFade(expression)
-        } else {
-          Logger.e("RNMBXFill", "Expression for fillPatternCrossFade is null")
-        }
-      } else {
-          val value = styleValue.getDouble(VALUE_KEY)
-          if (value != null) {
-            layer.fillPatternCrossFade(value)
-          } else {
-            Logger.e("RNMBXFill", "value for fillPatternCrossFade is null")
-          }
-      }
-    }
+    // fun setFillPatternCrossFade(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.fillPatternCrossFade(expression)
+        // } else {
+          // Logger.e("RNMBXFill", "Expression for fillPatternCrossFade is null")
+        // }
+      // } else {
+          // val value = styleValue.getDouble(VALUE_KEY)
+          // if (value != null) {
+            // layer.fillPatternCrossFade(value)
+          // } else {
+            // Logger.e("RNMBXFill", "value for fillPatternCrossFade is null")
+          // }
+      // }
+    // }
 
     fun setFillEmissiveStrength(layer: FillLayer, styleValue: RNMBXStyleValue ) {
       if (styleValue.isExpression()) {
@@ -1637,54 +1637,54 @@ object RNMBXStyleFactory {
       }
     }
 
-    fun setLineElevationReference(layer: LineLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.lineElevationReference(expression)
-        } else {
-          Logger.e("RNMBXLine", "Expression for lineElevationReference is null")
-        }
-      } else {
-          layer.lineElevationReference(LineElevationReference.valueOf(styleValue.getEnumName()))
-      }
-    }
-
-    fun setLineCrossSlope(layer: LineLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.lineCrossSlope(expression)
-        } else {
-          Logger.e("RNMBXLine", "Expression for lineCrossSlope is null")
-        }
-      } else {
-          val value = styleValue.getDouble(VALUE_KEY)
-          if (value != null) {
-            layer.lineCrossSlope(value)
-          } else {
-            Logger.e("RNMBXLine", "value for lineCrossSlope is null")
-          }
-      }
-    }
-
-    fun setLinePatternCrossFade(layer: LineLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.linePatternCrossFade(expression)
-        } else {
-          Logger.e("RNMBXLine", "Expression for linePatternCrossFade is null")
-        }
-      } else {
-          val value = styleValue.getDouble(VALUE_KEY)
-          if (value != null) {
-            layer.linePatternCrossFade(value)
-          } else {
-            Logger.e("RNMBXLine", "value for linePatternCrossFade is null")
-          }
-      }
-    }
+    // fun setLineElevationReference(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.lineElevationReference(expression)
+        // } else {
+          // Logger.e("RNMBXLine", "Expression for lineElevationReference is null")
+        // }
+      // } else {
+          // layer.lineElevationReference(LineElevationReference.valueOf(styleValue.getEnumName()))
+      // }
+    // }
+
+    // fun setLineCrossSlope(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.lineCrossSlope(expression)
+        // } else {
+          // Logger.e("RNMBXLine", "Expression for lineCrossSlope is null")
+        // }
+      // } else {
+          // val value = styleValue.getDouble(VALUE_KEY)
+          // if (value != null) {
+            // layer.lineCrossSlope(value)
+          // } else {
+            // Logger.e("RNMBXLine", "value for lineCrossSlope is null")
+          // }
+      // }
+    // }
+
+    // fun setLinePatternCrossFade(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.linePatternCrossFade(expression)
+        // } else {
+          // Logger.e("RNMBXLine", "Expression for linePatternCrossFade is null")
+        // }
+      // } else {
+          // val value = styleValue.getDouble(VALUE_KEY)
+          // if (value != null) {
+            // layer.linePatternCrossFade(value)
+          // } else {
+            // Logger.e("RNMBXLine", "value for linePatternCrossFade is null")
+          // }
+      // }
+    // }
 
     fun setLineTrimFadeRange(layer: LineLayer, styleValue: RNMBXStyleValue ) {
       if (styleValue.isExpression()) {
@@ -3282,18 +3282,18 @@ object RNMBXStyleFactory {
       }
     }
 
-    fun setCircleElevationReference(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.circleElevationReference(expression)
-        } else {
-          Logger.e("RNMBXCircle", "Expression for circleElevationReference is null")
-        }
-      } else {
-          layer.circleElevationReference(CircleElevationReference.valueOf(styleValue.getEnumName()))
-      }
-    }
+    // fun setCircleElevationReference(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.circleElevationReference(expression)
+        // } else {
+          // Logger.e("RNMBXCircle", "Expression for circleElevationReference is null")
+        // }
+      // } else {
+          // layer.circleElevationReference(CircleElevationReference.valueOf(styleValue.getEnumName()))
+      // }
+    // }
 
     fun setCircleEmissiveStrength(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
       if (styleValue.isExpression()) {
@@ -3714,49 +3714,49 @@ object RNMBXStyleFactory {
       }
     }
 
-    fun setFillExtrusionPatternCrossFade(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.fillExtrusionPatternCrossFade(expression)
-        } else {
-          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPatternCrossFade is null")
-        }
-      } else {
-          val value = styleValue.getDouble(VALUE_KEY)
-          if (value != null) {
-            layer.fillExtrusionPatternCrossFade(value)
-          } else {
-            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPatternCrossFade is null")
-          }
-      }
-    }
-
-    fun setFillExtrusionHeightAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.fillExtrusionHeightAlignment(expression)
-        } else {
-          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeightAlignment is null")
-        }
-      } else {
-          layer.fillExtrusionHeightAlignment(FillExtrusionHeightAlignment.valueOf(styleValue.getEnumName()))
-      }
-    }
-
-    fun setFillExtrusionBaseAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.fillExtrusionBaseAlignment(expression)
-        } else {
-          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBaseAlignment is null")
-        }
-      } else {
-          layer.fillExtrusionBaseAlignment(FillExtrusionBaseAlignment.valueOf(styleValue.getEnumName()))
-      }
-    }
+    // fun setFillExtrusionPatternCrossFade(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.fillExtrusionPatternCrossFade(expression)
+        // } else {
+          // Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPatternCrossFade is null")
+        // }
+      // } else {
+          // val value = styleValue.getDouble(VALUE_KEY)
+          // if (value != null) {
+            // layer.fillExtrusionPatternCrossFade(value)
+          // } else {
+            // Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPatternCrossFade is null")
+          // }
+      // }
+    // }
+
+    // fun setFillExtrusionHeightAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.fillExtrusionHeightAlignment(expression)
+        // } else {
+          // Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeightAlignment is null")
+        // }
+      // } else {
+          // layer.fillExtrusionHeightAlignment(FillExtrusionHeightAlignment.valueOf(styleValue.getEnumName()))
+      // }
+    // }
+
+    // fun setFillExtrusionBaseAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.fillExtrusionBaseAlignment(expression)
+        // } else {
+          // Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBaseAlignment is null")
+        // }
+      // } else {
+          // layer.fillExtrusionBaseAlignment(FillExtrusionBaseAlignment.valueOf(styleValue.getEnumName()))
+      // }
+    // }
 
     fun setFillExtrusionAmbientOcclusionWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
       if (styleValue.isExpression()) {
@@ -5105,18 +5105,18 @@ object RNMBXStyleFactory {
       }
     }
 
-    fun setBackgroundPitchAlignment(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
-      if (styleValue.isExpression()) {
-        val expression = styleValue.getExpression()
-        if (expression != null) {
-          layer.backgroundPitchAlignment(expression)
-        } else {
-          Logger.e("RNMBXBackground", "Expression for backgroundPitchAlignment is null")
-        }
-      } else {
-          layer.backgroundPitchAlignment(BackgroundPitchAlignment.valueOf(styleValue.getEnumName()))
-      }
-    }
+    // fun setBackgroundPitchAlignment(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      // if (styleValue.isExpression()) {
+        // val expression = styleValue.getExpression()
+        // if (expression != null) {
+          // layer.backgroundPitchAlignment(expression)
+        // } else {
+          // Logger.e("RNMBXBackground", "Expression for backgroundPitchAlignment is null")
+        // }
+      // } else {
+          // layer.backgroundPitchAlignment(BackgroundPitchAlignment.valueOf(styleValue.getEnumName()))
+      // }
+    // }
 
     fun setBackgroundEmissiveStrength(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
       if (styleValue.isExpression()) {
diff --git a/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.backup b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.backup
new file mode 100644
index 0000000..a8456b6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.backup
@@ -0,0 +1,5597 @@
+// DO NOT MODIFY
+// THIS FILE IS AUTOGENERATED
+package com.rnmapbox.rnmbx.components.styles
+
+import com.mapbox.maps.MapboxStyleException
+import com.mapbox.maps.extension.style.expressions.generated.Expression
+import com.mapbox.maps.extension.style.layers.generated.BackgroundLayer
+import com.mapbox.maps.extension.style.layers.generated.CircleLayer
+import com.mapbox.maps.extension.style.layers.generated.FillExtrusionLayer
+import com.mapbox.maps.extension.style.layers.generated.FillLayer
+import com.mapbox.maps.extension.style.layers.generated.LineLayer
+import com.mapbox.maps.extension.style.layers.generated.SkyLayer
+// import com.mapbox.maps.extension.style.layers.generated.PropertyFactory
+// import com.mapbox.maps.extension.style.layers.generated.PropertyValue
+import com.mapbox.maps.extension.style.layers.generated.RasterLayer
+import com.mapbox.maps.extension.style.layers.generated.RasterParticleLayer
+import com.mapbox.maps.extension.style.layers.generated.SymbolLayer
+import com.mapbox.maps.extension.style.layers.generated.HeatmapLayer
+import com.mapbox.maps.extension.style.layers.generated.HillshadeLayer
+import com.mapbox.maps.extension.style.atmosphere.generated.Atmosphere
+import com.mapbox.maps.extension.style.terrain.generated.Terrain
+import com.mapbox.maps.extension.style.layers.generated.ModelLayer
+// import com.mapbox.maps.extension.style.layers.properties.generated.Visibility
+import com.mapbox.maps.extension.style.layers.properties.generated.*
+import com.mapbox.maps.extension.style.types.StyleTransition
+
+import com.mapbox.maps.extension.style.light.LightPosition
+import com.rnmapbox.rnmbx.utils.DownloadMapImageTask.OnAllImagesLoaded
+import com.rnmapbox.rnmbx.utils.Logger
+
+import com.rnmapbox.rnmbx.v11compat.light.*;
+import com.rnmapbox.rnmbx.v11compat.stylefactory.*;
+
+import java.util.List;
+
+const val LOG_TAG = "RNMBXStyleFactory"
+
+object RNMBXStyleFactory {
+    const val VALUE_KEY = "value";
+    const val SHOULD_ADD_IMAGE_KEY = "shouldAddImage";
+
+    fun setFillLayerStyle(layer: FillLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "fillSortKey" ->
+                setFillSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "fillAntialias" ->
+                setFillAntialias(layer, styleValue)
+              "fillOpacity" ->
+                setFillOpacity(layer, styleValue)
+                "fillOpacityTransition" ->
+                setFillOpacityTransition(layer, styleValue)
+              "fillColor" ->
+                setFillColor(layer, styleValue)
+                "fillColorTransition" ->
+                setFillColorTransition(layer, styleValue)
+              "fillOutlineColor" ->
+                setFillOutlineColor(layer, styleValue)
+                "fillOutlineColorTransition" ->
+                setFillOutlineColorTransition(layer, styleValue)
+              "fillTranslate" ->
+                setFillTranslate(layer, styleValue)
+                "fillTranslateTransition" ->
+                setFillTranslateTransition(layer, styleValue)
+              "fillTranslateAnchor" ->
+                setFillTranslateAnchor(layer, styleValue)
+              "fillPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "fillPatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillPatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "fillEmissiveStrength" ->
+                setFillEmissiveStrength(layer, styleValue)
+                "fillEmissiveStrengthTransition" ->
+                setFillEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setLineLayerStyle(layer: LineLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "lineCap" ->
+                setLineCap(layer, styleValue)
+              "lineJoin" ->
+                setLineJoin(layer, styleValue)
+              "lineMiterLimit" ->
+                setLineMiterLimit(layer, styleValue)
+              "lineRoundLimit" ->
+                setLineRoundLimit(layer, styleValue)
+              "lineSortKey" ->
+                setLineSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "lineOpacity" ->
+                setLineOpacity(layer, styleValue)
+                "lineOpacityTransition" ->
+                setLineOpacityTransition(layer, styleValue)
+              "lineColor" ->
+                setLineColor(layer, styleValue)
+                "lineColorTransition" ->
+                setLineColorTransition(layer, styleValue)
+              "lineTranslate" ->
+                setLineTranslate(layer, styleValue)
+                "lineTranslateTransition" ->
+                setLineTranslateTransition(layer, styleValue)
+              "lineTranslateAnchor" ->
+                setLineTranslateAnchor(layer, styleValue)
+              "lineWidth" ->
+                setLineWidth(layer, styleValue)
+                "lineWidthTransition" ->
+                setLineWidthTransition(layer, styleValue)
+              "lineGapWidth" ->
+                setLineGapWidth(layer, styleValue)
+                "lineGapWidthTransition" ->
+                setLineGapWidthTransition(layer, styleValue)
+              "lineOffset" ->
+                setLineOffset(layer, styleValue)
+                "lineOffsetTransition" ->
+                setLineOffsetTransition(layer, styleValue)
+              "lineBlur" ->
+                setLineBlur(layer, styleValue)
+                "lineBlurTransition" ->
+                setLineBlurTransition(layer, styleValue)
+              "lineDasharray" ->
+                setLineDasharray(layer, styleValue)
+              "linePattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setLinePattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePattern: %s", exception.message))
+                        }
+                    }
+                })
+              "lineGradient" ->
+                setLineGradient(layer, styleValue)
+              "lineTrimOffset" ->
+                setLineTrimOffset(layer, styleValue)
+              "lineZOffset" ->
+                setLineZOffset(layer, styleValue)
+              "lineElevationReference" ->
+                setLineElevationReference(layer, styleValue)
+              "lineCrossSlope" ->
+                setLineCrossSlope(layer, styleValue)
+              "linePatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setLinePatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "lineTrimFadeRange" ->
+                setLineTrimFadeRange(layer, styleValue)
+              "lineTrimColor" ->
+                setLineTrimColor(layer, styleValue)
+                "lineTrimColorTransition" ->
+                setLineTrimColorTransition(layer, styleValue)
+              "lineEmissiveStrength" ->
+                setLineEmissiveStrength(layer, styleValue)
+                "lineEmissiveStrengthTransition" ->
+                setLineEmissiveStrengthTransition(layer, styleValue)
+              "lineOcclusionOpacity" ->
+                setLineOcclusionOpacity(layer, styleValue)
+                "lineOcclusionOpacityTransition" ->
+                setLineOcclusionOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setSymbolLayerStyle(layer: SymbolLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "symbolPlacement" ->
+                setSymbolPlacement(layer, styleValue)
+              "symbolSpacing" ->
+                setSymbolSpacing(layer, styleValue)
+              "symbolAvoidEdges" ->
+                setSymbolAvoidEdges(layer, styleValue)
+              "symbolSortKey" ->
+                setSymbolSortKey(layer, styleValue)
+              "symbolZOrder" ->
+                setSymbolZOrder(layer, styleValue)
+              "iconAllowOverlap" ->
+                setIconAllowOverlap(layer, styleValue)
+              "iconIgnorePlacement" ->
+                setIconIgnorePlacement(layer, styleValue)
+              "iconOptional" ->
+                setIconOptional(layer, styleValue)
+              "iconRotationAlignment" ->
+                setIconRotationAlignment(layer, styleValue)
+              "iconSize" ->
+                setIconSize(layer, styleValue)
+              "iconTextFit" ->
+                setIconTextFit(layer, styleValue)
+              "iconTextFitPadding" ->
+                setIconTextFitPadding(layer, styleValue)
+              "iconImage" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setIconImage(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXSymbol",String.format("Exception failed during setIconImage: %s", exception.message))
+                        }
+                    }
+                })
+              "iconRotate" ->
+                setIconRotate(layer, styleValue)
+              "iconPadding" ->
+                setIconPadding(layer, styleValue)
+              "iconKeepUpright" ->
+                setIconKeepUpright(layer, styleValue)
+              "iconOffset" ->
+                setIconOffset(layer, styleValue)
+              "iconAnchor" ->
+                setIconAnchor(layer, styleValue)
+              "iconPitchAlignment" ->
+                setIconPitchAlignment(layer, styleValue)
+              "textPitchAlignment" ->
+                setTextPitchAlignment(layer, styleValue)
+              "textRotationAlignment" ->
+                setTextRotationAlignment(layer, styleValue)
+              "textField" ->
+                setTextField(layer, styleValue)
+              "textFont" ->
+                setTextFont(layer, styleValue)
+              "textSize" ->
+                setTextSize(layer, styleValue)
+              "textMaxWidth" ->
+                setTextMaxWidth(layer, styleValue)
+              "textLineHeight" ->
+                setTextLineHeight(layer, styleValue)
+              "textLetterSpacing" ->
+                setTextLetterSpacing(layer, styleValue)
+              "textJustify" ->
+                setTextJustify(layer, styleValue)
+              "textRadialOffset" ->
+                setTextRadialOffset(layer, styleValue)
+              "textVariableAnchor" ->
+                setTextVariableAnchor(layer, styleValue)
+              "textAnchor" ->
+                setTextAnchor(layer, styleValue)
+              "textMaxAngle" ->
+                setTextMaxAngle(layer, styleValue)
+              "textWritingMode" ->
+                setTextWritingMode(layer, styleValue)
+              "textRotate" ->
+                setTextRotate(layer, styleValue)
+              "textPadding" ->
+                setTextPadding(layer, styleValue)
+              "textKeepUpright" ->
+                setTextKeepUpright(layer, styleValue)
+              "textTransform" ->
+                setTextTransform(layer, styleValue)
+              "textOffset" ->
+                setTextOffset(layer, styleValue)
+              "textAllowOverlap" ->
+                setTextAllowOverlap(layer, styleValue)
+              "textIgnorePlacement" ->
+                setTextIgnorePlacement(layer, styleValue)
+              "textOptional" ->
+                setTextOptional(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "iconOpacity" ->
+                setIconOpacity(layer, styleValue)
+                "iconOpacityTransition" ->
+                setIconOpacityTransition(layer, styleValue)
+              "iconColor" ->
+                setIconColor(layer, styleValue)
+                "iconColorTransition" ->
+                setIconColorTransition(layer, styleValue)
+              "iconHaloColor" ->
+                setIconHaloColor(layer, styleValue)
+                "iconHaloColorTransition" ->
+                setIconHaloColorTransition(layer, styleValue)
+              "iconHaloWidth" ->
+                setIconHaloWidth(layer, styleValue)
+                "iconHaloWidthTransition" ->
+                setIconHaloWidthTransition(layer, styleValue)
+              "iconHaloBlur" ->
+                setIconHaloBlur(layer, styleValue)
+                "iconHaloBlurTransition" ->
+                setIconHaloBlurTransition(layer, styleValue)
+              "iconTranslate" ->
+                setIconTranslate(layer, styleValue)
+                "iconTranslateTransition" ->
+                setIconTranslateTransition(layer, styleValue)
+              "iconTranslateAnchor" ->
+                setIconTranslateAnchor(layer, styleValue)
+              "textOpacity" ->
+                setTextOpacity(layer, styleValue)
+                "textOpacityTransition" ->
+                setTextOpacityTransition(layer, styleValue)
+              "textColor" ->
+                setTextColor(layer, styleValue)
+                "textColorTransition" ->
+                setTextColorTransition(layer, styleValue)
+              "textHaloColor" ->
+                setTextHaloColor(layer, styleValue)
+                "textHaloColorTransition" ->
+                setTextHaloColorTransition(layer, styleValue)
+              "textHaloWidth" ->
+                setTextHaloWidth(layer, styleValue)
+                "textHaloWidthTransition" ->
+                setTextHaloWidthTransition(layer, styleValue)
+              "textHaloBlur" ->
+                setTextHaloBlur(layer, styleValue)
+                "textHaloBlurTransition" ->
+                setTextHaloBlurTransition(layer, styleValue)
+              "textTranslate" ->
+                setTextTranslate(layer, styleValue)
+                "textTranslateTransition" ->
+                setTextTranslateTransition(layer, styleValue)
+              "textTranslateAnchor" ->
+                setTextTranslateAnchor(layer, styleValue)
+              "symbolZElevate" ->
+                setSymbolZElevate(layer, styleValue)
+              "symbolElevationReference" ->
+                setSymbolElevationReference(layer, styleValue)
+              "iconOcclusionOpacity" ->
+                setIconOcclusionOpacity(layer, styleValue)
+                "iconOcclusionOpacityTransition" ->
+                setIconOcclusionOpacityTransition(layer, styleValue)
+              "iconEmissiveStrength" ->
+                setIconEmissiveStrength(layer, styleValue)
+                "iconEmissiveStrengthTransition" ->
+                setIconEmissiveStrengthTransition(layer, styleValue)
+              "textEmissiveStrength" ->
+                setTextEmissiveStrength(layer, styleValue)
+                "textEmissiveStrengthTransition" ->
+                setTextEmissiveStrengthTransition(layer, styleValue)
+              "iconImageCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setIconImageCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXSymbol",String.format("Exception failed during setIconImageCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "textOcclusionOpacity" ->
+                setTextOcclusionOpacity(layer, styleValue)
+                "textOcclusionOpacityTransition" ->
+                setTextOcclusionOpacityTransition(layer, styleValue)
+              "iconColorSaturation" ->
+                setIconColorSaturation(layer, styleValue)
+              "symbolZOffset" ->
+                setSymbolZOffset(layer, styleValue)
+                "symbolZOffsetTransition" ->
+                setSymbolZOffsetTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setCircleLayerStyle(layer: CircleLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "circleSortKey" ->
+                setCircleSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "circleRadius" ->
+                setCircleRadius(layer, styleValue)
+                "circleRadiusTransition" ->
+                setCircleRadiusTransition(layer, styleValue)
+              "circleColor" ->
+                setCircleColor(layer, styleValue)
+                "circleColorTransition" ->
+                setCircleColorTransition(layer, styleValue)
+              "circleBlur" ->
+                setCircleBlur(layer, styleValue)
+                "circleBlurTransition" ->
+                setCircleBlurTransition(layer, styleValue)
+              "circleOpacity" ->
+                setCircleOpacity(layer, styleValue)
+                "circleOpacityTransition" ->
+                setCircleOpacityTransition(layer, styleValue)
+              "circleTranslate" ->
+                setCircleTranslate(layer, styleValue)
+                "circleTranslateTransition" ->
+                setCircleTranslateTransition(layer, styleValue)
+              "circleTranslateAnchor" ->
+                setCircleTranslateAnchor(layer, styleValue)
+              "circlePitchScale" ->
+                setCirclePitchScale(layer, styleValue)
+              "circlePitchAlignment" ->
+                setCirclePitchAlignment(layer, styleValue)
+              "circleStrokeWidth" ->
+                setCircleStrokeWidth(layer, styleValue)
+                "circleStrokeWidthTransition" ->
+                setCircleStrokeWidthTransition(layer, styleValue)
+              "circleStrokeColor" ->
+                setCircleStrokeColor(layer, styleValue)
+                "circleStrokeColorTransition" ->
+                setCircleStrokeColorTransition(layer, styleValue)
+              "circleStrokeOpacity" ->
+                setCircleStrokeOpacity(layer, styleValue)
+                "circleStrokeOpacityTransition" ->
+                setCircleStrokeOpacityTransition(layer, styleValue)
+              "circleElevationReference" ->
+                setCircleElevationReference(layer, styleValue)
+              "circleEmissiveStrength" ->
+                setCircleEmissiveStrength(layer, styleValue)
+                "circleEmissiveStrengthTransition" ->
+                setCircleEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setHeatmapLayerStyle(layer: HeatmapLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "heatmapRadius" ->
+                setHeatmapRadius(layer, styleValue)
+                "heatmapRadiusTransition" ->
+                setHeatmapRadiusTransition(layer, styleValue)
+              "heatmapWeight" ->
+                setHeatmapWeight(layer, styleValue)
+              "heatmapIntensity" ->
+                setHeatmapIntensity(layer, styleValue)
+                "heatmapIntensityTransition" ->
+                setHeatmapIntensityTransition(layer, styleValue)
+              "heatmapColor" ->
+                setHeatmapColor(layer, styleValue)
+              "heatmapOpacity" ->
+                setHeatmapOpacity(layer, styleValue)
+                "heatmapOpacityTransition" ->
+                setHeatmapOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setFillExtrusionLayerStyle(layer: FillExtrusionLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "fillExtrusionEdgeRadius" ->
+                setFillExtrusionEdgeRadius(layer, styleValue)
+              "fillExtrusionOpacity" ->
+                setFillExtrusionOpacity(layer, styleValue)
+                "fillExtrusionOpacityTransition" ->
+                setFillExtrusionOpacityTransition(layer, styleValue)
+              "fillExtrusionColor" ->
+                setFillExtrusionColor(layer, styleValue)
+                "fillExtrusionColorTransition" ->
+                setFillExtrusionColorTransition(layer, styleValue)
+              "fillExtrusionTranslate" ->
+                setFillExtrusionTranslate(layer, styleValue)
+                "fillExtrusionTranslateTransition" ->
+                setFillExtrusionTranslateTransition(layer, styleValue)
+              "fillExtrusionTranslateAnchor" ->
+                setFillExtrusionTranslateAnchor(layer, styleValue)
+              "fillExtrusionPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillExtrusionPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "fillExtrusionHeight" ->
+                setFillExtrusionHeight(layer, styleValue)
+                "fillExtrusionHeightTransition" ->
+                setFillExtrusionHeightTransition(layer, styleValue)
+              "fillExtrusionBase" ->
+                setFillExtrusionBase(layer, styleValue)
+                "fillExtrusionBaseTransition" ->
+                setFillExtrusionBaseTransition(layer, styleValue)
+              "fillExtrusionVerticalGradient" ->
+                setFillExtrusionVerticalGradient(layer, styleValue)
+              "fillExtrusionAmbientOcclusionIntensity" ->
+                setFillExtrusionAmbientOcclusionIntensity(layer, styleValue)
+                "fillExtrusionAmbientOcclusionIntensityTransition" ->
+                setFillExtrusionAmbientOcclusionIntensityTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionRadius" ->
+                setFillExtrusionAmbientOcclusionRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionRadiusTransition(layer, styleValue)
+              "fillExtrusionRoundedRoof" ->
+                setFillExtrusionRoundedRoof(layer, styleValue)
+              "fillExtrusionPatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillExtrusionPatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "fillExtrusionHeightAlignment" ->
+                setFillExtrusionHeightAlignment(layer, styleValue)
+              "fillExtrusionBaseAlignment" ->
+                setFillExtrusionBaseAlignment(layer, styleValue)
+              "fillExtrusionAmbientOcclusionWallRadius" ->
+                setFillExtrusionAmbientOcclusionWallRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionWallRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionWallRadiusTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionGroundRadius" ->
+                setFillExtrusionAmbientOcclusionGroundRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionGroundRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionGroundRadiusTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionGroundAttenuation" ->
+                setFillExtrusionAmbientOcclusionGroundAttenuation(layer, styleValue)
+                "fillExtrusionAmbientOcclusionGroundAttenuationTransition" ->
+                setFillExtrusionAmbientOcclusionGroundAttenuationTransition(layer, styleValue)
+              "fillExtrusionFloodLightColor" ->
+                setFillExtrusionFloodLightColor(layer, styleValue)
+                "fillExtrusionFloodLightColorTransition" ->
+                setFillExtrusionFloodLightColorTransition(layer, styleValue)
+              "fillExtrusionFloodLightIntensity" ->
+                setFillExtrusionFloodLightIntensity(layer, styleValue)
+                "fillExtrusionFloodLightIntensityTransition" ->
+                setFillExtrusionFloodLightIntensityTransition(layer, styleValue)
+              "fillExtrusionFloodLightWallRadius" ->
+                setFillExtrusionFloodLightWallRadius(layer, styleValue)
+                "fillExtrusionFloodLightWallRadiusTransition" ->
+                setFillExtrusionFloodLightWallRadiusTransition(layer, styleValue)
+              "fillExtrusionFloodLightGroundRadius" ->
+                setFillExtrusionFloodLightGroundRadius(layer, styleValue)
+                "fillExtrusionFloodLightGroundRadiusTransition" ->
+                setFillExtrusionFloodLightGroundRadiusTransition(layer, styleValue)
+              "fillExtrusionFloodLightGroundAttenuation" ->
+                setFillExtrusionFloodLightGroundAttenuation(layer, styleValue)
+                "fillExtrusionFloodLightGroundAttenuationTransition" ->
+                setFillExtrusionFloodLightGroundAttenuationTransition(layer, styleValue)
+              "fillExtrusionVerticalScale" ->
+                setFillExtrusionVerticalScale(layer, styleValue)
+                "fillExtrusionVerticalScaleTransition" ->
+                setFillExtrusionVerticalScaleTransition(layer, styleValue)
+              "fillExtrusionCutoffFadeRange" ->
+                setFillExtrusionCutoffFadeRange(layer, styleValue)
+              "fillExtrusionEmissiveStrength" ->
+                setFillExtrusionEmissiveStrength(layer, styleValue)
+                "fillExtrusionEmissiveStrengthTransition" ->
+                setFillExtrusionEmissiveStrengthTransition(layer, styleValue)
+              "fillExtrusionLineWidth" ->
+                setFillExtrusionLineWidth(layer, styleValue)
+                "fillExtrusionLineWidthTransition" ->
+                setFillExtrusionLineWidthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setRasterLayerStyle(layer: RasterLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "rasterOpacity" ->
+                setRasterOpacity(layer, styleValue)
+                "rasterOpacityTransition" ->
+                setRasterOpacityTransition(layer, styleValue)
+              "rasterHueRotate" ->
+                setRasterHueRotate(layer, styleValue)
+                "rasterHueRotateTransition" ->
+                setRasterHueRotateTransition(layer, styleValue)
+              "rasterBrightnessMin" ->
+                setRasterBrightnessMin(layer, styleValue)
+                "rasterBrightnessMinTransition" ->
+                setRasterBrightnessMinTransition(layer, styleValue)
+              "rasterBrightnessMax" ->
+                setRasterBrightnessMax(layer, styleValue)
+                "rasterBrightnessMaxTransition" ->
+                setRasterBrightnessMaxTransition(layer, styleValue)
+              "rasterSaturation" ->
+                setRasterSaturation(layer, styleValue)
+                "rasterSaturationTransition" ->
+                setRasterSaturationTransition(layer, styleValue)
+              "rasterContrast" ->
+                setRasterContrast(layer, styleValue)
+                "rasterContrastTransition" ->
+                setRasterContrastTransition(layer, styleValue)
+              "rasterResampling" ->
+                setRasterResampling(layer, styleValue)
+              "rasterFadeDuration" ->
+                setRasterFadeDuration(layer, styleValue)
+              "rasterColor" ->
+                setRasterColor(layer, styleValue)
+              "rasterColorMix" ->
+                setRasterColorMix(layer, styleValue)
+                "rasterColorMixTransition" ->
+                setRasterColorMixTransition(layer, styleValue)
+              "rasterColorRange" ->
+                setRasterColorRange(layer, styleValue)
+                "rasterColorRangeTransition" ->
+                setRasterColorRangeTransition(layer, styleValue)
+              "rasterEmissiveStrength" ->
+                setRasterEmissiveStrength(layer, styleValue)
+                "rasterEmissiveStrengthTransition" ->
+                setRasterEmissiveStrengthTransition(layer, styleValue)
+              "rasterArrayBand" ->
+                setRasterArrayBand(layer, styleValue)
+              "rasterElevation" ->
+                setRasterElevation(layer, styleValue)
+                "rasterElevationTransition" ->
+                setRasterElevationTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setRasterParticleLayerStyle(layer: RasterParticleLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "rasterParticleArrayBand" ->
+                setRasterParticleArrayBand(layer, styleValue)
+              "rasterParticleCount" ->
+                setRasterParticleCount(layer, styleValue)
+              "rasterParticleColor" ->
+                setRasterParticleColor(layer, styleValue)
+              "rasterParticleMaxSpeed" ->
+                setRasterParticleMaxSpeed(layer, styleValue)
+              "rasterParticleSpeedFactor" ->
+                setRasterParticleSpeedFactor(layer, styleValue)
+                "rasterParticleSpeedFactorTransition" ->
+                setRasterParticleSpeedFactorTransition(layer, styleValue)
+              "rasterParticleFadeOpacityFactor" ->
+                setRasterParticleFadeOpacityFactor(layer, styleValue)
+                "rasterParticleFadeOpacityFactorTransition" ->
+                setRasterParticleFadeOpacityFactorTransition(layer, styleValue)
+              "rasterParticleResetRateFactor" ->
+                setRasterParticleResetRateFactor(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setHillshadeLayerStyle(layer: HillshadeLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "hillshadeIlluminationDirection" ->
+                setHillshadeIlluminationDirection(layer, styleValue)
+              "hillshadeIlluminationAnchor" ->
+                setHillshadeIlluminationAnchor(layer, styleValue)
+              "hillshadeExaggeration" ->
+                setHillshadeExaggeration(layer, styleValue)
+                "hillshadeExaggerationTransition" ->
+                setHillshadeExaggerationTransition(layer, styleValue)
+              "hillshadeShadowColor" ->
+                setHillshadeShadowColor(layer, styleValue)
+                "hillshadeShadowColorTransition" ->
+                setHillshadeShadowColorTransition(layer, styleValue)
+              "hillshadeHighlightColor" ->
+                setHillshadeHighlightColor(layer, styleValue)
+                "hillshadeHighlightColorTransition" ->
+                setHillshadeHighlightColorTransition(layer, styleValue)
+              "hillshadeAccentColor" ->
+                setHillshadeAccentColor(layer, styleValue)
+                "hillshadeAccentColorTransition" ->
+                setHillshadeAccentColorTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setModelLayerStyle(layer: ModelLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "modelId" ->
+                setModelId(layer, styleValue)
+              "modelOpacity" ->
+                setModelOpacity(layer, styleValue)
+                "modelOpacityTransition" ->
+                setModelOpacityTransition(layer, styleValue)
+              "modelRotation" ->
+                setModelRotation(layer, styleValue)
+                "modelRotationTransition" ->
+                setModelRotationTransition(layer, styleValue)
+              "modelScale" ->
+                setModelScale(layer, styleValue)
+                "modelScaleTransition" ->
+                setModelScaleTransition(layer, styleValue)
+              "modelTranslation" ->
+                setModelTranslation(layer, styleValue)
+                "modelTranslationTransition" ->
+                setModelTranslationTransition(layer, styleValue)
+              "modelColor" ->
+                setModelColor(layer, styleValue)
+                "modelColorTransition" ->
+                setModelColorTransition(layer, styleValue)
+              "modelColorMixIntensity" ->
+                setModelColorMixIntensity(layer, styleValue)
+                "modelColorMixIntensityTransition" ->
+                setModelColorMixIntensityTransition(layer, styleValue)
+              "modelType" ->
+                setModelType(layer, styleValue)
+              "modelCastShadows" ->
+                setModelCastShadows(layer, styleValue)
+              "modelReceiveShadows" ->
+                setModelReceiveShadows(layer, styleValue)
+              "modelAmbientOcclusionIntensity" ->
+                setModelAmbientOcclusionIntensity(layer, styleValue)
+                "modelAmbientOcclusionIntensityTransition" ->
+                setModelAmbientOcclusionIntensityTransition(layer, styleValue)
+              "modelEmissiveStrength" ->
+                setModelEmissiveStrength(layer, styleValue)
+                "modelEmissiveStrengthTransition" ->
+                setModelEmissiveStrengthTransition(layer, styleValue)
+              "modelRoughness" ->
+                setModelRoughness(layer, styleValue)
+                "modelRoughnessTransition" ->
+                setModelRoughnessTransition(layer, styleValue)
+              "modelHeightBasedEmissiveStrengthMultiplier" ->
+                setModelHeightBasedEmissiveStrengthMultiplier(layer, styleValue)
+                "modelHeightBasedEmissiveStrengthMultiplierTransition" ->
+                setModelHeightBasedEmissiveStrengthMultiplierTransition(layer, styleValue)
+              "modelCutoffFadeRange" ->
+                setModelCutoffFadeRange(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setBackgroundLayerStyle(layer: BackgroundLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "backgroundColor" ->
+                setBackgroundColor(layer, styleValue)
+                "backgroundColorTransition" ->
+                setBackgroundColorTransition(layer, styleValue)
+              "backgroundPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setBackgroundPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXBackground",String.format("Exception failed during setBackgroundPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "backgroundOpacity" ->
+                setBackgroundOpacity(layer, styleValue)
+                "backgroundOpacityTransition" ->
+                setBackgroundOpacityTransition(layer, styleValue)
+              "backgroundPitchAlignment" ->
+                setBackgroundPitchAlignment(layer, styleValue)
+              "backgroundEmissiveStrength" ->
+                setBackgroundEmissiveStrength(layer, styleValue)
+                "backgroundEmissiveStrengthTransition" ->
+                setBackgroundEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setSkyLayerStyle(layer: SkyLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "skyType" ->
+                setSkyType(layer, styleValue)
+              "skyAtmosphereSun" ->
+                setSkyAtmosphereSun(layer, styleValue)
+              "skyAtmosphereSunIntensity" ->
+                setSkyAtmosphereSunIntensity(layer, styleValue)
+              "skyGradientCenter" ->
+                setSkyGradientCenter(layer, styleValue)
+              "skyGradientRadius" ->
+                setSkyGradientRadius(layer, styleValue)
+              "skyGradient" ->
+                setSkyGradient(layer, styleValue)
+              "skyAtmosphereHaloColor" ->
+                setSkyAtmosphereHaloColor(layer, styleValue)
+              "skyAtmosphereColor" ->
+                setSkyAtmosphereColor(layer, styleValue)
+              "skyOpacity" ->
+                setSkyOpacity(layer, styleValue)
+                "skyOpacityTransition" ->
+                setSkyOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setLightLayerStyle(layer: Light, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "anchor" ->
+                setAnchor(layer, styleValue)
+              "position" ->
+                setPosition(layer, styleValue)
+                "positionTransition" ->
+                setPositionTransition(layer, styleValue)
+              "color" ->
+                setColor(layer, styleValue)
+                "colorTransition" ->
+                setColorTransition(layer, styleValue)
+              "intensity" ->
+                setIntensity(layer, styleValue)
+                "intensityTransition" ->
+                setIntensityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setAtmosphereLayerStyle(layer: Atmosphere, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "range" ->
+                setRange(layer, styleValue)
+                "rangeTransition" ->
+                setRangeTransition(layer, styleValue)
+              "color" ->
+                setColor(layer, styleValue)
+                "colorTransition" ->
+                setColorTransition(layer, styleValue)
+              "highColor" ->
+                setHighColor(layer, styleValue)
+                "highColorTransition" ->
+                setHighColorTransition(layer, styleValue)
+              "spaceColor" ->
+                setSpaceColor(layer, styleValue)
+                "spaceColorTransition" ->
+                setSpaceColorTransition(layer, styleValue)
+              "horizonBlend" ->
+                setHorizonBlend(layer, styleValue)
+                "horizonBlendTransition" ->
+                setHorizonBlendTransition(layer, styleValue)
+              "starIntensity" ->
+                setStarIntensity(layer, styleValue)
+                "starIntensityTransition" ->
+                setStarIntensityTransition(layer, styleValue)
+              "verticalRange" ->
+                setVerticalRange(layer, styleValue)
+                "verticalRangeTransition" ->
+                setVerticalRangeTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setTerrainLayerStyle(layer: Terrain, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "exaggeration" ->
+                setExaggeration(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+
+    fun setFillSortKey(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillSortKey(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillSortKey(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setFillAntialias(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillAntialias(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillAntialias is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillAntialias(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillAntialias is null")
+          }
+      }
+    }
+
+    fun setFillOpacity(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillOpacity(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillOpacity(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillOpacity is null")
+          }
+      }
+    }
+
+
+    fun setFillOpacityTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillOpacityTransition(transition);
+      }
+    }
+
+    fun setFillColor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillColor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillColor(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillColor is null")
+          }
+      }
+    }
+
+
+    fun setFillColorTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillColorTransition(transition);
+      }
+    }
+
+    fun setFillOutlineColor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillOutlineColor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillOutlineColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillOutlineColor(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillOutlineColor is null")
+          }
+      }
+    }
+
+
+    fun setFillOutlineColorTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillOutlineColorTransition(transition);
+      }
+    }
+
+    fun setFillTranslate(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillTranslate(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.fillTranslate(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillTranslate is null")
+          }
+      }
+    }
+
+
+    fun setFillTranslateTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillTranslateTransition(transition);
+      }
+    }
+
+    fun setFillTranslateAnchor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillTranslateAnchor is null")
+        }
+      } else {
+          layer.fillTranslateAnchor(FillTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillPattern(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.fillPattern(value)
+          } else {
+            Logger.e("RNMBXFill", "Image for fillPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.fillPattern(expression)
+          } else {
+            Logger.e("RNMBXFill", "Expression for fillPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.fillPattern(value);
+        } else {
+          Logger.e("RNMBXFill", "value for fillPattern is null")
+        }
+      }
+    }
+
+    fun setFillPatternCrossFade(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillPatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillPatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillPatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillPatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setFillEmissiveStrength(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setFillEmissiveStrengthTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setLineCap(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineCap(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineCap is null")
+        }
+      } else {
+          layer.lineCap(LineCap.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineJoin(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineJoin(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineJoin is null")
+        }
+      } else {
+          layer.lineJoin(LineJoin.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineMiterLimit(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineMiterLimit(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineMiterLimit is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineMiterLimit(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineMiterLimit is null")
+          }
+      }
+    }
+
+    fun setLineRoundLimit(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineRoundLimit(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineRoundLimit is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineRoundLimit(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineRoundLimit is null")
+          }
+      }
+    }
+
+    fun setLineSortKey(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineSortKey(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineSortKey(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setLineOpacity(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOpacity(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOpacity(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOpacity is null")
+          }
+      }
+    }
+
+
+    fun setLineOpacityTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOpacityTransition(transition);
+      }
+    }
+
+    fun setLineColor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineColor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.lineColor(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineColor is null")
+          }
+      }
+    }
+
+
+    fun setLineColorTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineColorTransition(transition);
+      }
+    }
+
+    fun setLineTranslate(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTranslate(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTranslate(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTranslate is null")
+          }
+      }
+    }
+
+
+    fun setLineTranslateTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineTranslateTransition(transition);
+      }
+    }
+
+    fun setLineTranslateAnchor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTranslateAnchor is null")
+        }
+      } else {
+          layer.lineTranslateAnchor(LineTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineWidth(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineWidth(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineWidth(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineWidth is null")
+          }
+      }
+    }
+
+
+    fun setLineWidthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineWidthTransition(transition);
+      }
+    }
+
+    fun setLineGapWidth(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineGapWidth(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineGapWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineGapWidth(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineGapWidth is null")
+          }
+      }
+    }
+
+
+    fun setLineGapWidthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineGapWidthTransition(transition);
+      }
+    }
+
+    fun setLineOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOffset is null")
+          }
+      }
+    }
+
+
+    fun setLineOffsetTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOffsetTransition(transition);
+      }
+    }
+
+    fun setLineBlur(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineBlur(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineBlur(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineBlur is null")
+          }
+      }
+    }
+
+
+    fun setLineBlurTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineBlurTransition(transition);
+      }
+    }
+
+    fun setLineDasharray(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineDasharray(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineDasharray is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineDasharray(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineDasharray is null")
+          }
+      }
+    }
+
+    fun setLinePattern(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.linePattern(value)
+          } else {
+            Logger.e("RNMBXLine", "Image for linePattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.linePattern(expression)
+          } else {
+            Logger.e("RNMBXLine", "Expression for linePattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.linePattern(value);
+        } else {
+          Logger.e("RNMBXLine", "value for linePattern is null")
+        }
+      }
+    }
+
+    fun setLineGradient(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineGradient(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineGradient is null")
+        }
+      } else {
+          layer.lineGradient(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setLineTrimOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimOffset is null")
+          }
+      }
+    }
+
+    fun setLineZOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineZOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineZOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineZOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineZOffset is null")
+          }
+      }
+    }
+
+    fun setLineElevationReference(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineElevationReference(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineElevationReference is null")
+        }
+      } else {
+          layer.lineElevationReference(LineElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineCrossSlope(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineCrossSlope(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineCrossSlope is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineCrossSlope(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineCrossSlope is null")
+          }
+      }
+    }
+
+    fun setLinePatternCrossFade(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.linePatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for linePatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.linePatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXLine", "value for linePatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setLineTrimFadeRange(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimFadeRange(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimFadeRange(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimFadeRange is null")
+          }
+      }
+    }
+
+    fun setLineTrimColor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimColor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimColor(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimColor is null")
+          }
+      }
+    }
+
+
+    fun setLineTrimColorTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineTrimColorTransition(transition);
+      }
+    }
+
+    fun setLineEmissiveStrength(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setLineEmissiveStrengthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setLineOcclusionOpacity(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setLineOcclusionOpacityTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setSymbolPlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolPlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolPlacement is null")
+        }
+      } else {
+          layer.symbolPlacement(SymbolPlacement.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSymbolSpacing(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolSpacing(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolSpacing is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolSpacing(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolSpacing is null")
+          }
+      }
+    }
+
+    fun setSymbolAvoidEdges(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolAvoidEdges(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolAvoidEdges is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.symbolAvoidEdges(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolAvoidEdges is null")
+          }
+      }
+    }
+
+    fun setSymbolSortKey(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolSortKey(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolSortKey(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolSortKey is null")
+          }
+      }
+    }
+
+    fun setSymbolZOrder(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZOrder(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZOrder is null")
+        }
+      } else {
+          layer.symbolZOrder(SymbolZOrder.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconAllowOverlap(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconAllowOverlap(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconAllowOverlap is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconAllowOverlap(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconAllowOverlap is null")
+          }
+      }
+    }
+
+    fun setIconIgnorePlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconIgnorePlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconIgnorePlacement is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconIgnorePlacement(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconIgnorePlacement is null")
+          }
+      }
+    }
+
+    fun setIconOptional(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOptional(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOptional is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconOptional(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOptional is null")
+          }
+      }
+    }
+
+    fun setIconRotationAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconRotationAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconRotationAlignment is null")
+        }
+      } else {
+          layer.iconRotationAlignment(IconRotationAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconSize(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconSize(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconSize is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconSize(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconSize is null")
+          }
+      }
+    }
+
+    fun setIconTextFit(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTextFit(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTextFit is null")
+        }
+      } else {
+          layer.iconTextFit(IconTextFit.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconTextFitPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTextFitPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTextFitPadding is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconTextFitPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconTextFitPadding is null")
+          }
+      }
+    }
+
+    fun setIconImage(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.iconImage(value)
+          } else {
+            Logger.e("RNMBXSymbol", "Image for iconImage is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.iconImage(expression)
+          } else {
+            Logger.e("RNMBXSymbol", "Expression for iconImage is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.iconImage(value);
+        } else {
+          Logger.e("RNMBXSymbol", "value for iconImage is null")
+        }
+      }
+    }
+
+    fun setIconRotate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconRotate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconRotate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconRotate is null")
+          }
+      }
+    }
+
+    fun setIconPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconPadding is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconPadding is null")
+          }
+      }
+    }
+
+    fun setIconKeepUpright(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconKeepUpright(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconKeepUpright is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconKeepUpright(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconKeepUpright is null")
+          }
+      }
+    }
+
+    fun setIconOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOffset is null")
+          }
+      }
+    }
+
+    fun setIconAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconAnchor is null")
+        }
+      } else {
+          layer.iconAnchor(IconAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconPitchAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconPitchAlignment is null")
+        }
+      } else {
+          layer.iconPitchAlignment(IconPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextPitchAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textPitchAlignment is null")
+        }
+      } else {
+          layer.textPitchAlignment(TextPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextRotationAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRotationAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRotationAlignment is null")
+        }
+      } else {
+          layer.textRotationAlignment(TextRotationAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextField(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textField(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textField is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.textField(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textField is null")
+          }
+      }
+    }
+
+    fun setTextFont(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textFont(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textFont is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textFont(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textFont is null")
+          }
+      }
+    }
+
+    fun setTextSize(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textSize(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textSize is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textSize(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textSize is null")
+          }
+      }
+    }
+
+    fun setTextMaxWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textMaxWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textMaxWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textMaxWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textMaxWidth is null")
+          }
+      }
+    }
+
+    fun setTextLineHeight(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textLineHeight(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textLineHeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textLineHeight(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textLineHeight is null")
+          }
+      }
+    }
+
+    fun setTextLetterSpacing(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textLetterSpacing(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textLetterSpacing is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textLetterSpacing(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textLetterSpacing is null")
+          }
+      }
+    }
+
+    fun setTextJustify(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textJustify(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textJustify is null")
+        }
+      } else {
+          layer.textJustify(TextJustify.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextRadialOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRadialOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRadialOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textRadialOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textRadialOffset is null")
+          }
+      }
+    }
+
+    fun setTextVariableAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textVariableAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textVariableAnchor is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textVariableAnchor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textVariableAnchor is null")
+          }
+      }
+    }
+
+    fun setTextAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textAnchor is null")
+        }
+      } else {
+          layer.textAnchor(TextAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextMaxAngle(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textMaxAngle(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textMaxAngle is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textMaxAngle(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textMaxAngle is null")
+          }
+      }
+    }
+
+    fun setTextWritingMode(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textWritingMode(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textWritingMode is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textWritingMode(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textWritingMode is null")
+          }
+      }
+    }
+
+    fun setTextRotate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRotate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textRotate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textRotate is null")
+          }
+      }
+    }
+
+    fun setTextPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textPadding is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textPadding is null")
+          }
+      }
+    }
+
+    fun setTextKeepUpright(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textKeepUpright(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textKeepUpright is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textKeepUpright(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textKeepUpright is null")
+          }
+      }
+    }
+
+    fun setTextTransform(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTransform(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTransform is null")
+        }
+      } else {
+          layer.textTransform(TextTransform.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.textOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOffset is null")
+          }
+      }
+    }
+
+    fun setTextAllowOverlap(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textAllowOverlap(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textAllowOverlap is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textAllowOverlap(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textAllowOverlap is null")
+          }
+      }
+    }
+
+    fun setTextIgnorePlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textIgnorePlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textIgnorePlacement is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textIgnorePlacement(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textIgnorePlacement is null")
+          }
+      }
+    }
+
+    fun setTextOptional(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOptional(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOptional is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textOptional(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOptional is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setIconOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOpacity is null")
+          }
+      }
+    }
+
+
+    fun setIconOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconOpacityTransition(transition);
+      }
+    }
+
+    fun setIconColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.iconColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconColor is null")
+          }
+      }
+    }
+
+
+    fun setIconColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconColorTransition(transition);
+      }
+    }
+
+    fun setIconHaloColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloColor is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloColorTransition(transition);
+      }
+    }
+
+    fun setIconHaloWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloWidth is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloWidthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloWidthTransition(transition);
+      }
+    }
+
+    fun setIconHaloBlur(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloBlur(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloBlur(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloBlur is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloBlurTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloBlurTransition(transition);
+      }
+    }
+
+    fun setIconTranslate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTranslate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconTranslate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconTranslate is null")
+          }
+      }
+    }
+
+
+    fun setIconTranslateTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconTranslateTransition(transition);
+      }
+    }
+
+    fun setIconTranslateAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTranslateAnchor is null")
+        }
+      } else {
+          layer.iconTranslateAnchor(IconTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOpacity is null")
+          }
+      }
+    }
+
+
+    fun setTextOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textOpacityTransition(transition);
+      }
+    }
+
+    fun setTextColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.textColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textColor is null")
+          }
+      }
+    }
+
+
+    fun setTextColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textColorTransition(transition);
+      }
+    }
+
+    fun setTextHaloColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloColor is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloColorTransition(transition);
+      }
+    }
+
+    fun setTextHaloWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloWidth is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloWidthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloWidthTransition(transition);
+      }
+    }
+
+    fun setTextHaloBlur(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloBlur(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloBlur(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloBlur is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloBlurTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloBlurTransition(transition);
+      }
+    }
+
+    fun setTextTranslate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTranslate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.textTranslate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textTranslate is null")
+          }
+      }
+    }
+
+
+    fun setTextTranslateTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textTranslateTransition(transition);
+      }
+    }
+
+    fun setTextTranslateAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTranslateAnchor is null")
+        }
+      } else {
+          layer.textTranslateAnchor(TextTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSymbolZElevate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZElevate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZElevate is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.symbolZElevate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolZElevate is null")
+          }
+      }
+    }
+
+    fun setSymbolElevationReference(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolElevationReference(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolElevationReference is null")
+        }
+      } else {
+          layer.symbolElevationReference(SymbolElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconOcclusionOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setIconOcclusionOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setIconEmissiveStrength(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setIconEmissiveStrengthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setTextEmissiveStrength(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setTextEmissiveStrengthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setIconImageCrossFade(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconImageCrossFade(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconImageCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconImageCrossFade(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconImageCrossFade is null")
+          }
+      }
+    }
+
+    fun setTextOcclusionOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setTextOcclusionOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setIconColorSaturation(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconColorSaturation(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconColorSaturation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconColorSaturation(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconColorSaturation is null")
+          }
+      }
+    }
+
+    fun setSymbolZOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolZOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolZOffset is null")
+          }
+      }
+    }
+
+
+    fun setSymbolZOffsetTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.symbolZOffsetTransition(transition);
+      }
+    }
+
+    fun setCircleSortKey(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleSortKey(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleSortKey(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setCircleRadius(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleRadius(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleRadius(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleRadius is null")
+          }
+      }
+    }
+
+
+    fun setCircleRadiusTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleRadiusTransition(transition);
+      }
+    }
+
+    fun setCircleColor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleColor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.circleColor(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleColor is null")
+          }
+      }
+    }
+
+
+    fun setCircleColorTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleColorTransition(transition);
+      }
+    }
+
+    fun setCircleBlur(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleBlur(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleBlur(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleBlur is null")
+          }
+      }
+    }
+
+
+    fun setCircleBlurTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleBlurTransition(transition);
+      }
+    }
+
+    fun setCircleOpacity(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleOpacity(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleOpacity(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleOpacity is null")
+          }
+      }
+    }
+
+
+    fun setCircleOpacityTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleOpacityTransition(transition);
+      }
+    }
+
+    fun setCircleTranslate(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleTranslate(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.circleTranslate(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleTranslate is null")
+          }
+      }
+    }
+
+
+    fun setCircleTranslateTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleTranslateTransition(transition);
+      }
+    }
+
+    fun setCircleTranslateAnchor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleTranslateAnchor is null")
+        }
+      } else {
+          layer.circleTranslateAnchor(CircleTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCirclePitchScale(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circlePitchScale(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circlePitchScale is null")
+        }
+      } else {
+          layer.circlePitchScale(CirclePitchScale.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCirclePitchAlignment(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circlePitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circlePitchAlignment is null")
+        }
+      } else {
+          layer.circlePitchAlignment(CirclePitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCircleStrokeWidth(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeWidth(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeWidth(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeWidth is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeWidthTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeWidthTransition(transition);
+      }
+    }
+
+    fun setCircleStrokeColor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeColor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeColor(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeColor is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeColorTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeColorTransition(transition);
+      }
+    }
+
+    fun setCircleStrokeOpacity(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeOpacity(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeOpacity(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeOpacity is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeOpacityTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeOpacityTransition(transition);
+      }
+    }
+
+    fun setCircleElevationReference(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleElevationReference(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleElevationReference is null")
+        }
+      } else {
+          layer.circleElevationReference(CircleElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCircleEmissiveStrength(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setCircleEmissiveStrengthTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setHeatmapRadius(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapRadius(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapRadius(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapRadius is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapRadiusTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapRadiusTransition(transition);
+      }
+    }
+
+    fun setHeatmapWeight(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapWeight(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapWeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapWeight(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapWeight is null")
+          }
+      }
+    }
+
+    fun setHeatmapIntensity(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapIntensity(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapIntensity(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapIntensity is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapIntensityTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapIntensityTransition(transition);
+      }
+    }
+
+    fun setHeatmapColor(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapColor(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapColor is null")
+        }
+      } else {
+          layer.heatmapColor(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setHeatmapOpacity(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapOpacity(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapOpacity(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapOpacity is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapOpacityTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapOpacityTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setFillExtrusionEdgeRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionEdgeRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionEdgeRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionEdgeRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionEdgeRadius is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionOpacity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionOpacity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionOpacityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionOpacityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionColor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionColor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionColor(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionColor is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionColorTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionColorTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionTranslate(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionTranslate(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionTranslate(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionTranslate is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionTranslateTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionTranslateTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionTranslateAnchor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionTranslateAnchor is null")
+        }
+      } else {
+          layer.fillExtrusionTranslateAnchor(FillExtrusionTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionPattern(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.fillExtrusionPattern(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "Image for fillExtrusionPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.fillExtrusionPattern(expression)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.fillExtrusionPattern(value);
+        } else {
+          Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPattern is null")
+        }
+      }
+    }
+
+    fun setFillExtrusionHeight(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionHeight(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionHeight(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionHeight is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionHeightTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionHeightTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionBase(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionBase(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBase is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionBase(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionBase is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionBaseTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionBaseTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionVerticalGradient(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionVerticalGradient(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionVerticalGradient is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionVerticalGradient(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionVerticalGradient is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionIntensity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionIntensity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionIntensity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionIntensity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionIntensityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionIntensityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionRoundedRoof(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionRoundedRoof(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionRoundedRoof is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionRoundedRoof(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionRoundedRoof is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionPatternCrossFade(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionPatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionPatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionHeightAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionHeightAlignment(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeightAlignment is null")
+        }
+      } else {
+          layer.fillExtrusionHeightAlignment(FillExtrusionHeightAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionBaseAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionBaseAlignment(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBaseAlignment is null")
+        }
+      } else {
+          layer.fillExtrusionBaseAlignment(FillExtrusionBaseAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionWallRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionWallRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionWallRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionWallRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionWallRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionWallRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionGroundRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionGroundRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionGroundRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionGroundRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionGroundRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionGroundRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionGroundRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionGroundAttenuation(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionGroundAttenuation(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionGroundAttenuation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionGroundAttenuation(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionGroundAttenuation is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionGroundAttenuationTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionGroundAttenuationTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightColor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightColor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightColor(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightColor is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightColorTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightColorTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightIntensity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightIntensity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightIntensity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightIntensity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightIntensityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightIntensityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightWallRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightWallRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightWallRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightWallRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightWallRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightWallRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightGroundRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightGroundRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightGroundRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightGroundRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightGroundRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightGroundRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightGroundRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightGroundAttenuation(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightGroundAttenuation(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightGroundAttenuation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightGroundAttenuation(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightGroundAttenuation is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightGroundAttenuationTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightGroundAttenuationTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionVerticalScale(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionVerticalScale(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionVerticalScale is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionVerticalScale(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionVerticalScale is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionVerticalScaleTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionVerticalScaleTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionCutoffFadeRange(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionCutoffFadeRange(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionCutoffFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionCutoffFadeRange(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionCutoffFadeRange is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionEmissiveStrength(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionEmissiveStrengthTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionLineWidth(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionLineWidth(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionLineWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionLineWidth(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionLineWidth is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionLineWidthTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionLineWidthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setRasterOpacity(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterOpacity(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterOpacity(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterOpacity is null")
+          }
+      }
+    }
+
+
+    fun setRasterOpacityTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterOpacityTransition(transition);
+      }
+    }
+
+    fun setRasterHueRotate(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterHueRotate(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterHueRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterHueRotate(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterHueRotate is null")
+          }
+      }
+    }
+
+
+    fun setRasterHueRotateTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterHueRotateTransition(transition);
+      }
+    }
+
+    fun setRasterBrightnessMin(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterBrightnessMin(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterBrightnessMin is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterBrightnessMin(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterBrightnessMin is null")
+          }
+      }
+    }
+
+
+    fun setRasterBrightnessMinTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterBrightnessMinTransition(transition);
+      }
+    }
+
+    fun setRasterBrightnessMax(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterBrightnessMax(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterBrightnessMax is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterBrightnessMax(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterBrightnessMax is null")
+          }
+      }
+    }
+
+
+    fun setRasterBrightnessMaxTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterBrightnessMaxTransition(transition);
+      }
+    }
+
+    fun setRasterSaturation(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterSaturation(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterSaturation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterSaturation(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterSaturation is null")
+          }
+      }
+    }
+
+
+    fun setRasterSaturationTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterSaturationTransition(transition);
+      }
+    }
+
+    fun setRasterContrast(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterContrast(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterContrast is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterContrast(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterContrast is null")
+          }
+      }
+    }
+
+
+    fun setRasterContrastTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterContrastTransition(transition);
+      }
+    }
+
+    fun setRasterResampling(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterResampling(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterResampling is null")
+        }
+      } else {
+          layer.rasterResampling(RasterResampling.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setRasterFadeDuration(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterFadeDuration(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterFadeDuration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterFadeDuration(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterFadeDuration is null")
+          }
+      }
+    }
+
+    fun setRasterColor(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColor(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColor(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColor is null")
+          }
+      }
+    }
+
+    fun setRasterColorMix(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColorMix(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColorMix is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColorMix(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColorMix is null")
+          }
+      }
+    }
+
+
+    fun setRasterColorMixTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterColorMixTransition(transition);
+      }
+    }
+
+    fun setRasterColorRange(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColorRange(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColorRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColorRange(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColorRange is null")
+          }
+      }
+    }
+
+
+    fun setRasterColorRangeTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterColorRangeTransition(transition);
+      }
+    }
+
+    fun setRasterEmissiveStrength(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setRasterEmissiveStrengthTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setRasterArrayBand(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterArrayBand(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterArrayBand is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.rasterArrayBand(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterArrayBand is null")
+          }
+      }
+    }
+
+    fun setRasterElevation(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterElevation(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterElevation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterElevation(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterElevation is null")
+          }
+      }
+    }
+
+
+    fun setRasterElevationTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterElevationTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setRasterParticleArrayBand(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleArrayBand(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleArrayBand is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleArrayBand(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleArrayBand is null")
+          }
+      }
+    }
+
+    fun setRasterParticleCount(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleCount(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleCount is null")
+        }
+      } else {
+          val value = styleValue.getLong(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleCount(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleCount is null")
+          }
+      }
+    }
+
+    fun setRasterParticleColor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleColor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleColor is null")
+        }
+      } else {
+          layer.rasterParticleColor(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setRasterParticleMaxSpeed(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleMaxSpeed(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleMaxSpeed is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleMaxSpeed(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleMaxSpeed is null")
+          }
+      }
+    }
+
+    fun setRasterParticleSpeedFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleSpeedFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleSpeedFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleSpeedFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleSpeedFactor is null")
+          }
+      }
+    }
+
+
+    fun setRasterParticleSpeedFactorTransition(layer: RasterParticleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterParticleSpeedFactorTransition(transition);
+      }
+    }
+
+    fun setRasterParticleFadeOpacityFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleFadeOpacityFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleFadeOpacityFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleFadeOpacityFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleFadeOpacityFactor is null")
+          }
+      }
+    }
+
+
+    fun setRasterParticleFadeOpacityFactorTransition(layer: RasterParticleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterParticleFadeOpacityFactorTransition(transition);
+      }
+    }
+
+    fun setRasterParticleResetRateFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleResetRateFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleResetRateFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleResetRateFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleResetRateFactor is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setHillshadeIlluminationDirection(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeIlluminationDirection(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeIlluminationDirection is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeIlluminationDirection(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeIlluminationDirection is null")
+          }
+      }
+    }
+
+    fun setHillshadeIlluminationAnchor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeIlluminationAnchor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeIlluminationAnchor is null")
+        }
+      } else {
+          layer.hillshadeIlluminationAnchor(HillshadeIlluminationAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setHillshadeExaggeration(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeExaggeration(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeExaggeration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeExaggeration(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeExaggeration is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeExaggerationTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeExaggerationTransition(transition);
+      }
+    }
+
+    fun setHillshadeShadowColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeShadowColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeShadowColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeShadowColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeShadowColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeShadowColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeShadowColorTransition(transition);
+      }
+    }
+
+    fun setHillshadeHighlightColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeHighlightColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeHighlightColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeHighlightColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeHighlightColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeHighlightColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeHighlightColorTransition(transition);
+      }
+    }
+
+    fun setHillshadeAccentColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeAccentColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeAccentColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeAccentColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeAccentColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeAccentColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeAccentColorTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setModelId(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelId(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelId is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.modelId(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelId is null")
+          }
+      }
+    }
+
+    fun setModelOpacity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelOpacity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelOpacity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelOpacity is null")
+          }
+      }
+    }
+
+
+    fun setModelOpacityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelOpacityTransition(transition);
+      }
+    }
+
+    fun setModelRotation(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelRotation(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelRotation is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelRotation(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelRotation is null")
+          }
+      }
+    }
+
+
+    fun setModelRotationTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelRotationTransition(transition);
+      }
+    }
+
+    fun setModelScale(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelScale(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelScale is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelScale(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelScale is null")
+          }
+      }
+    }
+
+
+    fun setModelScaleTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelScaleTransition(transition);
+      }
+    }
+
+    fun setModelTranslation(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelTranslation(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelTranslation is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelTranslation(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelTranslation is null")
+          }
+      }
+    }
+
+
+    fun setModelTranslationTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelTranslationTransition(transition);
+      }
+    }
+
+    fun setModelColor(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelColor(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.modelColor(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelColor is null")
+          }
+      }
+    }
+
+
+    fun setModelColorTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelColorTransition(transition);
+      }
+    }
+
+    fun setModelColorMixIntensity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelColorMixIntensity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelColorMixIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelColorMixIntensity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelColorMixIntensity is null")
+          }
+      }
+    }
+
+
+    fun setModelColorMixIntensityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelColorMixIntensityTransition(transition);
+      }
+    }
+
+    fun setModelType(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelType(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelType is null")
+        }
+      } else {
+          layer.modelType(ModelType.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setModelCastShadows(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelCastShadows(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelCastShadows is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.modelCastShadows(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelCastShadows is null")
+          }
+      }
+    }
+
+    fun setModelReceiveShadows(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelReceiveShadows(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelReceiveShadows is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.modelReceiveShadows(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelReceiveShadows is null")
+          }
+      }
+    }
+
+    fun setModelAmbientOcclusionIntensity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelAmbientOcclusionIntensity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelAmbientOcclusionIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelAmbientOcclusionIntensity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelAmbientOcclusionIntensity is null")
+          }
+      }
+    }
+
+
+    fun setModelAmbientOcclusionIntensityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelAmbientOcclusionIntensityTransition(transition);
+      }
+    }
+
+    fun setModelEmissiveStrength(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setModelEmissiveStrengthTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setModelRoughness(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelRoughness(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelRoughness is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelRoughness(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelRoughness is null")
+          }
+      }
+    }
+
+
+    fun setModelRoughnessTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelRoughnessTransition(transition);
+      }
+    }
+
+    fun setModelHeightBasedEmissiveStrengthMultiplier(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelHeightBasedEmissiveStrengthMultiplier(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelHeightBasedEmissiveStrengthMultiplier is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelHeightBasedEmissiveStrengthMultiplier(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelHeightBasedEmissiveStrengthMultiplier is null")
+          }
+      }
+    }
+
+
+    fun setModelHeightBasedEmissiveStrengthMultiplierTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelHeightBasedEmissiveStrengthMultiplierTransition(transition);
+      }
+    }
+
+    fun setModelCutoffFadeRange(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelCutoffFadeRange(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelCutoffFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelCutoffFadeRange(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelCutoffFadeRange is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setBackgroundColor(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundColor(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundColor(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundColor is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundColorTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundColorTransition(transition);
+      }
+    }
+
+    fun setBackgroundPattern(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.backgroundPattern(value)
+          } else {
+            Logger.e("RNMBXBackground", "Image for backgroundPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.backgroundPattern(expression)
+          } else {
+            Logger.e("RNMBXBackground", "Expression for backgroundPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.backgroundPattern(value);
+        } else {
+          Logger.e("RNMBXBackground", "value for backgroundPattern is null")
+        }
+      }
+    }
+
+    fun setBackgroundOpacity(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundOpacity(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundOpacity(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundOpacity is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundOpacityTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundOpacityTransition(transition);
+      }
+    }
+
+    fun setBackgroundPitchAlignment(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundPitchAlignment is null")
+        }
+      } else {
+          layer.backgroundPitchAlignment(BackgroundPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setBackgroundEmissiveStrength(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundEmissiveStrengthTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setSkyType(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyType(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyType is null")
+        }
+      } else {
+          layer.skyType(SkyType.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSkyAtmosphereSun(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereSun(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereSun is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereSun(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereSun is null")
+          }
+      }
+    }
+
+    fun setSkyAtmosphereSunIntensity(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereSunIntensity(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereSunIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereSunIntensity(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereSunIntensity is null")
+          }
+      }
+    }
+
+    fun setSkyGradientCenter(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradientCenter(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradientCenter is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.skyGradientCenter(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyGradientCenter is null")
+          }
+      }
+    }
+
+    fun setSkyGradientRadius(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradientRadius(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradientRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyGradientRadius(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyGradientRadius is null")
+          }
+      }
+    }
+
+    fun setSkyGradient(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradient(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradient is null")
+        }
+      } else {
+          layer.skyGradient(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setSkyAtmosphereHaloColor(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereHaloColor(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereHaloColor is null")
+          }
+      }
+    }
+
+    fun setSkyAtmosphereColor(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereColor(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereColor(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereColor is null")
+          }
+      }
+    }
+
+    fun setSkyOpacity(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyOpacity(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyOpacity(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyOpacity is null")
+          }
+      }
+    }
+
+
+    fun setSkyOpacityTransition(layer: SkyLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.skyOpacityTransition(transition);
+      }
+    }
+
+    fun setAnchor(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.anchor(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for anchor is null")
+        }
+      } else {
+          layer.anchor(Anchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setPosition(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.position(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for position is null")
+        }
+      } else {
+          layer.position(styleValue.getLightPosition())
+      }
+    }
+
+
+    fun setPositionTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.positionTransition(transition);
+      }
+    }
+
+    fun setColor(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.color(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for color is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.color(value)
+          } else {
+            Logger.e("RNMBXLight", "value for color is null")
+          }
+      }
+    }
+
+
+    fun setColorTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.colorTransition(transition);
+      }
+    }
+
+    fun setIntensity(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.intensity(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for intensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.intensity(value)
+          } else {
+            Logger.e("RNMBXLight", "value for intensity is null")
+          }
+      }
+    }
+
+
+    fun setIntensityTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.intensityTransition(transition);
+      }
+    }
+
+    fun setRange(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.range(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for range is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.range(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for range is null")
+          }
+      }
+    }
+
+
+    fun setRangeTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rangeTransition(transition);
+      }
+    }
+
+    fun setColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.color(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for color is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.color(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for color is null")
+          }
+      }
+    }
+
+
+    fun setColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.colorTransition(transition);
+      }
+    }
+
+    fun setHighColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.highColor(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for highColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.highColor(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for highColor is null")
+          }
+      }
+    }
+
+
+    fun setHighColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.highColorTransition(transition);
+      }
+    }
+
+    fun setSpaceColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.spaceColor(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for spaceColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.spaceColor(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for spaceColor is null")
+          }
+      }
+    }
+
+
+    fun setSpaceColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.spaceColorTransition(transition);
+      }
+    }
+
+    fun setHorizonBlend(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.horizonBlend(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for horizonBlend is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.horizonBlend(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for horizonBlend is null")
+          }
+      }
+    }
+
+
+    fun setHorizonBlendTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.horizonBlendTransition(transition);
+      }
+    }
+
+    fun setStarIntensity(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.starIntensity(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for starIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.starIntensity(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for starIntensity is null")
+          }
+      }
+    }
+
+
+    fun setStarIntensityTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.starIntensityTransition(transition);
+      }
+    }
+
+    fun setVerticalRange(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.verticalRange(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for verticalRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.verticalRange(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for verticalRange is null")
+          }
+      }
+    }
+
+
+    fun setVerticalRangeTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.verticalRangeTransition(transition);
+      }
+    }
+
+    fun setExaggeration(layer: Terrain, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.exaggeration(expression)
+        } else {
+          Logger.e("RNMBXTerrain", "Expression for exaggeration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.exaggeration(value)
+          } else {
+            Logger.e("RNMBXTerrain", "value for exaggeration is null")
+          }
+      }
+    }
+
+}
diff --git a/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.bak2 b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.bak2
new file mode 100644
index 0000000..a8456b6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.bak2
@@ -0,0 +1,5597 @@
+// DO NOT MODIFY
+// THIS FILE IS AUTOGENERATED
+package com.rnmapbox.rnmbx.components.styles
+
+import com.mapbox.maps.MapboxStyleException
+import com.mapbox.maps.extension.style.expressions.generated.Expression
+import com.mapbox.maps.extension.style.layers.generated.BackgroundLayer
+import com.mapbox.maps.extension.style.layers.generated.CircleLayer
+import com.mapbox.maps.extension.style.layers.generated.FillExtrusionLayer
+import com.mapbox.maps.extension.style.layers.generated.FillLayer
+import com.mapbox.maps.extension.style.layers.generated.LineLayer
+import com.mapbox.maps.extension.style.layers.generated.SkyLayer
+// import com.mapbox.maps.extension.style.layers.generated.PropertyFactory
+// import com.mapbox.maps.extension.style.layers.generated.PropertyValue
+import com.mapbox.maps.extension.style.layers.generated.RasterLayer
+import com.mapbox.maps.extension.style.layers.generated.RasterParticleLayer
+import com.mapbox.maps.extension.style.layers.generated.SymbolLayer
+import com.mapbox.maps.extension.style.layers.generated.HeatmapLayer
+import com.mapbox.maps.extension.style.layers.generated.HillshadeLayer
+import com.mapbox.maps.extension.style.atmosphere.generated.Atmosphere
+import com.mapbox.maps.extension.style.terrain.generated.Terrain
+import com.mapbox.maps.extension.style.layers.generated.ModelLayer
+// import com.mapbox.maps.extension.style.layers.properties.generated.Visibility
+import com.mapbox.maps.extension.style.layers.properties.generated.*
+import com.mapbox.maps.extension.style.types.StyleTransition
+
+import com.mapbox.maps.extension.style.light.LightPosition
+import com.rnmapbox.rnmbx.utils.DownloadMapImageTask.OnAllImagesLoaded
+import com.rnmapbox.rnmbx.utils.Logger
+
+import com.rnmapbox.rnmbx.v11compat.light.*;
+import com.rnmapbox.rnmbx.v11compat.stylefactory.*;
+
+import java.util.List;
+
+const val LOG_TAG = "RNMBXStyleFactory"
+
+object RNMBXStyleFactory {
+    const val VALUE_KEY = "value";
+    const val SHOULD_ADD_IMAGE_KEY = "shouldAddImage";
+
+    fun setFillLayerStyle(layer: FillLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "fillSortKey" ->
+                setFillSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "fillAntialias" ->
+                setFillAntialias(layer, styleValue)
+              "fillOpacity" ->
+                setFillOpacity(layer, styleValue)
+                "fillOpacityTransition" ->
+                setFillOpacityTransition(layer, styleValue)
+              "fillColor" ->
+                setFillColor(layer, styleValue)
+                "fillColorTransition" ->
+                setFillColorTransition(layer, styleValue)
+              "fillOutlineColor" ->
+                setFillOutlineColor(layer, styleValue)
+                "fillOutlineColorTransition" ->
+                setFillOutlineColorTransition(layer, styleValue)
+              "fillTranslate" ->
+                setFillTranslate(layer, styleValue)
+                "fillTranslateTransition" ->
+                setFillTranslateTransition(layer, styleValue)
+              "fillTranslateAnchor" ->
+                setFillTranslateAnchor(layer, styleValue)
+              "fillPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "fillPatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillPatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "fillEmissiveStrength" ->
+                setFillEmissiveStrength(layer, styleValue)
+                "fillEmissiveStrengthTransition" ->
+                setFillEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setLineLayerStyle(layer: LineLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "lineCap" ->
+                setLineCap(layer, styleValue)
+              "lineJoin" ->
+                setLineJoin(layer, styleValue)
+              "lineMiterLimit" ->
+                setLineMiterLimit(layer, styleValue)
+              "lineRoundLimit" ->
+                setLineRoundLimit(layer, styleValue)
+              "lineSortKey" ->
+                setLineSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "lineOpacity" ->
+                setLineOpacity(layer, styleValue)
+                "lineOpacityTransition" ->
+                setLineOpacityTransition(layer, styleValue)
+              "lineColor" ->
+                setLineColor(layer, styleValue)
+                "lineColorTransition" ->
+                setLineColorTransition(layer, styleValue)
+              "lineTranslate" ->
+                setLineTranslate(layer, styleValue)
+                "lineTranslateTransition" ->
+                setLineTranslateTransition(layer, styleValue)
+              "lineTranslateAnchor" ->
+                setLineTranslateAnchor(layer, styleValue)
+              "lineWidth" ->
+                setLineWidth(layer, styleValue)
+                "lineWidthTransition" ->
+                setLineWidthTransition(layer, styleValue)
+              "lineGapWidth" ->
+                setLineGapWidth(layer, styleValue)
+                "lineGapWidthTransition" ->
+                setLineGapWidthTransition(layer, styleValue)
+              "lineOffset" ->
+                setLineOffset(layer, styleValue)
+                "lineOffsetTransition" ->
+                setLineOffsetTransition(layer, styleValue)
+              "lineBlur" ->
+                setLineBlur(layer, styleValue)
+                "lineBlurTransition" ->
+                setLineBlurTransition(layer, styleValue)
+              "lineDasharray" ->
+                setLineDasharray(layer, styleValue)
+              "linePattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setLinePattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePattern: %s", exception.message))
+                        }
+                    }
+                })
+              "lineGradient" ->
+                setLineGradient(layer, styleValue)
+              "lineTrimOffset" ->
+                setLineTrimOffset(layer, styleValue)
+              "lineZOffset" ->
+                setLineZOffset(layer, styleValue)
+              "lineElevationReference" ->
+                setLineElevationReference(layer, styleValue)
+              "lineCrossSlope" ->
+                setLineCrossSlope(layer, styleValue)
+              "linePatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setLinePatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "lineTrimFadeRange" ->
+                setLineTrimFadeRange(layer, styleValue)
+              "lineTrimColor" ->
+                setLineTrimColor(layer, styleValue)
+                "lineTrimColorTransition" ->
+                setLineTrimColorTransition(layer, styleValue)
+              "lineEmissiveStrength" ->
+                setLineEmissiveStrength(layer, styleValue)
+                "lineEmissiveStrengthTransition" ->
+                setLineEmissiveStrengthTransition(layer, styleValue)
+              "lineOcclusionOpacity" ->
+                setLineOcclusionOpacity(layer, styleValue)
+                "lineOcclusionOpacityTransition" ->
+                setLineOcclusionOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setSymbolLayerStyle(layer: SymbolLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "symbolPlacement" ->
+                setSymbolPlacement(layer, styleValue)
+              "symbolSpacing" ->
+                setSymbolSpacing(layer, styleValue)
+              "symbolAvoidEdges" ->
+                setSymbolAvoidEdges(layer, styleValue)
+              "symbolSortKey" ->
+                setSymbolSortKey(layer, styleValue)
+              "symbolZOrder" ->
+                setSymbolZOrder(layer, styleValue)
+              "iconAllowOverlap" ->
+                setIconAllowOverlap(layer, styleValue)
+              "iconIgnorePlacement" ->
+                setIconIgnorePlacement(layer, styleValue)
+              "iconOptional" ->
+                setIconOptional(layer, styleValue)
+              "iconRotationAlignment" ->
+                setIconRotationAlignment(layer, styleValue)
+              "iconSize" ->
+                setIconSize(layer, styleValue)
+              "iconTextFit" ->
+                setIconTextFit(layer, styleValue)
+              "iconTextFitPadding" ->
+                setIconTextFitPadding(layer, styleValue)
+              "iconImage" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setIconImage(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXSymbol",String.format("Exception failed during setIconImage: %s", exception.message))
+                        }
+                    }
+                })
+              "iconRotate" ->
+                setIconRotate(layer, styleValue)
+              "iconPadding" ->
+                setIconPadding(layer, styleValue)
+              "iconKeepUpright" ->
+                setIconKeepUpright(layer, styleValue)
+              "iconOffset" ->
+                setIconOffset(layer, styleValue)
+              "iconAnchor" ->
+                setIconAnchor(layer, styleValue)
+              "iconPitchAlignment" ->
+                setIconPitchAlignment(layer, styleValue)
+              "textPitchAlignment" ->
+                setTextPitchAlignment(layer, styleValue)
+              "textRotationAlignment" ->
+                setTextRotationAlignment(layer, styleValue)
+              "textField" ->
+                setTextField(layer, styleValue)
+              "textFont" ->
+                setTextFont(layer, styleValue)
+              "textSize" ->
+                setTextSize(layer, styleValue)
+              "textMaxWidth" ->
+                setTextMaxWidth(layer, styleValue)
+              "textLineHeight" ->
+                setTextLineHeight(layer, styleValue)
+              "textLetterSpacing" ->
+                setTextLetterSpacing(layer, styleValue)
+              "textJustify" ->
+                setTextJustify(layer, styleValue)
+              "textRadialOffset" ->
+                setTextRadialOffset(layer, styleValue)
+              "textVariableAnchor" ->
+                setTextVariableAnchor(layer, styleValue)
+              "textAnchor" ->
+                setTextAnchor(layer, styleValue)
+              "textMaxAngle" ->
+                setTextMaxAngle(layer, styleValue)
+              "textWritingMode" ->
+                setTextWritingMode(layer, styleValue)
+              "textRotate" ->
+                setTextRotate(layer, styleValue)
+              "textPadding" ->
+                setTextPadding(layer, styleValue)
+              "textKeepUpright" ->
+                setTextKeepUpright(layer, styleValue)
+              "textTransform" ->
+                setTextTransform(layer, styleValue)
+              "textOffset" ->
+                setTextOffset(layer, styleValue)
+              "textAllowOverlap" ->
+                setTextAllowOverlap(layer, styleValue)
+              "textIgnorePlacement" ->
+                setTextIgnorePlacement(layer, styleValue)
+              "textOptional" ->
+                setTextOptional(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "iconOpacity" ->
+                setIconOpacity(layer, styleValue)
+                "iconOpacityTransition" ->
+                setIconOpacityTransition(layer, styleValue)
+              "iconColor" ->
+                setIconColor(layer, styleValue)
+                "iconColorTransition" ->
+                setIconColorTransition(layer, styleValue)
+              "iconHaloColor" ->
+                setIconHaloColor(layer, styleValue)
+                "iconHaloColorTransition" ->
+                setIconHaloColorTransition(layer, styleValue)
+              "iconHaloWidth" ->
+                setIconHaloWidth(layer, styleValue)
+                "iconHaloWidthTransition" ->
+                setIconHaloWidthTransition(layer, styleValue)
+              "iconHaloBlur" ->
+                setIconHaloBlur(layer, styleValue)
+                "iconHaloBlurTransition" ->
+                setIconHaloBlurTransition(layer, styleValue)
+              "iconTranslate" ->
+                setIconTranslate(layer, styleValue)
+                "iconTranslateTransition" ->
+                setIconTranslateTransition(layer, styleValue)
+              "iconTranslateAnchor" ->
+                setIconTranslateAnchor(layer, styleValue)
+              "textOpacity" ->
+                setTextOpacity(layer, styleValue)
+                "textOpacityTransition" ->
+                setTextOpacityTransition(layer, styleValue)
+              "textColor" ->
+                setTextColor(layer, styleValue)
+                "textColorTransition" ->
+                setTextColorTransition(layer, styleValue)
+              "textHaloColor" ->
+                setTextHaloColor(layer, styleValue)
+                "textHaloColorTransition" ->
+                setTextHaloColorTransition(layer, styleValue)
+              "textHaloWidth" ->
+                setTextHaloWidth(layer, styleValue)
+                "textHaloWidthTransition" ->
+                setTextHaloWidthTransition(layer, styleValue)
+              "textHaloBlur" ->
+                setTextHaloBlur(layer, styleValue)
+                "textHaloBlurTransition" ->
+                setTextHaloBlurTransition(layer, styleValue)
+              "textTranslate" ->
+                setTextTranslate(layer, styleValue)
+                "textTranslateTransition" ->
+                setTextTranslateTransition(layer, styleValue)
+              "textTranslateAnchor" ->
+                setTextTranslateAnchor(layer, styleValue)
+              "symbolZElevate" ->
+                setSymbolZElevate(layer, styleValue)
+              "symbolElevationReference" ->
+                setSymbolElevationReference(layer, styleValue)
+              "iconOcclusionOpacity" ->
+                setIconOcclusionOpacity(layer, styleValue)
+                "iconOcclusionOpacityTransition" ->
+                setIconOcclusionOpacityTransition(layer, styleValue)
+              "iconEmissiveStrength" ->
+                setIconEmissiveStrength(layer, styleValue)
+                "iconEmissiveStrengthTransition" ->
+                setIconEmissiveStrengthTransition(layer, styleValue)
+              "textEmissiveStrength" ->
+                setTextEmissiveStrength(layer, styleValue)
+                "textEmissiveStrengthTransition" ->
+                setTextEmissiveStrengthTransition(layer, styleValue)
+              "iconImageCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setIconImageCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXSymbol",String.format("Exception failed during setIconImageCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "textOcclusionOpacity" ->
+                setTextOcclusionOpacity(layer, styleValue)
+                "textOcclusionOpacityTransition" ->
+                setTextOcclusionOpacityTransition(layer, styleValue)
+              "iconColorSaturation" ->
+                setIconColorSaturation(layer, styleValue)
+              "symbolZOffset" ->
+                setSymbolZOffset(layer, styleValue)
+                "symbolZOffsetTransition" ->
+                setSymbolZOffsetTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setCircleLayerStyle(layer: CircleLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "circleSortKey" ->
+                setCircleSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "circleRadius" ->
+                setCircleRadius(layer, styleValue)
+                "circleRadiusTransition" ->
+                setCircleRadiusTransition(layer, styleValue)
+              "circleColor" ->
+                setCircleColor(layer, styleValue)
+                "circleColorTransition" ->
+                setCircleColorTransition(layer, styleValue)
+              "circleBlur" ->
+                setCircleBlur(layer, styleValue)
+                "circleBlurTransition" ->
+                setCircleBlurTransition(layer, styleValue)
+              "circleOpacity" ->
+                setCircleOpacity(layer, styleValue)
+                "circleOpacityTransition" ->
+                setCircleOpacityTransition(layer, styleValue)
+              "circleTranslate" ->
+                setCircleTranslate(layer, styleValue)
+                "circleTranslateTransition" ->
+                setCircleTranslateTransition(layer, styleValue)
+              "circleTranslateAnchor" ->
+                setCircleTranslateAnchor(layer, styleValue)
+              "circlePitchScale" ->
+                setCirclePitchScale(layer, styleValue)
+              "circlePitchAlignment" ->
+                setCirclePitchAlignment(layer, styleValue)
+              "circleStrokeWidth" ->
+                setCircleStrokeWidth(layer, styleValue)
+                "circleStrokeWidthTransition" ->
+                setCircleStrokeWidthTransition(layer, styleValue)
+              "circleStrokeColor" ->
+                setCircleStrokeColor(layer, styleValue)
+                "circleStrokeColorTransition" ->
+                setCircleStrokeColorTransition(layer, styleValue)
+              "circleStrokeOpacity" ->
+                setCircleStrokeOpacity(layer, styleValue)
+                "circleStrokeOpacityTransition" ->
+                setCircleStrokeOpacityTransition(layer, styleValue)
+              "circleElevationReference" ->
+                setCircleElevationReference(layer, styleValue)
+              "circleEmissiveStrength" ->
+                setCircleEmissiveStrength(layer, styleValue)
+                "circleEmissiveStrengthTransition" ->
+                setCircleEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setHeatmapLayerStyle(layer: HeatmapLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "heatmapRadius" ->
+                setHeatmapRadius(layer, styleValue)
+                "heatmapRadiusTransition" ->
+                setHeatmapRadiusTransition(layer, styleValue)
+              "heatmapWeight" ->
+                setHeatmapWeight(layer, styleValue)
+              "heatmapIntensity" ->
+                setHeatmapIntensity(layer, styleValue)
+                "heatmapIntensityTransition" ->
+                setHeatmapIntensityTransition(layer, styleValue)
+              "heatmapColor" ->
+                setHeatmapColor(layer, styleValue)
+              "heatmapOpacity" ->
+                setHeatmapOpacity(layer, styleValue)
+                "heatmapOpacityTransition" ->
+                setHeatmapOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setFillExtrusionLayerStyle(layer: FillExtrusionLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "fillExtrusionEdgeRadius" ->
+                setFillExtrusionEdgeRadius(layer, styleValue)
+              "fillExtrusionOpacity" ->
+                setFillExtrusionOpacity(layer, styleValue)
+                "fillExtrusionOpacityTransition" ->
+                setFillExtrusionOpacityTransition(layer, styleValue)
+              "fillExtrusionColor" ->
+                setFillExtrusionColor(layer, styleValue)
+                "fillExtrusionColorTransition" ->
+                setFillExtrusionColorTransition(layer, styleValue)
+              "fillExtrusionTranslate" ->
+                setFillExtrusionTranslate(layer, styleValue)
+                "fillExtrusionTranslateTransition" ->
+                setFillExtrusionTranslateTransition(layer, styleValue)
+              "fillExtrusionTranslateAnchor" ->
+                setFillExtrusionTranslateAnchor(layer, styleValue)
+              "fillExtrusionPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillExtrusionPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "fillExtrusionHeight" ->
+                setFillExtrusionHeight(layer, styleValue)
+                "fillExtrusionHeightTransition" ->
+                setFillExtrusionHeightTransition(layer, styleValue)
+              "fillExtrusionBase" ->
+                setFillExtrusionBase(layer, styleValue)
+                "fillExtrusionBaseTransition" ->
+                setFillExtrusionBaseTransition(layer, styleValue)
+              "fillExtrusionVerticalGradient" ->
+                setFillExtrusionVerticalGradient(layer, styleValue)
+              "fillExtrusionAmbientOcclusionIntensity" ->
+                setFillExtrusionAmbientOcclusionIntensity(layer, styleValue)
+                "fillExtrusionAmbientOcclusionIntensityTransition" ->
+                setFillExtrusionAmbientOcclusionIntensityTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionRadius" ->
+                setFillExtrusionAmbientOcclusionRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionRadiusTransition(layer, styleValue)
+              "fillExtrusionRoundedRoof" ->
+                setFillExtrusionRoundedRoof(layer, styleValue)
+              "fillExtrusionPatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillExtrusionPatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "fillExtrusionHeightAlignment" ->
+                setFillExtrusionHeightAlignment(layer, styleValue)
+              "fillExtrusionBaseAlignment" ->
+                setFillExtrusionBaseAlignment(layer, styleValue)
+              "fillExtrusionAmbientOcclusionWallRadius" ->
+                setFillExtrusionAmbientOcclusionWallRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionWallRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionWallRadiusTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionGroundRadius" ->
+                setFillExtrusionAmbientOcclusionGroundRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionGroundRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionGroundRadiusTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionGroundAttenuation" ->
+                setFillExtrusionAmbientOcclusionGroundAttenuation(layer, styleValue)
+                "fillExtrusionAmbientOcclusionGroundAttenuationTransition" ->
+                setFillExtrusionAmbientOcclusionGroundAttenuationTransition(layer, styleValue)
+              "fillExtrusionFloodLightColor" ->
+                setFillExtrusionFloodLightColor(layer, styleValue)
+                "fillExtrusionFloodLightColorTransition" ->
+                setFillExtrusionFloodLightColorTransition(layer, styleValue)
+              "fillExtrusionFloodLightIntensity" ->
+                setFillExtrusionFloodLightIntensity(layer, styleValue)
+                "fillExtrusionFloodLightIntensityTransition" ->
+                setFillExtrusionFloodLightIntensityTransition(layer, styleValue)
+              "fillExtrusionFloodLightWallRadius" ->
+                setFillExtrusionFloodLightWallRadius(layer, styleValue)
+                "fillExtrusionFloodLightWallRadiusTransition" ->
+                setFillExtrusionFloodLightWallRadiusTransition(layer, styleValue)
+              "fillExtrusionFloodLightGroundRadius" ->
+                setFillExtrusionFloodLightGroundRadius(layer, styleValue)
+                "fillExtrusionFloodLightGroundRadiusTransition" ->
+                setFillExtrusionFloodLightGroundRadiusTransition(layer, styleValue)
+              "fillExtrusionFloodLightGroundAttenuation" ->
+                setFillExtrusionFloodLightGroundAttenuation(layer, styleValue)
+                "fillExtrusionFloodLightGroundAttenuationTransition" ->
+                setFillExtrusionFloodLightGroundAttenuationTransition(layer, styleValue)
+              "fillExtrusionVerticalScale" ->
+                setFillExtrusionVerticalScale(layer, styleValue)
+                "fillExtrusionVerticalScaleTransition" ->
+                setFillExtrusionVerticalScaleTransition(layer, styleValue)
+              "fillExtrusionCutoffFadeRange" ->
+                setFillExtrusionCutoffFadeRange(layer, styleValue)
+              "fillExtrusionEmissiveStrength" ->
+                setFillExtrusionEmissiveStrength(layer, styleValue)
+                "fillExtrusionEmissiveStrengthTransition" ->
+                setFillExtrusionEmissiveStrengthTransition(layer, styleValue)
+              "fillExtrusionLineWidth" ->
+                setFillExtrusionLineWidth(layer, styleValue)
+                "fillExtrusionLineWidthTransition" ->
+                setFillExtrusionLineWidthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setRasterLayerStyle(layer: RasterLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "rasterOpacity" ->
+                setRasterOpacity(layer, styleValue)
+                "rasterOpacityTransition" ->
+                setRasterOpacityTransition(layer, styleValue)
+              "rasterHueRotate" ->
+                setRasterHueRotate(layer, styleValue)
+                "rasterHueRotateTransition" ->
+                setRasterHueRotateTransition(layer, styleValue)
+              "rasterBrightnessMin" ->
+                setRasterBrightnessMin(layer, styleValue)
+                "rasterBrightnessMinTransition" ->
+                setRasterBrightnessMinTransition(layer, styleValue)
+              "rasterBrightnessMax" ->
+                setRasterBrightnessMax(layer, styleValue)
+                "rasterBrightnessMaxTransition" ->
+                setRasterBrightnessMaxTransition(layer, styleValue)
+              "rasterSaturation" ->
+                setRasterSaturation(layer, styleValue)
+                "rasterSaturationTransition" ->
+                setRasterSaturationTransition(layer, styleValue)
+              "rasterContrast" ->
+                setRasterContrast(layer, styleValue)
+                "rasterContrastTransition" ->
+                setRasterContrastTransition(layer, styleValue)
+              "rasterResampling" ->
+                setRasterResampling(layer, styleValue)
+              "rasterFadeDuration" ->
+                setRasterFadeDuration(layer, styleValue)
+              "rasterColor" ->
+                setRasterColor(layer, styleValue)
+              "rasterColorMix" ->
+                setRasterColorMix(layer, styleValue)
+                "rasterColorMixTransition" ->
+                setRasterColorMixTransition(layer, styleValue)
+              "rasterColorRange" ->
+                setRasterColorRange(layer, styleValue)
+                "rasterColorRangeTransition" ->
+                setRasterColorRangeTransition(layer, styleValue)
+              "rasterEmissiveStrength" ->
+                setRasterEmissiveStrength(layer, styleValue)
+                "rasterEmissiveStrengthTransition" ->
+                setRasterEmissiveStrengthTransition(layer, styleValue)
+              "rasterArrayBand" ->
+                setRasterArrayBand(layer, styleValue)
+              "rasterElevation" ->
+                setRasterElevation(layer, styleValue)
+                "rasterElevationTransition" ->
+                setRasterElevationTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setRasterParticleLayerStyle(layer: RasterParticleLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "rasterParticleArrayBand" ->
+                setRasterParticleArrayBand(layer, styleValue)
+              "rasterParticleCount" ->
+                setRasterParticleCount(layer, styleValue)
+              "rasterParticleColor" ->
+                setRasterParticleColor(layer, styleValue)
+              "rasterParticleMaxSpeed" ->
+                setRasterParticleMaxSpeed(layer, styleValue)
+              "rasterParticleSpeedFactor" ->
+                setRasterParticleSpeedFactor(layer, styleValue)
+                "rasterParticleSpeedFactorTransition" ->
+                setRasterParticleSpeedFactorTransition(layer, styleValue)
+              "rasterParticleFadeOpacityFactor" ->
+                setRasterParticleFadeOpacityFactor(layer, styleValue)
+                "rasterParticleFadeOpacityFactorTransition" ->
+                setRasterParticleFadeOpacityFactorTransition(layer, styleValue)
+              "rasterParticleResetRateFactor" ->
+                setRasterParticleResetRateFactor(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setHillshadeLayerStyle(layer: HillshadeLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "hillshadeIlluminationDirection" ->
+                setHillshadeIlluminationDirection(layer, styleValue)
+              "hillshadeIlluminationAnchor" ->
+                setHillshadeIlluminationAnchor(layer, styleValue)
+              "hillshadeExaggeration" ->
+                setHillshadeExaggeration(layer, styleValue)
+                "hillshadeExaggerationTransition" ->
+                setHillshadeExaggerationTransition(layer, styleValue)
+              "hillshadeShadowColor" ->
+                setHillshadeShadowColor(layer, styleValue)
+                "hillshadeShadowColorTransition" ->
+                setHillshadeShadowColorTransition(layer, styleValue)
+              "hillshadeHighlightColor" ->
+                setHillshadeHighlightColor(layer, styleValue)
+                "hillshadeHighlightColorTransition" ->
+                setHillshadeHighlightColorTransition(layer, styleValue)
+              "hillshadeAccentColor" ->
+                setHillshadeAccentColor(layer, styleValue)
+                "hillshadeAccentColorTransition" ->
+                setHillshadeAccentColorTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setModelLayerStyle(layer: ModelLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "modelId" ->
+                setModelId(layer, styleValue)
+              "modelOpacity" ->
+                setModelOpacity(layer, styleValue)
+                "modelOpacityTransition" ->
+                setModelOpacityTransition(layer, styleValue)
+              "modelRotation" ->
+                setModelRotation(layer, styleValue)
+                "modelRotationTransition" ->
+                setModelRotationTransition(layer, styleValue)
+              "modelScale" ->
+                setModelScale(layer, styleValue)
+                "modelScaleTransition" ->
+                setModelScaleTransition(layer, styleValue)
+              "modelTranslation" ->
+                setModelTranslation(layer, styleValue)
+                "modelTranslationTransition" ->
+                setModelTranslationTransition(layer, styleValue)
+              "modelColor" ->
+                setModelColor(layer, styleValue)
+                "modelColorTransition" ->
+                setModelColorTransition(layer, styleValue)
+              "modelColorMixIntensity" ->
+                setModelColorMixIntensity(layer, styleValue)
+                "modelColorMixIntensityTransition" ->
+                setModelColorMixIntensityTransition(layer, styleValue)
+              "modelType" ->
+                setModelType(layer, styleValue)
+              "modelCastShadows" ->
+                setModelCastShadows(layer, styleValue)
+              "modelReceiveShadows" ->
+                setModelReceiveShadows(layer, styleValue)
+              "modelAmbientOcclusionIntensity" ->
+                setModelAmbientOcclusionIntensity(layer, styleValue)
+                "modelAmbientOcclusionIntensityTransition" ->
+                setModelAmbientOcclusionIntensityTransition(layer, styleValue)
+              "modelEmissiveStrength" ->
+                setModelEmissiveStrength(layer, styleValue)
+                "modelEmissiveStrengthTransition" ->
+                setModelEmissiveStrengthTransition(layer, styleValue)
+              "modelRoughness" ->
+                setModelRoughness(layer, styleValue)
+                "modelRoughnessTransition" ->
+                setModelRoughnessTransition(layer, styleValue)
+              "modelHeightBasedEmissiveStrengthMultiplier" ->
+                setModelHeightBasedEmissiveStrengthMultiplier(layer, styleValue)
+                "modelHeightBasedEmissiveStrengthMultiplierTransition" ->
+                setModelHeightBasedEmissiveStrengthMultiplierTransition(layer, styleValue)
+              "modelCutoffFadeRange" ->
+                setModelCutoffFadeRange(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setBackgroundLayerStyle(layer: BackgroundLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "backgroundColor" ->
+                setBackgroundColor(layer, styleValue)
+                "backgroundColorTransition" ->
+                setBackgroundColorTransition(layer, styleValue)
+              "backgroundPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setBackgroundPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXBackground",String.format("Exception failed during setBackgroundPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "backgroundOpacity" ->
+                setBackgroundOpacity(layer, styleValue)
+                "backgroundOpacityTransition" ->
+                setBackgroundOpacityTransition(layer, styleValue)
+              "backgroundPitchAlignment" ->
+                setBackgroundPitchAlignment(layer, styleValue)
+              "backgroundEmissiveStrength" ->
+                setBackgroundEmissiveStrength(layer, styleValue)
+                "backgroundEmissiveStrengthTransition" ->
+                setBackgroundEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setSkyLayerStyle(layer: SkyLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "skyType" ->
+                setSkyType(layer, styleValue)
+              "skyAtmosphereSun" ->
+                setSkyAtmosphereSun(layer, styleValue)
+              "skyAtmosphereSunIntensity" ->
+                setSkyAtmosphereSunIntensity(layer, styleValue)
+              "skyGradientCenter" ->
+                setSkyGradientCenter(layer, styleValue)
+              "skyGradientRadius" ->
+                setSkyGradientRadius(layer, styleValue)
+              "skyGradient" ->
+                setSkyGradient(layer, styleValue)
+              "skyAtmosphereHaloColor" ->
+                setSkyAtmosphereHaloColor(layer, styleValue)
+              "skyAtmosphereColor" ->
+                setSkyAtmosphereColor(layer, styleValue)
+              "skyOpacity" ->
+                setSkyOpacity(layer, styleValue)
+                "skyOpacityTransition" ->
+                setSkyOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setLightLayerStyle(layer: Light, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "anchor" ->
+                setAnchor(layer, styleValue)
+              "position" ->
+                setPosition(layer, styleValue)
+                "positionTransition" ->
+                setPositionTransition(layer, styleValue)
+              "color" ->
+                setColor(layer, styleValue)
+                "colorTransition" ->
+                setColorTransition(layer, styleValue)
+              "intensity" ->
+                setIntensity(layer, styleValue)
+                "intensityTransition" ->
+                setIntensityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setAtmosphereLayerStyle(layer: Atmosphere, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "range" ->
+                setRange(layer, styleValue)
+                "rangeTransition" ->
+                setRangeTransition(layer, styleValue)
+              "color" ->
+                setColor(layer, styleValue)
+                "colorTransition" ->
+                setColorTransition(layer, styleValue)
+              "highColor" ->
+                setHighColor(layer, styleValue)
+                "highColorTransition" ->
+                setHighColorTransition(layer, styleValue)
+              "spaceColor" ->
+                setSpaceColor(layer, styleValue)
+                "spaceColorTransition" ->
+                setSpaceColorTransition(layer, styleValue)
+              "horizonBlend" ->
+                setHorizonBlend(layer, styleValue)
+                "horizonBlendTransition" ->
+                setHorizonBlendTransition(layer, styleValue)
+              "starIntensity" ->
+                setStarIntensity(layer, styleValue)
+                "starIntensityTransition" ->
+                setStarIntensityTransition(layer, styleValue)
+              "verticalRange" ->
+                setVerticalRange(layer, styleValue)
+                "verticalRangeTransition" ->
+                setVerticalRangeTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setTerrainLayerStyle(layer: Terrain, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "exaggeration" ->
+                setExaggeration(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+
+    fun setFillSortKey(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillSortKey(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillSortKey(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setFillAntialias(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillAntialias(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillAntialias is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillAntialias(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillAntialias is null")
+          }
+      }
+    }
+
+    fun setFillOpacity(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillOpacity(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillOpacity(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillOpacity is null")
+          }
+      }
+    }
+
+
+    fun setFillOpacityTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillOpacityTransition(transition);
+      }
+    }
+
+    fun setFillColor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillColor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillColor(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillColor is null")
+          }
+      }
+    }
+
+
+    fun setFillColorTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillColorTransition(transition);
+      }
+    }
+
+    fun setFillOutlineColor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillOutlineColor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillOutlineColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillOutlineColor(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillOutlineColor is null")
+          }
+      }
+    }
+
+
+    fun setFillOutlineColorTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillOutlineColorTransition(transition);
+      }
+    }
+
+    fun setFillTranslate(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillTranslate(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.fillTranslate(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillTranslate is null")
+          }
+      }
+    }
+
+
+    fun setFillTranslateTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillTranslateTransition(transition);
+      }
+    }
+
+    fun setFillTranslateAnchor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillTranslateAnchor is null")
+        }
+      } else {
+          layer.fillTranslateAnchor(FillTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillPattern(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.fillPattern(value)
+          } else {
+            Logger.e("RNMBXFill", "Image for fillPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.fillPattern(expression)
+          } else {
+            Logger.e("RNMBXFill", "Expression for fillPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.fillPattern(value);
+        } else {
+          Logger.e("RNMBXFill", "value for fillPattern is null")
+        }
+      }
+    }
+
+    fun setFillPatternCrossFade(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillPatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillPatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillPatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillPatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setFillEmissiveStrength(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setFillEmissiveStrengthTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setLineCap(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineCap(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineCap is null")
+        }
+      } else {
+          layer.lineCap(LineCap.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineJoin(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineJoin(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineJoin is null")
+        }
+      } else {
+          layer.lineJoin(LineJoin.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineMiterLimit(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineMiterLimit(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineMiterLimit is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineMiterLimit(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineMiterLimit is null")
+          }
+      }
+    }
+
+    fun setLineRoundLimit(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineRoundLimit(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineRoundLimit is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineRoundLimit(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineRoundLimit is null")
+          }
+      }
+    }
+
+    fun setLineSortKey(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineSortKey(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineSortKey(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setLineOpacity(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOpacity(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOpacity(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOpacity is null")
+          }
+      }
+    }
+
+
+    fun setLineOpacityTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOpacityTransition(transition);
+      }
+    }
+
+    fun setLineColor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineColor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.lineColor(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineColor is null")
+          }
+      }
+    }
+
+
+    fun setLineColorTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineColorTransition(transition);
+      }
+    }
+
+    fun setLineTranslate(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTranslate(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTranslate(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTranslate is null")
+          }
+      }
+    }
+
+
+    fun setLineTranslateTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineTranslateTransition(transition);
+      }
+    }
+
+    fun setLineTranslateAnchor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTranslateAnchor is null")
+        }
+      } else {
+          layer.lineTranslateAnchor(LineTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineWidth(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineWidth(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineWidth(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineWidth is null")
+          }
+      }
+    }
+
+
+    fun setLineWidthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineWidthTransition(transition);
+      }
+    }
+
+    fun setLineGapWidth(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineGapWidth(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineGapWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineGapWidth(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineGapWidth is null")
+          }
+      }
+    }
+
+
+    fun setLineGapWidthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineGapWidthTransition(transition);
+      }
+    }
+
+    fun setLineOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOffset is null")
+          }
+      }
+    }
+
+
+    fun setLineOffsetTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOffsetTransition(transition);
+      }
+    }
+
+    fun setLineBlur(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineBlur(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineBlur(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineBlur is null")
+          }
+      }
+    }
+
+
+    fun setLineBlurTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineBlurTransition(transition);
+      }
+    }
+
+    fun setLineDasharray(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineDasharray(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineDasharray is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineDasharray(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineDasharray is null")
+          }
+      }
+    }
+
+    fun setLinePattern(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.linePattern(value)
+          } else {
+            Logger.e("RNMBXLine", "Image for linePattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.linePattern(expression)
+          } else {
+            Logger.e("RNMBXLine", "Expression for linePattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.linePattern(value);
+        } else {
+          Logger.e("RNMBXLine", "value for linePattern is null")
+        }
+      }
+    }
+
+    fun setLineGradient(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineGradient(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineGradient is null")
+        }
+      } else {
+          layer.lineGradient(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setLineTrimOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimOffset is null")
+          }
+      }
+    }
+
+    fun setLineZOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineZOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineZOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineZOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineZOffset is null")
+          }
+      }
+    }
+
+    fun setLineElevationReference(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineElevationReference(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineElevationReference is null")
+        }
+      } else {
+          layer.lineElevationReference(LineElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineCrossSlope(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineCrossSlope(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineCrossSlope is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineCrossSlope(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineCrossSlope is null")
+          }
+      }
+    }
+
+    fun setLinePatternCrossFade(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.linePatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for linePatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.linePatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXLine", "value for linePatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setLineTrimFadeRange(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimFadeRange(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimFadeRange(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimFadeRange is null")
+          }
+      }
+    }
+
+    fun setLineTrimColor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimColor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimColor(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimColor is null")
+          }
+      }
+    }
+
+
+    fun setLineTrimColorTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineTrimColorTransition(transition);
+      }
+    }
+
+    fun setLineEmissiveStrength(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setLineEmissiveStrengthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setLineOcclusionOpacity(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setLineOcclusionOpacityTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setSymbolPlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolPlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolPlacement is null")
+        }
+      } else {
+          layer.symbolPlacement(SymbolPlacement.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSymbolSpacing(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolSpacing(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolSpacing is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolSpacing(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolSpacing is null")
+          }
+      }
+    }
+
+    fun setSymbolAvoidEdges(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolAvoidEdges(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolAvoidEdges is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.symbolAvoidEdges(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolAvoidEdges is null")
+          }
+      }
+    }
+
+    fun setSymbolSortKey(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolSortKey(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolSortKey(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolSortKey is null")
+          }
+      }
+    }
+
+    fun setSymbolZOrder(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZOrder(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZOrder is null")
+        }
+      } else {
+          layer.symbolZOrder(SymbolZOrder.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconAllowOverlap(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconAllowOverlap(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconAllowOverlap is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconAllowOverlap(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconAllowOverlap is null")
+          }
+      }
+    }
+
+    fun setIconIgnorePlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconIgnorePlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconIgnorePlacement is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconIgnorePlacement(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconIgnorePlacement is null")
+          }
+      }
+    }
+
+    fun setIconOptional(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOptional(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOptional is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconOptional(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOptional is null")
+          }
+      }
+    }
+
+    fun setIconRotationAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconRotationAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconRotationAlignment is null")
+        }
+      } else {
+          layer.iconRotationAlignment(IconRotationAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconSize(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconSize(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconSize is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconSize(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconSize is null")
+          }
+      }
+    }
+
+    fun setIconTextFit(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTextFit(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTextFit is null")
+        }
+      } else {
+          layer.iconTextFit(IconTextFit.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconTextFitPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTextFitPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTextFitPadding is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconTextFitPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconTextFitPadding is null")
+          }
+      }
+    }
+
+    fun setIconImage(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.iconImage(value)
+          } else {
+            Logger.e("RNMBXSymbol", "Image for iconImage is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.iconImage(expression)
+          } else {
+            Logger.e("RNMBXSymbol", "Expression for iconImage is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.iconImage(value);
+        } else {
+          Logger.e("RNMBXSymbol", "value for iconImage is null")
+        }
+      }
+    }
+
+    fun setIconRotate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconRotate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconRotate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconRotate is null")
+          }
+      }
+    }
+
+    fun setIconPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconPadding is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconPadding is null")
+          }
+      }
+    }
+
+    fun setIconKeepUpright(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconKeepUpright(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconKeepUpright is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconKeepUpright(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconKeepUpright is null")
+          }
+      }
+    }
+
+    fun setIconOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOffset is null")
+          }
+      }
+    }
+
+    fun setIconAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconAnchor is null")
+        }
+      } else {
+          layer.iconAnchor(IconAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconPitchAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconPitchAlignment is null")
+        }
+      } else {
+          layer.iconPitchAlignment(IconPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextPitchAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textPitchAlignment is null")
+        }
+      } else {
+          layer.textPitchAlignment(TextPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextRotationAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRotationAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRotationAlignment is null")
+        }
+      } else {
+          layer.textRotationAlignment(TextRotationAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextField(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textField(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textField is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.textField(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textField is null")
+          }
+      }
+    }
+
+    fun setTextFont(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textFont(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textFont is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textFont(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textFont is null")
+          }
+      }
+    }
+
+    fun setTextSize(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textSize(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textSize is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textSize(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textSize is null")
+          }
+      }
+    }
+
+    fun setTextMaxWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textMaxWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textMaxWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textMaxWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textMaxWidth is null")
+          }
+      }
+    }
+
+    fun setTextLineHeight(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textLineHeight(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textLineHeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textLineHeight(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textLineHeight is null")
+          }
+      }
+    }
+
+    fun setTextLetterSpacing(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textLetterSpacing(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textLetterSpacing is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textLetterSpacing(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textLetterSpacing is null")
+          }
+      }
+    }
+
+    fun setTextJustify(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textJustify(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textJustify is null")
+        }
+      } else {
+          layer.textJustify(TextJustify.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextRadialOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRadialOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRadialOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textRadialOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textRadialOffset is null")
+          }
+      }
+    }
+
+    fun setTextVariableAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textVariableAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textVariableAnchor is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textVariableAnchor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textVariableAnchor is null")
+          }
+      }
+    }
+
+    fun setTextAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textAnchor is null")
+        }
+      } else {
+          layer.textAnchor(TextAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextMaxAngle(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textMaxAngle(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textMaxAngle is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textMaxAngle(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textMaxAngle is null")
+          }
+      }
+    }
+
+    fun setTextWritingMode(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textWritingMode(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textWritingMode is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textWritingMode(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textWritingMode is null")
+          }
+      }
+    }
+
+    fun setTextRotate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRotate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textRotate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textRotate is null")
+          }
+      }
+    }
+
+    fun setTextPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textPadding is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textPadding is null")
+          }
+      }
+    }
+
+    fun setTextKeepUpright(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textKeepUpright(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textKeepUpright is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textKeepUpright(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textKeepUpright is null")
+          }
+      }
+    }
+
+    fun setTextTransform(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTransform(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTransform is null")
+        }
+      } else {
+          layer.textTransform(TextTransform.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.textOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOffset is null")
+          }
+      }
+    }
+
+    fun setTextAllowOverlap(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textAllowOverlap(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textAllowOverlap is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textAllowOverlap(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textAllowOverlap is null")
+          }
+      }
+    }
+
+    fun setTextIgnorePlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textIgnorePlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textIgnorePlacement is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textIgnorePlacement(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textIgnorePlacement is null")
+          }
+      }
+    }
+
+    fun setTextOptional(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOptional(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOptional is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textOptional(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOptional is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setIconOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOpacity is null")
+          }
+      }
+    }
+
+
+    fun setIconOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconOpacityTransition(transition);
+      }
+    }
+
+    fun setIconColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.iconColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconColor is null")
+          }
+      }
+    }
+
+
+    fun setIconColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconColorTransition(transition);
+      }
+    }
+
+    fun setIconHaloColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloColor is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloColorTransition(transition);
+      }
+    }
+
+    fun setIconHaloWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloWidth is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloWidthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloWidthTransition(transition);
+      }
+    }
+
+    fun setIconHaloBlur(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloBlur(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloBlur(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloBlur is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloBlurTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloBlurTransition(transition);
+      }
+    }
+
+    fun setIconTranslate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTranslate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconTranslate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconTranslate is null")
+          }
+      }
+    }
+
+
+    fun setIconTranslateTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconTranslateTransition(transition);
+      }
+    }
+
+    fun setIconTranslateAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTranslateAnchor is null")
+        }
+      } else {
+          layer.iconTranslateAnchor(IconTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOpacity is null")
+          }
+      }
+    }
+
+
+    fun setTextOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textOpacityTransition(transition);
+      }
+    }
+
+    fun setTextColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.textColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textColor is null")
+          }
+      }
+    }
+
+
+    fun setTextColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textColorTransition(transition);
+      }
+    }
+
+    fun setTextHaloColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloColor is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloColorTransition(transition);
+      }
+    }
+
+    fun setTextHaloWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloWidth is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloWidthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloWidthTransition(transition);
+      }
+    }
+
+    fun setTextHaloBlur(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloBlur(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloBlur(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloBlur is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloBlurTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloBlurTransition(transition);
+      }
+    }
+
+    fun setTextTranslate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTranslate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.textTranslate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textTranslate is null")
+          }
+      }
+    }
+
+
+    fun setTextTranslateTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textTranslateTransition(transition);
+      }
+    }
+
+    fun setTextTranslateAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTranslateAnchor is null")
+        }
+      } else {
+          layer.textTranslateAnchor(TextTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSymbolZElevate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZElevate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZElevate is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.symbolZElevate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolZElevate is null")
+          }
+      }
+    }
+
+    fun setSymbolElevationReference(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolElevationReference(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolElevationReference is null")
+        }
+      } else {
+          layer.symbolElevationReference(SymbolElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconOcclusionOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setIconOcclusionOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setIconEmissiveStrength(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setIconEmissiveStrengthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setTextEmissiveStrength(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setTextEmissiveStrengthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setIconImageCrossFade(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconImageCrossFade(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconImageCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconImageCrossFade(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconImageCrossFade is null")
+          }
+      }
+    }
+
+    fun setTextOcclusionOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setTextOcclusionOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setIconColorSaturation(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconColorSaturation(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconColorSaturation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconColorSaturation(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconColorSaturation is null")
+          }
+      }
+    }
+
+    fun setSymbolZOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolZOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolZOffset is null")
+          }
+      }
+    }
+
+
+    fun setSymbolZOffsetTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.symbolZOffsetTransition(transition);
+      }
+    }
+
+    fun setCircleSortKey(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleSortKey(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleSortKey(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setCircleRadius(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleRadius(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleRadius(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleRadius is null")
+          }
+      }
+    }
+
+
+    fun setCircleRadiusTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleRadiusTransition(transition);
+      }
+    }
+
+    fun setCircleColor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleColor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.circleColor(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleColor is null")
+          }
+      }
+    }
+
+
+    fun setCircleColorTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleColorTransition(transition);
+      }
+    }
+
+    fun setCircleBlur(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleBlur(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleBlur(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleBlur is null")
+          }
+      }
+    }
+
+
+    fun setCircleBlurTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleBlurTransition(transition);
+      }
+    }
+
+    fun setCircleOpacity(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleOpacity(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleOpacity(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleOpacity is null")
+          }
+      }
+    }
+
+
+    fun setCircleOpacityTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleOpacityTransition(transition);
+      }
+    }
+
+    fun setCircleTranslate(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleTranslate(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.circleTranslate(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleTranslate is null")
+          }
+      }
+    }
+
+
+    fun setCircleTranslateTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleTranslateTransition(transition);
+      }
+    }
+
+    fun setCircleTranslateAnchor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleTranslateAnchor is null")
+        }
+      } else {
+          layer.circleTranslateAnchor(CircleTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCirclePitchScale(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circlePitchScale(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circlePitchScale is null")
+        }
+      } else {
+          layer.circlePitchScale(CirclePitchScale.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCirclePitchAlignment(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circlePitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circlePitchAlignment is null")
+        }
+      } else {
+          layer.circlePitchAlignment(CirclePitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCircleStrokeWidth(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeWidth(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeWidth(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeWidth is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeWidthTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeWidthTransition(transition);
+      }
+    }
+
+    fun setCircleStrokeColor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeColor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeColor(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeColor is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeColorTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeColorTransition(transition);
+      }
+    }
+
+    fun setCircleStrokeOpacity(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeOpacity(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeOpacity(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeOpacity is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeOpacityTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeOpacityTransition(transition);
+      }
+    }
+
+    fun setCircleElevationReference(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleElevationReference(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleElevationReference is null")
+        }
+      } else {
+          layer.circleElevationReference(CircleElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCircleEmissiveStrength(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setCircleEmissiveStrengthTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setHeatmapRadius(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapRadius(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapRadius(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapRadius is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapRadiusTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapRadiusTransition(transition);
+      }
+    }
+
+    fun setHeatmapWeight(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapWeight(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapWeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapWeight(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapWeight is null")
+          }
+      }
+    }
+
+    fun setHeatmapIntensity(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapIntensity(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapIntensity(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapIntensity is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapIntensityTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapIntensityTransition(transition);
+      }
+    }
+
+    fun setHeatmapColor(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapColor(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapColor is null")
+        }
+      } else {
+          layer.heatmapColor(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setHeatmapOpacity(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapOpacity(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapOpacity(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapOpacity is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapOpacityTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapOpacityTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setFillExtrusionEdgeRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionEdgeRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionEdgeRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionEdgeRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionEdgeRadius is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionOpacity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionOpacity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionOpacityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionOpacityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionColor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionColor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionColor(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionColor is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionColorTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionColorTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionTranslate(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionTranslate(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionTranslate(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionTranslate is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionTranslateTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionTranslateTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionTranslateAnchor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionTranslateAnchor is null")
+        }
+      } else {
+          layer.fillExtrusionTranslateAnchor(FillExtrusionTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionPattern(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.fillExtrusionPattern(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "Image for fillExtrusionPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.fillExtrusionPattern(expression)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.fillExtrusionPattern(value);
+        } else {
+          Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPattern is null")
+        }
+      }
+    }
+
+    fun setFillExtrusionHeight(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionHeight(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionHeight(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionHeight is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionHeightTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionHeightTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionBase(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionBase(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBase is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionBase(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionBase is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionBaseTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionBaseTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionVerticalGradient(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionVerticalGradient(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionVerticalGradient is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionVerticalGradient(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionVerticalGradient is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionIntensity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionIntensity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionIntensity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionIntensity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionIntensityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionIntensityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionRoundedRoof(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionRoundedRoof(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionRoundedRoof is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionRoundedRoof(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionRoundedRoof is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionPatternCrossFade(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionPatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionPatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionHeightAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionHeightAlignment(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeightAlignment is null")
+        }
+      } else {
+          layer.fillExtrusionHeightAlignment(FillExtrusionHeightAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionBaseAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionBaseAlignment(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBaseAlignment is null")
+        }
+      } else {
+          layer.fillExtrusionBaseAlignment(FillExtrusionBaseAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionWallRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionWallRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionWallRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionWallRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionWallRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionWallRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionGroundRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionGroundRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionGroundRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionGroundRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionGroundRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionGroundRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionGroundRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionGroundAttenuation(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionGroundAttenuation(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionGroundAttenuation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionGroundAttenuation(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionGroundAttenuation is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionGroundAttenuationTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionGroundAttenuationTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightColor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightColor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightColor(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightColor is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightColorTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightColorTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightIntensity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightIntensity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightIntensity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightIntensity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightIntensityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightIntensityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightWallRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightWallRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightWallRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightWallRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightWallRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightWallRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightGroundRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightGroundRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightGroundRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightGroundRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightGroundRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightGroundRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightGroundRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightGroundAttenuation(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightGroundAttenuation(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightGroundAttenuation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightGroundAttenuation(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightGroundAttenuation is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightGroundAttenuationTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightGroundAttenuationTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionVerticalScale(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionVerticalScale(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionVerticalScale is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionVerticalScale(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionVerticalScale is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionVerticalScaleTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionVerticalScaleTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionCutoffFadeRange(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionCutoffFadeRange(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionCutoffFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionCutoffFadeRange(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionCutoffFadeRange is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionEmissiveStrength(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionEmissiveStrengthTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionLineWidth(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionLineWidth(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionLineWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionLineWidth(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionLineWidth is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionLineWidthTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionLineWidthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setRasterOpacity(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterOpacity(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterOpacity(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterOpacity is null")
+          }
+      }
+    }
+
+
+    fun setRasterOpacityTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterOpacityTransition(transition);
+      }
+    }
+
+    fun setRasterHueRotate(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterHueRotate(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterHueRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterHueRotate(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterHueRotate is null")
+          }
+      }
+    }
+
+
+    fun setRasterHueRotateTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterHueRotateTransition(transition);
+      }
+    }
+
+    fun setRasterBrightnessMin(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterBrightnessMin(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterBrightnessMin is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterBrightnessMin(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterBrightnessMin is null")
+          }
+      }
+    }
+
+
+    fun setRasterBrightnessMinTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterBrightnessMinTransition(transition);
+      }
+    }
+
+    fun setRasterBrightnessMax(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterBrightnessMax(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterBrightnessMax is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterBrightnessMax(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterBrightnessMax is null")
+          }
+      }
+    }
+
+
+    fun setRasterBrightnessMaxTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterBrightnessMaxTransition(transition);
+      }
+    }
+
+    fun setRasterSaturation(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterSaturation(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterSaturation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterSaturation(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterSaturation is null")
+          }
+      }
+    }
+
+
+    fun setRasterSaturationTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterSaturationTransition(transition);
+      }
+    }
+
+    fun setRasterContrast(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterContrast(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterContrast is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterContrast(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterContrast is null")
+          }
+      }
+    }
+
+
+    fun setRasterContrastTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterContrastTransition(transition);
+      }
+    }
+
+    fun setRasterResampling(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterResampling(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterResampling is null")
+        }
+      } else {
+          layer.rasterResampling(RasterResampling.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setRasterFadeDuration(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterFadeDuration(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterFadeDuration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterFadeDuration(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterFadeDuration is null")
+          }
+      }
+    }
+
+    fun setRasterColor(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColor(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColor(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColor is null")
+          }
+      }
+    }
+
+    fun setRasterColorMix(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColorMix(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColorMix is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColorMix(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColorMix is null")
+          }
+      }
+    }
+
+
+    fun setRasterColorMixTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterColorMixTransition(transition);
+      }
+    }
+
+    fun setRasterColorRange(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColorRange(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColorRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColorRange(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColorRange is null")
+          }
+      }
+    }
+
+
+    fun setRasterColorRangeTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterColorRangeTransition(transition);
+      }
+    }
+
+    fun setRasterEmissiveStrength(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setRasterEmissiveStrengthTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setRasterArrayBand(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterArrayBand(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterArrayBand is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.rasterArrayBand(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterArrayBand is null")
+          }
+      }
+    }
+
+    fun setRasterElevation(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterElevation(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterElevation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterElevation(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterElevation is null")
+          }
+      }
+    }
+
+
+    fun setRasterElevationTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterElevationTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setRasterParticleArrayBand(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleArrayBand(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleArrayBand is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleArrayBand(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleArrayBand is null")
+          }
+      }
+    }
+
+    fun setRasterParticleCount(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleCount(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleCount is null")
+        }
+      } else {
+          val value = styleValue.getLong(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleCount(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleCount is null")
+          }
+      }
+    }
+
+    fun setRasterParticleColor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleColor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleColor is null")
+        }
+      } else {
+          layer.rasterParticleColor(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setRasterParticleMaxSpeed(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleMaxSpeed(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleMaxSpeed is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleMaxSpeed(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleMaxSpeed is null")
+          }
+      }
+    }
+
+    fun setRasterParticleSpeedFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleSpeedFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleSpeedFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleSpeedFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleSpeedFactor is null")
+          }
+      }
+    }
+
+
+    fun setRasterParticleSpeedFactorTransition(layer: RasterParticleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterParticleSpeedFactorTransition(transition);
+      }
+    }
+
+    fun setRasterParticleFadeOpacityFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleFadeOpacityFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleFadeOpacityFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleFadeOpacityFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleFadeOpacityFactor is null")
+          }
+      }
+    }
+
+
+    fun setRasterParticleFadeOpacityFactorTransition(layer: RasterParticleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterParticleFadeOpacityFactorTransition(transition);
+      }
+    }
+
+    fun setRasterParticleResetRateFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleResetRateFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleResetRateFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleResetRateFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleResetRateFactor is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setHillshadeIlluminationDirection(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeIlluminationDirection(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeIlluminationDirection is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeIlluminationDirection(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeIlluminationDirection is null")
+          }
+      }
+    }
+
+    fun setHillshadeIlluminationAnchor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeIlluminationAnchor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeIlluminationAnchor is null")
+        }
+      } else {
+          layer.hillshadeIlluminationAnchor(HillshadeIlluminationAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setHillshadeExaggeration(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeExaggeration(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeExaggeration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeExaggeration(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeExaggeration is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeExaggerationTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeExaggerationTransition(transition);
+      }
+    }
+
+    fun setHillshadeShadowColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeShadowColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeShadowColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeShadowColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeShadowColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeShadowColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeShadowColorTransition(transition);
+      }
+    }
+
+    fun setHillshadeHighlightColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeHighlightColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeHighlightColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeHighlightColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeHighlightColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeHighlightColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeHighlightColorTransition(transition);
+      }
+    }
+
+    fun setHillshadeAccentColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeAccentColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeAccentColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeAccentColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeAccentColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeAccentColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeAccentColorTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setModelId(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelId(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelId is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.modelId(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelId is null")
+          }
+      }
+    }
+
+    fun setModelOpacity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelOpacity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelOpacity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelOpacity is null")
+          }
+      }
+    }
+
+
+    fun setModelOpacityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelOpacityTransition(transition);
+      }
+    }
+
+    fun setModelRotation(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelRotation(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelRotation is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelRotation(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelRotation is null")
+          }
+      }
+    }
+
+
+    fun setModelRotationTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelRotationTransition(transition);
+      }
+    }
+
+    fun setModelScale(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelScale(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelScale is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelScale(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelScale is null")
+          }
+      }
+    }
+
+
+    fun setModelScaleTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelScaleTransition(transition);
+      }
+    }
+
+    fun setModelTranslation(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelTranslation(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelTranslation is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelTranslation(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelTranslation is null")
+          }
+      }
+    }
+
+
+    fun setModelTranslationTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelTranslationTransition(transition);
+      }
+    }
+
+    fun setModelColor(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelColor(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.modelColor(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelColor is null")
+          }
+      }
+    }
+
+
+    fun setModelColorTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelColorTransition(transition);
+      }
+    }
+
+    fun setModelColorMixIntensity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelColorMixIntensity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelColorMixIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelColorMixIntensity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelColorMixIntensity is null")
+          }
+      }
+    }
+
+
+    fun setModelColorMixIntensityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelColorMixIntensityTransition(transition);
+      }
+    }
+
+    fun setModelType(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelType(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelType is null")
+        }
+      } else {
+          layer.modelType(ModelType.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setModelCastShadows(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelCastShadows(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelCastShadows is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.modelCastShadows(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelCastShadows is null")
+          }
+      }
+    }
+
+    fun setModelReceiveShadows(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelReceiveShadows(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelReceiveShadows is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.modelReceiveShadows(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelReceiveShadows is null")
+          }
+      }
+    }
+
+    fun setModelAmbientOcclusionIntensity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelAmbientOcclusionIntensity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelAmbientOcclusionIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelAmbientOcclusionIntensity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelAmbientOcclusionIntensity is null")
+          }
+      }
+    }
+
+
+    fun setModelAmbientOcclusionIntensityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelAmbientOcclusionIntensityTransition(transition);
+      }
+    }
+
+    fun setModelEmissiveStrength(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setModelEmissiveStrengthTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setModelRoughness(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelRoughness(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelRoughness is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelRoughness(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelRoughness is null")
+          }
+      }
+    }
+
+
+    fun setModelRoughnessTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelRoughnessTransition(transition);
+      }
+    }
+
+    fun setModelHeightBasedEmissiveStrengthMultiplier(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelHeightBasedEmissiveStrengthMultiplier(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelHeightBasedEmissiveStrengthMultiplier is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelHeightBasedEmissiveStrengthMultiplier(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelHeightBasedEmissiveStrengthMultiplier is null")
+          }
+      }
+    }
+
+
+    fun setModelHeightBasedEmissiveStrengthMultiplierTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelHeightBasedEmissiveStrengthMultiplierTransition(transition);
+      }
+    }
+
+    fun setModelCutoffFadeRange(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelCutoffFadeRange(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelCutoffFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelCutoffFadeRange(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelCutoffFadeRange is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setBackgroundColor(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundColor(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundColor(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundColor is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundColorTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundColorTransition(transition);
+      }
+    }
+
+    fun setBackgroundPattern(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.backgroundPattern(value)
+          } else {
+            Logger.e("RNMBXBackground", "Image for backgroundPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.backgroundPattern(expression)
+          } else {
+            Logger.e("RNMBXBackground", "Expression for backgroundPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.backgroundPattern(value);
+        } else {
+          Logger.e("RNMBXBackground", "value for backgroundPattern is null")
+        }
+      }
+    }
+
+    fun setBackgroundOpacity(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundOpacity(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundOpacity(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundOpacity is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundOpacityTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundOpacityTransition(transition);
+      }
+    }
+
+    fun setBackgroundPitchAlignment(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundPitchAlignment is null")
+        }
+      } else {
+          layer.backgroundPitchAlignment(BackgroundPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setBackgroundEmissiveStrength(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundEmissiveStrengthTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setSkyType(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyType(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyType is null")
+        }
+      } else {
+          layer.skyType(SkyType.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSkyAtmosphereSun(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereSun(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereSun is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereSun(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereSun is null")
+          }
+      }
+    }
+
+    fun setSkyAtmosphereSunIntensity(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereSunIntensity(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereSunIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereSunIntensity(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereSunIntensity is null")
+          }
+      }
+    }
+
+    fun setSkyGradientCenter(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradientCenter(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradientCenter is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.skyGradientCenter(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyGradientCenter is null")
+          }
+      }
+    }
+
+    fun setSkyGradientRadius(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradientRadius(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradientRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyGradientRadius(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyGradientRadius is null")
+          }
+      }
+    }
+
+    fun setSkyGradient(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradient(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradient is null")
+        }
+      } else {
+          layer.skyGradient(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setSkyAtmosphereHaloColor(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereHaloColor(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereHaloColor is null")
+          }
+      }
+    }
+
+    fun setSkyAtmosphereColor(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereColor(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereColor(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereColor is null")
+          }
+      }
+    }
+
+    fun setSkyOpacity(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyOpacity(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyOpacity(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyOpacity is null")
+          }
+      }
+    }
+
+
+    fun setSkyOpacityTransition(layer: SkyLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.skyOpacityTransition(transition);
+      }
+    }
+
+    fun setAnchor(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.anchor(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for anchor is null")
+        }
+      } else {
+          layer.anchor(Anchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setPosition(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.position(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for position is null")
+        }
+      } else {
+          layer.position(styleValue.getLightPosition())
+      }
+    }
+
+
+    fun setPositionTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.positionTransition(transition);
+      }
+    }
+
+    fun setColor(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.color(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for color is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.color(value)
+          } else {
+            Logger.e("RNMBXLight", "value for color is null")
+          }
+      }
+    }
+
+
+    fun setColorTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.colorTransition(transition);
+      }
+    }
+
+    fun setIntensity(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.intensity(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for intensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.intensity(value)
+          } else {
+            Logger.e("RNMBXLight", "value for intensity is null")
+          }
+      }
+    }
+
+
+    fun setIntensityTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.intensityTransition(transition);
+      }
+    }
+
+    fun setRange(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.range(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for range is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.range(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for range is null")
+          }
+      }
+    }
+
+
+    fun setRangeTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rangeTransition(transition);
+      }
+    }
+
+    fun setColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.color(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for color is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.color(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for color is null")
+          }
+      }
+    }
+
+
+    fun setColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.colorTransition(transition);
+      }
+    }
+
+    fun setHighColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.highColor(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for highColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.highColor(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for highColor is null")
+          }
+      }
+    }
+
+
+    fun setHighColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.highColorTransition(transition);
+      }
+    }
+
+    fun setSpaceColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.spaceColor(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for spaceColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.spaceColor(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for spaceColor is null")
+          }
+      }
+    }
+
+
+    fun setSpaceColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.spaceColorTransition(transition);
+      }
+    }
+
+    fun setHorizonBlend(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.horizonBlend(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for horizonBlend is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.horizonBlend(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for horizonBlend is null")
+          }
+      }
+    }
+
+
+    fun setHorizonBlendTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.horizonBlendTransition(transition);
+      }
+    }
+
+    fun setStarIntensity(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.starIntensity(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for starIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.starIntensity(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for starIntensity is null")
+          }
+      }
+    }
+
+
+    fun setStarIntensityTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.starIntensityTransition(transition);
+      }
+    }
+
+    fun setVerticalRange(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.verticalRange(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for verticalRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.verticalRange(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for verticalRange is null")
+          }
+      }
+    }
+
+
+    fun setVerticalRangeTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.verticalRangeTransition(transition);
+      }
+    }
+
+    fun setExaggeration(layer: Terrain, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.exaggeration(expression)
+        } else {
+          Logger.e("RNMBXTerrain", "Expression for exaggeration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.exaggeration(value)
+          } else {
+            Logger.e("RNMBXTerrain", "value for exaggeration is null")
+          }
+      }
+    }
+
+}
diff --git a/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.original b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.original
new file mode 100644
index 0000000..a8456b6
--- /dev/null
+++ b/node_modules/@rnmapbox/maps/android/src/main/java/com/rnmapbox/rnmbx/components/styles/RNMBXStyleFactory.kt.original
@@ -0,0 +1,5597 @@
+// DO NOT MODIFY
+// THIS FILE IS AUTOGENERATED
+package com.rnmapbox.rnmbx.components.styles
+
+import com.mapbox.maps.MapboxStyleException
+import com.mapbox.maps.extension.style.expressions.generated.Expression
+import com.mapbox.maps.extension.style.layers.generated.BackgroundLayer
+import com.mapbox.maps.extension.style.layers.generated.CircleLayer
+import com.mapbox.maps.extension.style.layers.generated.FillExtrusionLayer
+import com.mapbox.maps.extension.style.layers.generated.FillLayer
+import com.mapbox.maps.extension.style.layers.generated.LineLayer
+import com.mapbox.maps.extension.style.layers.generated.SkyLayer
+// import com.mapbox.maps.extension.style.layers.generated.PropertyFactory
+// import com.mapbox.maps.extension.style.layers.generated.PropertyValue
+import com.mapbox.maps.extension.style.layers.generated.RasterLayer
+import com.mapbox.maps.extension.style.layers.generated.RasterParticleLayer
+import com.mapbox.maps.extension.style.layers.generated.SymbolLayer
+import com.mapbox.maps.extension.style.layers.generated.HeatmapLayer
+import com.mapbox.maps.extension.style.layers.generated.HillshadeLayer
+import com.mapbox.maps.extension.style.atmosphere.generated.Atmosphere
+import com.mapbox.maps.extension.style.terrain.generated.Terrain
+import com.mapbox.maps.extension.style.layers.generated.ModelLayer
+// import com.mapbox.maps.extension.style.layers.properties.generated.Visibility
+import com.mapbox.maps.extension.style.layers.properties.generated.*
+import com.mapbox.maps.extension.style.types.StyleTransition
+
+import com.mapbox.maps.extension.style.light.LightPosition
+import com.rnmapbox.rnmbx.utils.DownloadMapImageTask.OnAllImagesLoaded
+import com.rnmapbox.rnmbx.utils.Logger
+
+import com.rnmapbox.rnmbx.v11compat.light.*;
+import com.rnmapbox.rnmbx.v11compat.stylefactory.*;
+
+import java.util.List;
+
+const val LOG_TAG = "RNMBXStyleFactory"
+
+object RNMBXStyleFactory {
+    const val VALUE_KEY = "value";
+    const val SHOULD_ADD_IMAGE_KEY = "shouldAddImage";
+
+    fun setFillLayerStyle(layer: FillLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "fillSortKey" ->
+                setFillSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "fillAntialias" ->
+                setFillAntialias(layer, styleValue)
+              "fillOpacity" ->
+                setFillOpacity(layer, styleValue)
+                "fillOpacityTransition" ->
+                setFillOpacityTransition(layer, styleValue)
+              "fillColor" ->
+                setFillColor(layer, styleValue)
+                "fillColorTransition" ->
+                setFillColorTransition(layer, styleValue)
+              "fillOutlineColor" ->
+                setFillOutlineColor(layer, styleValue)
+                "fillOutlineColorTransition" ->
+                setFillOutlineColorTransition(layer, styleValue)
+              "fillTranslate" ->
+                setFillTranslate(layer, styleValue)
+                "fillTranslateTransition" ->
+                setFillTranslateTransition(layer, styleValue)
+              "fillTranslateAnchor" ->
+                setFillTranslateAnchor(layer, styleValue)
+              "fillPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "fillPatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillPatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFill",String.format("Exception failed during setFillPatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "fillEmissiveStrength" ->
+                setFillEmissiveStrength(layer, styleValue)
+                "fillEmissiveStrengthTransition" ->
+                setFillEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setLineLayerStyle(layer: LineLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "lineCap" ->
+                setLineCap(layer, styleValue)
+              "lineJoin" ->
+                setLineJoin(layer, styleValue)
+              "lineMiterLimit" ->
+                setLineMiterLimit(layer, styleValue)
+              "lineRoundLimit" ->
+                setLineRoundLimit(layer, styleValue)
+              "lineSortKey" ->
+                setLineSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "lineOpacity" ->
+                setLineOpacity(layer, styleValue)
+                "lineOpacityTransition" ->
+                setLineOpacityTransition(layer, styleValue)
+              "lineColor" ->
+                setLineColor(layer, styleValue)
+                "lineColorTransition" ->
+                setLineColorTransition(layer, styleValue)
+              "lineTranslate" ->
+                setLineTranslate(layer, styleValue)
+                "lineTranslateTransition" ->
+                setLineTranslateTransition(layer, styleValue)
+              "lineTranslateAnchor" ->
+                setLineTranslateAnchor(layer, styleValue)
+              "lineWidth" ->
+                setLineWidth(layer, styleValue)
+                "lineWidthTransition" ->
+                setLineWidthTransition(layer, styleValue)
+              "lineGapWidth" ->
+                setLineGapWidth(layer, styleValue)
+                "lineGapWidthTransition" ->
+                setLineGapWidthTransition(layer, styleValue)
+              "lineOffset" ->
+                setLineOffset(layer, styleValue)
+                "lineOffsetTransition" ->
+                setLineOffsetTransition(layer, styleValue)
+              "lineBlur" ->
+                setLineBlur(layer, styleValue)
+                "lineBlurTransition" ->
+                setLineBlurTransition(layer, styleValue)
+              "lineDasharray" ->
+                setLineDasharray(layer, styleValue)
+              "linePattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setLinePattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePattern: %s", exception.message))
+                        }
+                    }
+                })
+              "lineGradient" ->
+                setLineGradient(layer, styleValue)
+              "lineTrimOffset" ->
+                setLineTrimOffset(layer, styleValue)
+              "lineZOffset" ->
+                setLineZOffset(layer, styleValue)
+              "lineElevationReference" ->
+                setLineElevationReference(layer, styleValue)
+              "lineCrossSlope" ->
+                setLineCrossSlope(layer, styleValue)
+              "linePatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setLinePatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXLine",String.format("Exception failed during setLinePatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "lineTrimFadeRange" ->
+                setLineTrimFadeRange(layer, styleValue)
+              "lineTrimColor" ->
+                setLineTrimColor(layer, styleValue)
+                "lineTrimColorTransition" ->
+                setLineTrimColorTransition(layer, styleValue)
+              "lineEmissiveStrength" ->
+                setLineEmissiveStrength(layer, styleValue)
+                "lineEmissiveStrengthTransition" ->
+                setLineEmissiveStrengthTransition(layer, styleValue)
+              "lineOcclusionOpacity" ->
+                setLineOcclusionOpacity(layer, styleValue)
+                "lineOcclusionOpacityTransition" ->
+                setLineOcclusionOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setSymbolLayerStyle(layer: SymbolLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "symbolPlacement" ->
+                setSymbolPlacement(layer, styleValue)
+              "symbolSpacing" ->
+                setSymbolSpacing(layer, styleValue)
+              "symbolAvoidEdges" ->
+                setSymbolAvoidEdges(layer, styleValue)
+              "symbolSortKey" ->
+                setSymbolSortKey(layer, styleValue)
+              "symbolZOrder" ->
+                setSymbolZOrder(layer, styleValue)
+              "iconAllowOverlap" ->
+                setIconAllowOverlap(layer, styleValue)
+              "iconIgnorePlacement" ->
+                setIconIgnorePlacement(layer, styleValue)
+              "iconOptional" ->
+                setIconOptional(layer, styleValue)
+              "iconRotationAlignment" ->
+                setIconRotationAlignment(layer, styleValue)
+              "iconSize" ->
+                setIconSize(layer, styleValue)
+              "iconTextFit" ->
+                setIconTextFit(layer, styleValue)
+              "iconTextFitPadding" ->
+                setIconTextFitPadding(layer, styleValue)
+              "iconImage" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setIconImage(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXSymbol",String.format("Exception failed during setIconImage: %s", exception.message))
+                        }
+                    }
+                })
+              "iconRotate" ->
+                setIconRotate(layer, styleValue)
+              "iconPadding" ->
+                setIconPadding(layer, styleValue)
+              "iconKeepUpright" ->
+                setIconKeepUpright(layer, styleValue)
+              "iconOffset" ->
+                setIconOffset(layer, styleValue)
+              "iconAnchor" ->
+                setIconAnchor(layer, styleValue)
+              "iconPitchAlignment" ->
+                setIconPitchAlignment(layer, styleValue)
+              "textPitchAlignment" ->
+                setTextPitchAlignment(layer, styleValue)
+              "textRotationAlignment" ->
+                setTextRotationAlignment(layer, styleValue)
+              "textField" ->
+                setTextField(layer, styleValue)
+              "textFont" ->
+                setTextFont(layer, styleValue)
+              "textSize" ->
+                setTextSize(layer, styleValue)
+              "textMaxWidth" ->
+                setTextMaxWidth(layer, styleValue)
+              "textLineHeight" ->
+                setTextLineHeight(layer, styleValue)
+              "textLetterSpacing" ->
+                setTextLetterSpacing(layer, styleValue)
+              "textJustify" ->
+                setTextJustify(layer, styleValue)
+              "textRadialOffset" ->
+                setTextRadialOffset(layer, styleValue)
+              "textVariableAnchor" ->
+                setTextVariableAnchor(layer, styleValue)
+              "textAnchor" ->
+                setTextAnchor(layer, styleValue)
+              "textMaxAngle" ->
+                setTextMaxAngle(layer, styleValue)
+              "textWritingMode" ->
+                setTextWritingMode(layer, styleValue)
+              "textRotate" ->
+                setTextRotate(layer, styleValue)
+              "textPadding" ->
+                setTextPadding(layer, styleValue)
+              "textKeepUpright" ->
+                setTextKeepUpright(layer, styleValue)
+              "textTransform" ->
+                setTextTransform(layer, styleValue)
+              "textOffset" ->
+                setTextOffset(layer, styleValue)
+              "textAllowOverlap" ->
+                setTextAllowOverlap(layer, styleValue)
+              "textIgnorePlacement" ->
+                setTextIgnorePlacement(layer, styleValue)
+              "textOptional" ->
+                setTextOptional(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "iconOpacity" ->
+                setIconOpacity(layer, styleValue)
+                "iconOpacityTransition" ->
+                setIconOpacityTransition(layer, styleValue)
+              "iconColor" ->
+                setIconColor(layer, styleValue)
+                "iconColorTransition" ->
+                setIconColorTransition(layer, styleValue)
+              "iconHaloColor" ->
+                setIconHaloColor(layer, styleValue)
+                "iconHaloColorTransition" ->
+                setIconHaloColorTransition(layer, styleValue)
+              "iconHaloWidth" ->
+                setIconHaloWidth(layer, styleValue)
+                "iconHaloWidthTransition" ->
+                setIconHaloWidthTransition(layer, styleValue)
+              "iconHaloBlur" ->
+                setIconHaloBlur(layer, styleValue)
+                "iconHaloBlurTransition" ->
+                setIconHaloBlurTransition(layer, styleValue)
+              "iconTranslate" ->
+                setIconTranslate(layer, styleValue)
+                "iconTranslateTransition" ->
+                setIconTranslateTransition(layer, styleValue)
+              "iconTranslateAnchor" ->
+                setIconTranslateAnchor(layer, styleValue)
+              "textOpacity" ->
+                setTextOpacity(layer, styleValue)
+                "textOpacityTransition" ->
+                setTextOpacityTransition(layer, styleValue)
+              "textColor" ->
+                setTextColor(layer, styleValue)
+                "textColorTransition" ->
+                setTextColorTransition(layer, styleValue)
+              "textHaloColor" ->
+                setTextHaloColor(layer, styleValue)
+                "textHaloColorTransition" ->
+                setTextHaloColorTransition(layer, styleValue)
+              "textHaloWidth" ->
+                setTextHaloWidth(layer, styleValue)
+                "textHaloWidthTransition" ->
+                setTextHaloWidthTransition(layer, styleValue)
+              "textHaloBlur" ->
+                setTextHaloBlur(layer, styleValue)
+                "textHaloBlurTransition" ->
+                setTextHaloBlurTransition(layer, styleValue)
+              "textTranslate" ->
+                setTextTranslate(layer, styleValue)
+                "textTranslateTransition" ->
+                setTextTranslateTransition(layer, styleValue)
+              "textTranslateAnchor" ->
+                setTextTranslateAnchor(layer, styleValue)
+              "symbolZElevate" ->
+                setSymbolZElevate(layer, styleValue)
+              "symbolElevationReference" ->
+                setSymbolElevationReference(layer, styleValue)
+              "iconOcclusionOpacity" ->
+                setIconOcclusionOpacity(layer, styleValue)
+                "iconOcclusionOpacityTransition" ->
+                setIconOcclusionOpacityTransition(layer, styleValue)
+              "iconEmissiveStrength" ->
+                setIconEmissiveStrength(layer, styleValue)
+                "iconEmissiveStrengthTransition" ->
+                setIconEmissiveStrengthTransition(layer, styleValue)
+              "textEmissiveStrength" ->
+                setTextEmissiveStrength(layer, styleValue)
+                "textEmissiveStrengthTransition" ->
+                setTextEmissiveStrengthTransition(layer, styleValue)
+              "iconImageCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setIconImageCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXSymbol",String.format("Exception failed during setIconImageCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "textOcclusionOpacity" ->
+                setTextOcclusionOpacity(layer, styleValue)
+                "textOcclusionOpacityTransition" ->
+                setTextOcclusionOpacityTransition(layer, styleValue)
+              "iconColorSaturation" ->
+                setIconColorSaturation(layer, styleValue)
+              "symbolZOffset" ->
+                setSymbolZOffset(layer, styleValue)
+                "symbolZOffsetTransition" ->
+                setSymbolZOffsetTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setCircleLayerStyle(layer: CircleLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "circleSortKey" ->
+                setCircleSortKey(layer, styleValue)
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "circleRadius" ->
+                setCircleRadius(layer, styleValue)
+                "circleRadiusTransition" ->
+                setCircleRadiusTransition(layer, styleValue)
+              "circleColor" ->
+                setCircleColor(layer, styleValue)
+                "circleColorTransition" ->
+                setCircleColorTransition(layer, styleValue)
+              "circleBlur" ->
+                setCircleBlur(layer, styleValue)
+                "circleBlurTransition" ->
+                setCircleBlurTransition(layer, styleValue)
+              "circleOpacity" ->
+                setCircleOpacity(layer, styleValue)
+                "circleOpacityTransition" ->
+                setCircleOpacityTransition(layer, styleValue)
+              "circleTranslate" ->
+                setCircleTranslate(layer, styleValue)
+                "circleTranslateTransition" ->
+                setCircleTranslateTransition(layer, styleValue)
+              "circleTranslateAnchor" ->
+                setCircleTranslateAnchor(layer, styleValue)
+              "circlePitchScale" ->
+                setCirclePitchScale(layer, styleValue)
+              "circlePitchAlignment" ->
+                setCirclePitchAlignment(layer, styleValue)
+              "circleStrokeWidth" ->
+                setCircleStrokeWidth(layer, styleValue)
+                "circleStrokeWidthTransition" ->
+                setCircleStrokeWidthTransition(layer, styleValue)
+              "circleStrokeColor" ->
+                setCircleStrokeColor(layer, styleValue)
+                "circleStrokeColorTransition" ->
+                setCircleStrokeColorTransition(layer, styleValue)
+              "circleStrokeOpacity" ->
+                setCircleStrokeOpacity(layer, styleValue)
+                "circleStrokeOpacityTransition" ->
+                setCircleStrokeOpacityTransition(layer, styleValue)
+              "circleElevationReference" ->
+                setCircleElevationReference(layer, styleValue)
+              "circleEmissiveStrength" ->
+                setCircleEmissiveStrength(layer, styleValue)
+                "circleEmissiveStrengthTransition" ->
+                setCircleEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setHeatmapLayerStyle(layer: HeatmapLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "heatmapRadius" ->
+                setHeatmapRadius(layer, styleValue)
+                "heatmapRadiusTransition" ->
+                setHeatmapRadiusTransition(layer, styleValue)
+              "heatmapWeight" ->
+                setHeatmapWeight(layer, styleValue)
+              "heatmapIntensity" ->
+                setHeatmapIntensity(layer, styleValue)
+                "heatmapIntensityTransition" ->
+                setHeatmapIntensityTransition(layer, styleValue)
+              "heatmapColor" ->
+                setHeatmapColor(layer, styleValue)
+              "heatmapOpacity" ->
+                setHeatmapOpacity(layer, styleValue)
+                "heatmapOpacityTransition" ->
+                setHeatmapOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setFillExtrusionLayerStyle(layer: FillExtrusionLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "fillExtrusionEdgeRadius" ->
+                setFillExtrusionEdgeRadius(layer, styleValue)
+              "fillExtrusionOpacity" ->
+                setFillExtrusionOpacity(layer, styleValue)
+                "fillExtrusionOpacityTransition" ->
+                setFillExtrusionOpacityTransition(layer, styleValue)
+              "fillExtrusionColor" ->
+                setFillExtrusionColor(layer, styleValue)
+                "fillExtrusionColorTransition" ->
+                setFillExtrusionColorTransition(layer, styleValue)
+              "fillExtrusionTranslate" ->
+                setFillExtrusionTranslate(layer, styleValue)
+                "fillExtrusionTranslateTransition" ->
+                setFillExtrusionTranslateTransition(layer, styleValue)
+              "fillExtrusionTranslateAnchor" ->
+                setFillExtrusionTranslateAnchor(layer, styleValue)
+              "fillExtrusionPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillExtrusionPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "fillExtrusionHeight" ->
+                setFillExtrusionHeight(layer, styleValue)
+                "fillExtrusionHeightTransition" ->
+                setFillExtrusionHeightTransition(layer, styleValue)
+              "fillExtrusionBase" ->
+                setFillExtrusionBase(layer, styleValue)
+                "fillExtrusionBaseTransition" ->
+                setFillExtrusionBaseTransition(layer, styleValue)
+              "fillExtrusionVerticalGradient" ->
+                setFillExtrusionVerticalGradient(layer, styleValue)
+              "fillExtrusionAmbientOcclusionIntensity" ->
+                setFillExtrusionAmbientOcclusionIntensity(layer, styleValue)
+                "fillExtrusionAmbientOcclusionIntensityTransition" ->
+                setFillExtrusionAmbientOcclusionIntensityTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionRadius" ->
+                setFillExtrusionAmbientOcclusionRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionRadiusTransition(layer, styleValue)
+              "fillExtrusionRoundedRoof" ->
+                setFillExtrusionRoundedRoof(layer, styleValue)
+              "fillExtrusionPatternCrossFade" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setFillExtrusionPatternCrossFade(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXFillExtrusion",String.format("Exception failed during setFillExtrusionPatternCrossFade: %s", exception.message))
+                        }
+                    }
+                })
+              "fillExtrusionHeightAlignment" ->
+                setFillExtrusionHeightAlignment(layer, styleValue)
+              "fillExtrusionBaseAlignment" ->
+                setFillExtrusionBaseAlignment(layer, styleValue)
+              "fillExtrusionAmbientOcclusionWallRadius" ->
+                setFillExtrusionAmbientOcclusionWallRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionWallRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionWallRadiusTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionGroundRadius" ->
+                setFillExtrusionAmbientOcclusionGroundRadius(layer, styleValue)
+                "fillExtrusionAmbientOcclusionGroundRadiusTransition" ->
+                setFillExtrusionAmbientOcclusionGroundRadiusTransition(layer, styleValue)
+              "fillExtrusionAmbientOcclusionGroundAttenuation" ->
+                setFillExtrusionAmbientOcclusionGroundAttenuation(layer, styleValue)
+                "fillExtrusionAmbientOcclusionGroundAttenuationTransition" ->
+                setFillExtrusionAmbientOcclusionGroundAttenuationTransition(layer, styleValue)
+              "fillExtrusionFloodLightColor" ->
+                setFillExtrusionFloodLightColor(layer, styleValue)
+                "fillExtrusionFloodLightColorTransition" ->
+                setFillExtrusionFloodLightColorTransition(layer, styleValue)
+              "fillExtrusionFloodLightIntensity" ->
+                setFillExtrusionFloodLightIntensity(layer, styleValue)
+                "fillExtrusionFloodLightIntensityTransition" ->
+                setFillExtrusionFloodLightIntensityTransition(layer, styleValue)
+              "fillExtrusionFloodLightWallRadius" ->
+                setFillExtrusionFloodLightWallRadius(layer, styleValue)
+                "fillExtrusionFloodLightWallRadiusTransition" ->
+                setFillExtrusionFloodLightWallRadiusTransition(layer, styleValue)
+              "fillExtrusionFloodLightGroundRadius" ->
+                setFillExtrusionFloodLightGroundRadius(layer, styleValue)
+                "fillExtrusionFloodLightGroundRadiusTransition" ->
+                setFillExtrusionFloodLightGroundRadiusTransition(layer, styleValue)
+              "fillExtrusionFloodLightGroundAttenuation" ->
+                setFillExtrusionFloodLightGroundAttenuation(layer, styleValue)
+                "fillExtrusionFloodLightGroundAttenuationTransition" ->
+                setFillExtrusionFloodLightGroundAttenuationTransition(layer, styleValue)
+              "fillExtrusionVerticalScale" ->
+                setFillExtrusionVerticalScale(layer, styleValue)
+                "fillExtrusionVerticalScaleTransition" ->
+                setFillExtrusionVerticalScaleTransition(layer, styleValue)
+              "fillExtrusionCutoffFadeRange" ->
+                setFillExtrusionCutoffFadeRange(layer, styleValue)
+              "fillExtrusionEmissiveStrength" ->
+                setFillExtrusionEmissiveStrength(layer, styleValue)
+                "fillExtrusionEmissiveStrengthTransition" ->
+                setFillExtrusionEmissiveStrengthTransition(layer, styleValue)
+              "fillExtrusionLineWidth" ->
+                setFillExtrusionLineWidth(layer, styleValue)
+                "fillExtrusionLineWidthTransition" ->
+                setFillExtrusionLineWidthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setRasterLayerStyle(layer: RasterLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "rasterOpacity" ->
+                setRasterOpacity(layer, styleValue)
+                "rasterOpacityTransition" ->
+                setRasterOpacityTransition(layer, styleValue)
+              "rasterHueRotate" ->
+                setRasterHueRotate(layer, styleValue)
+                "rasterHueRotateTransition" ->
+                setRasterHueRotateTransition(layer, styleValue)
+              "rasterBrightnessMin" ->
+                setRasterBrightnessMin(layer, styleValue)
+                "rasterBrightnessMinTransition" ->
+                setRasterBrightnessMinTransition(layer, styleValue)
+              "rasterBrightnessMax" ->
+                setRasterBrightnessMax(layer, styleValue)
+                "rasterBrightnessMaxTransition" ->
+                setRasterBrightnessMaxTransition(layer, styleValue)
+              "rasterSaturation" ->
+                setRasterSaturation(layer, styleValue)
+                "rasterSaturationTransition" ->
+                setRasterSaturationTransition(layer, styleValue)
+              "rasterContrast" ->
+                setRasterContrast(layer, styleValue)
+                "rasterContrastTransition" ->
+                setRasterContrastTransition(layer, styleValue)
+              "rasterResampling" ->
+                setRasterResampling(layer, styleValue)
+              "rasterFadeDuration" ->
+                setRasterFadeDuration(layer, styleValue)
+              "rasterColor" ->
+                setRasterColor(layer, styleValue)
+              "rasterColorMix" ->
+                setRasterColorMix(layer, styleValue)
+                "rasterColorMixTransition" ->
+                setRasterColorMixTransition(layer, styleValue)
+              "rasterColorRange" ->
+                setRasterColorRange(layer, styleValue)
+                "rasterColorRangeTransition" ->
+                setRasterColorRangeTransition(layer, styleValue)
+              "rasterEmissiveStrength" ->
+                setRasterEmissiveStrength(layer, styleValue)
+                "rasterEmissiveStrengthTransition" ->
+                setRasterEmissiveStrengthTransition(layer, styleValue)
+              "rasterArrayBand" ->
+                setRasterArrayBand(layer, styleValue)
+              "rasterElevation" ->
+                setRasterElevation(layer, styleValue)
+                "rasterElevationTransition" ->
+                setRasterElevationTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setRasterParticleLayerStyle(layer: RasterParticleLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "rasterParticleArrayBand" ->
+                setRasterParticleArrayBand(layer, styleValue)
+              "rasterParticleCount" ->
+                setRasterParticleCount(layer, styleValue)
+              "rasterParticleColor" ->
+                setRasterParticleColor(layer, styleValue)
+              "rasterParticleMaxSpeed" ->
+                setRasterParticleMaxSpeed(layer, styleValue)
+              "rasterParticleSpeedFactor" ->
+                setRasterParticleSpeedFactor(layer, styleValue)
+                "rasterParticleSpeedFactorTransition" ->
+                setRasterParticleSpeedFactorTransition(layer, styleValue)
+              "rasterParticleFadeOpacityFactor" ->
+                setRasterParticleFadeOpacityFactor(layer, styleValue)
+                "rasterParticleFadeOpacityFactorTransition" ->
+                setRasterParticleFadeOpacityFactorTransition(layer, styleValue)
+              "rasterParticleResetRateFactor" ->
+                setRasterParticleResetRateFactor(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setHillshadeLayerStyle(layer: HillshadeLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "hillshadeIlluminationDirection" ->
+                setHillshadeIlluminationDirection(layer, styleValue)
+              "hillshadeIlluminationAnchor" ->
+                setHillshadeIlluminationAnchor(layer, styleValue)
+              "hillshadeExaggeration" ->
+                setHillshadeExaggeration(layer, styleValue)
+                "hillshadeExaggerationTransition" ->
+                setHillshadeExaggerationTransition(layer, styleValue)
+              "hillshadeShadowColor" ->
+                setHillshadeShadowColor(layer, styleValue)
+                "hillshadeShadowColorTransition" ->
+                setHillshadeShadowColorTransition(layer, styleValue)
+              "hillshadeHighlightColor" ->
+                setHillshadeHighlightColor(layer, styleValue)
+                "hillshadeHighlightColorTransition" ->
+                setHillshadeHighlightColorTransition(layer, styleValue)
+              "hillshadeAccentColor" ->
+                setHillshadeAccentColor(layer, styleValue)
+                "hillshadeAccentColorTransition" ->
+                setHillshadeAccentColorTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setModelLayerStyle(layer: ModelLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "modelId" ->
+                setModelId(layer, styleValue)
+              "modelOpacity" ->
+                setModelOpacity(layer, styleValue)
+                "modelOpacityTransition" ->
+                setModelOpacityTransition(layer, styleValue)
+              "modelRotation" ->
+                setModelRotation(layer, styleValue)
+                "modelRotationTransition" ->
+                setModelRotationTransition(layer, styleValue)
+              "modelScale" ->
+                setModelScale(layer, styleValue)
+                "modelScaleTransition" ->
+                setModelScaleTransition(layer, styleValue)
+              "modelTranslation" ->
+                setModelTranslation(layer, styleValue)
+                "modelTranslationTransition" ->
+                setModelTranslationTransition(layer, styleValue)
+              "modelColor" ->
+                setModelColor(layer, styleValue)
+                "modelColorTransition" ->
+                setModelColorTransition(layer, styleValue)
+              "modelColorMixIntensity" ->
+                setModelColorMixIntensity(layer, styleValue)
+                "modelColorMixIntensityTransition" ->
+                setModelColorMixIntensityTransition(layer, styleValue)
+              "modelType" ->
+                setModelType(layer, styleValue)
+              "modelCastShadows" ->
+                setModelCastShadows(layer, styleValue)
+              "modelReceiveShadows" ->
+                setModelReceiveShadows(layer, styleValue)
+              "modelAmbientOcclusionIntensity" ->
+                setModelAmbientOcclusionIntensity(layer, styleValue)
+                "modelAmbientOcclusionIntensityTransition" ->
+                setModelAmbientOcclusionIntensityTransition(layer, styleValue)
+              "modelEmissiveStrength" ->
+                setModelEmissiveStrength(layer, styleValue)
+                "modelEmissiveStrengthTransition" ->
+                setModelEmissiveStrengthTransition(layer, styleValue)
+              "modelRoughness" ->
+                setModelRoughness(layer, styleValue)
+                "modelRoughnessTransition" ->
+                setModelRoughnessTransition(layer, styleValue)
+              "modelHeightBasedEmissiveStrengthMultiplier" ->
+                setModelHeightBasedEmissiveStrengthMultiplier(layer, styleValue)
+                "modelHeightBasedEmissiveStrengthMultiplierTransition" ->
+                setModelHeightBasedEmissiveStrengthMultiplierTransition(layer, styleValue)
+              "modelCutoffFadeRange" ->
+                setModelCutoffFadeRange(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setBackgroundLayerStyle(layer: BackgroundLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "backgroundColor" ->
+                setBackgroundColor(layer, styleValue)
+                "backgroundColorTransition" ->
+                setBackgroundColorTransition(layer, styleValue)
+              "backgroundPattern" ->
+                style.addImage(styleValue!!, styleKey, object : OnAllImagesLoaded {
+                    override fun onAllImagesLoaded() {
+                        try {
+                            setBackgroundPattern(layer, styleValue)
+                        } catch (exception: RuntimeException) {
+                            Logger.e("RNMBXBackground",String.format("Exception failed during setBackgroundPattern: %s", exception.message))
+                        }
+                    }
+                })
+              "backgroundOpacity" ->
+                setBackgroundOpacity(layer, styleValue)
+                "backgroundOpacityTransition" ->
+                setBackgroundOpacityTransition(layer, styleValue)
+              "backgroundPitchAlignment" ->
+                setBackgroundPitchAlignment(layer, styleValue)
+              "backgroundEmissiveStrength" ->
+                setBackgroundEmissiveStrength(layer, styleValue)
+                "backgroundEmissiveStrengthTransition" ->
+                setBackgroundEmissiveStrengthTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setSkyLayerStyle(layer: SkyLayer, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "visibility" ->
+                setVisibility(layer, styleValue)
+              "skyType" ->
+                setSkyType(layer, styleValue)
+              "skyAtmosphereSun" ->
+                setSkyAtmosphereSun(layer, styleValue)
+              "skyAtmosphereSunIntensity" ->
+                setSkyAtmosphereSunIntensity(layer, styleValue)
+              "skyGradientCenter" ->
+                setSkyGradientCenter(layer, styleValue)
+              "skyGradientRadius" ->
+                setSkyGradientRadius(layer, styleValue)
+              "skyGradient" ->
+                setSkyGradient(layer, styleValue)
+              "skyAtmosphereHaloColor" ->
+                setSkyAtmosphereHaloColor(layer, styleValue)
+              "skyAtmosphereColor" ->
+                setSkyAtmosphereColor(layer, styleValue)
+              "skyOpacity" ->
+                setSkyOpacity(layer, styleValue)
+                "skyOpacityTransition" ->
+                setSkyOpacityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setLightLayerStyle(layer: Light, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "anchor" ->
+                setAnchor(layer, styleValue)
+              "position" ->
+                setPosition(layer, styleValue)
+                "positionTransition" ->
+                setPositionTransition(layer, styleValue)
+              "color" ->
+                setColor(layer, styleValue)
+                "colorTransition" ->
+                setColorTransition(layer, styleValue)
+              "intensity" ->
+                setIntensity(layer, styleValue)
+                "intensityTransition" ->
+                setIntensityTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setAtmosphereLayerStyle(layer: Atmosphere, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "range" ->
+                setRange(layer, styleValue)
+                "rangeTransition" ->
+                setRangeTransition(layer, styleValue)
+              "color" ->
+                setColor(layer, styleValue)
+                "colorTransition" ->
+                setColorTransition(layer, styleValue)
+              "highColor" ->
+                setHighColor(layer, styleValue)
+                "highColorTransition" ->
+                setHighColorTransition(layer, styleValue)
+              "spaceColor" ->
+                setSpaceColor(layer, styleValue)
+                "spaceColorTransition" ->
+                setSpaceColorTransition(layer, styleValue)
+              "horizonBlend" ->
+                setHorizonBlend(layer, styleValue)
+                "horizonBlendTransition" ->
+                setHorizonBlendTransition(layer, styleValue)
+              "starIntensity" ->
+                setStarIntensity(layer, styleValue)
+                "starIntensityTransition" ->
+                setStarIntensityTransition(layer, styleValue)
+              "verticalRange" ->
+                setVerticalRange(layer, styleValue)
+                "verticalRangeTransition" ->
+                setVerticalRangeTransition(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+    fun setTerrainLayerStyle(layer: Terrain, style: RNMBXStyle ) {
+      val styleKeys = style.allStyleKeys
+
+      if (styleKeys.isEmpty()) {
+        return
+      }
+
+      for (styleKey in styleKeys) {
+        try {
+          val styleValue = style.getStyleValueForKey(styleKey)
+
+          when (styleKey) {
+              "exaggeration" ->
+                setExaggeration(layer, styleValue)
+          }
+        } catch (e: MapboxStyleException) {
+          Logger.e(LOG_TAG, "Failed to update: $styleKey ${e.message}")
+        }
+      }
+    }
+
+    fun setFillSortKey(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillSortKey(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillSortKey(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setFillAntialias(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillAntialias(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillAntialias is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillAntialias(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillAntialias is null")
+          }
+      }
+    }
+
+    fun setFillOpacity(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillOpacity(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillOpacity(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillOpacity is null")
+          }
+      }
+    }
+
+
+    fun setFillOpacityTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillOpacityTransition(transition);
+      }
+    }
+
+    fun setFillColor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillColor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillColor(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillColor is null")
+          }
+      }
+    }
+
+
+    fun setFillColorTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillColorTransition(transition);
+      }
+    }
+
+    fun setFillOutlineColor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillOutlineColor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillOutlineColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillOutlineColor(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillOutlineColor is null")
+          }
+      }
+    }
+
+
+    fun setFillOutlineColorTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillOutlineColorTransition(transition);
+      }
+    }
+
+    fun setFillTranslate(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillTranslate(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.fillTranslate(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillTranslate is null")
+          }
+      }
+    }
+
+
+    fun setFillTranslateTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillTranslateTransition(transition);
+      }
+    }
+
+    fun setFillTranslateAnchor(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillTranslateAnchor is null")
+        }
+      } else {
+          layer.fillTranslateAnchor(FillTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillPattern(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.fillPattern(value)
+          } else {
+            Logger.e("RNMBXFill", "Image for fillPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.fillPattern(expression)
+          } else {
+            Logger.e("RNMBXFill", "Expression for fillPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.fillPattern(value);
+        } else {
+          Logger.e("RNMBXFill", "value for fillPattern is null")
+        }
+      }
+    }
+
+    fun setFillPatternCrossFade(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillPatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillPatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillPatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillPatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setFillEmissiveStrength(layer: FillLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXFill", "Expression for fillEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXFill", "value for fillEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setFillEmissiveStrengthTransition(layer: FillLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setLineCap(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineCap(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineCap is null")
+        }
+      } else {
+          layer.lineCap(LineCap.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineJoin(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineJoin(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineJoin is null")
+        }
+      } else {
+          layer.lineJoin(LineJoin.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineMiterLimit(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineMiterLimit(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineMiterLimit is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineMiterLimit(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineMiterLimit is null")
+          }
+      }
+    }
+
+    fun setLineRoundLimit(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineRoundLimit(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineRoundLimit is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineRoundLimit(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineRoundLimit is null")
+          }
+      }
+    }
+
+    fun setLineSortKey(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineSortKey(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineSortKey(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setLineOpacity(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOpacity(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOpacity(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOpacity is null")
+          }
+      }
+    }
+
+
+    fun setLineOpacityTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOpacityTransition(transition);
+      }
+    }
+
+    fun setLineColor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineColor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.lineColor(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineColor is null")
+          }
+      }
+    }
+
+
+    fun setLineColorTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineColorTransition(transition);
+      }
+    }
+
+    fun setLineTranslate(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTranslate(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTranslate(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTranslate is null")
+          }
+      }
+    }
+
+
+    fun setLineTranslateTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineTranslateTransition(transition);
+      }
+    }
+
+    fun setLineTranslateAnchor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTranslateAnchor is null")
+        }
+      } else {
+          layer.lineTranslateAnchor(LineTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineWidth(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineWidth(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineWidth(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineWidth is null")
+          }
+      }
+    }
+
+
+    fun setLineWidthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineWidthTransition(transition);
+      }
+    }
+
+    fun setLineGapWidth(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineGapWidth(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineGapWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineGapWidth(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineGapWidth is null")
+          }
+      }
+    }
+
+
+    fun setLineGapWidthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineGapWidthTransition(transition);
+      }
+    }
+
+    fun setLineOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOffset is null")
+          }
+      }
+    }
+
+
+    fun setLineOffsetTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOffsetTransition(transition);
+      }
+    }
+
+    fun setLineBlur(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineBlur(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineBlur(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineBlur is null")
+          }
+      }
+    }
+
+
+    fun setLineBlurTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineBlurTransition(transition);
+      }
+    }
+
+    fun setLineDasharray(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineDasharray(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineDasharray is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineDasharray(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineDasharray is null")
+          }
+      }
+    }
+
+    fun setLinePattern(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.linePattern(value)
+          } else {
+            Logger.e("RNMBXLine", "Image for linePattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.linePattern(expression)
+          } else {
+            Logger.e("RNMBXLine", "Expression for linePattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.linePattern(value);
+        } else {
+          Logger.e("RNMBXLine", "value for linePattern is null")
+        }
+      }
+    }
+
+    fun setLineGradient(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineGradient(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineGradient is null")
+        }
+      } else {
+          layer.lineGradient(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setLineTrimOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimOffset is null")
+          }
+      }
+    }
+
+    fun setLineZOffset(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineZOffset(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineZOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineZOffset(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineZOffset is null")
+          }
+      }
+    }
+
+    fun setLineElevationReference(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineElevationReference(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineElevationReference is null")
+        }
+      } else {
+          layer.lineElevationReference(LineElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setLineCrossSlope(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineCrossSlope(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineCrossSlope is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineCrossSlope(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineCrossSlope is null")
+          }
+      }
+    }
+
+    fun setLinePatternCrossFade(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.linePatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for linePatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.linePatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXLine", "value for linePatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setLineTrimFadeRange(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimFadeRange(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimFadeRange(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimFadeRange is null")
+          }
+      }
+    }
+
+    fun setLineTrimColor(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineTrimColor(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineTrimColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.lineTrimColor(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineTrimColor is null")
+          }
+      }
+    }
+
+
+    fun setLineTrimColorTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineTrimColorTransition(transition);
+      }
+    }
+
+    fun setLineEmissiveStrength(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setLineEmissiveStrengthTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setLineOcclusionOpacity(layer: LineLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.lineOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXLine", "Expression for lineOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.lineOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXLine", "value for lineOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setLineOcclusionOpacityTransition(layer: LineLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.lineOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setSymbolPlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolPlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolPlacement is null")
+        }
+      } else {
+          layer.symbolPlacement(SymbolPlacement.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSymbolSpacing(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolSpacing(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolSpacing is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolSpacing(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolSpacing is null")
+          }
+      }
+    }
+
+    fun setSymbolAvoidEdges(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolAvoidEdges(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolAvoidEdges is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.symbolAvoidEdges(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolAvoidEdges is null")
+          }
+      }
+    }
+
+    fun setSymbolSortKey(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolSortKey(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolSortKey(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolSortKey is null")
+          }
+      }
+    }
+
+    fun setSymbolZOrder(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZOrder(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZOrder is null")
+        }
+      } else {
+          layer.symbolZOrder(SymbolZOrder.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconAllowOverlap(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconAllowOverlap(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconAllowOverlap is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconAllowOverlap(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconAllowOverlap is null")
+          }
+      }
+    }
+
+    fun setIconIgnorePlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconIgnorePlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconIgnorePlacement is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconIgnorePlacement(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconIgnorePlacement is null")
+          }
+      }
+    }
+
+    fun setIconOptional(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOptional(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOptional is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconOptional(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOptional is null")
+          }
+      }
+    }
+
+    fun setIconRotationAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconRotationAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconRotationAlignment is null")
+        }
+      } else {
+          layer.iconRotationAlignment(IconRotationAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconSize(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconSize(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconSize is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconSize(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconSize is null")
+          }
+      }
+    }
+
+    fun setIconTextFit(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTextFit(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTextFit is null")
+        }
+      } else {
+          layer.iconTextFit(IconTextFit.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconTextFitPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTextFitPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTextFitPadding is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconTextFitPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconTextFitPadding is null")
+          }
+      }
+    }
+
+    fun setIconImage(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.iconImage(value)
+          } else {
+            Logger.e("RNMBXSymbol", "Image for iconImage is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.iconImage(expression)
+          } else {
+            Logger.e("RNMBXSymbol", "Expression for iconImage is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.iconImage(value);
+        } else {
+          Logger.e("RNMBXSymbol", "value for iconImage is null")
+        }
+      }
+    }
+
+    fun setIconRotate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconRotate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconRotate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconRotate is null")
+          }
+      }
+    }
+
+    fun setIconPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconPadding is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconPadding is null")
+          }
+      }
+    }
+
+    fun setIconKeepUpright(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconKeepUpright(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconKeepUpright is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.iconKeepUpright(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconKeepUpright is null")
+          }
+      }
+    }
+
+    fun setIconOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOffset is null")
+          }
+      }
+    }
+
+    fun setIconAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconAnchor is null")
+        }
+      } else {
+          layer.iconAnchor(IconAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconPitchAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconPitchAlignment is null")
+        }
+      } else {
+          layer.iconPitchAlignment(IconPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextPitchAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textPitchAlignment is null")
+        }
+      } else {
+          layer.textPitchAlignment(TextPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextRotationAlignment(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRotationAlignment(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRotationAlignment is null")
+        }
+      } else {
+          layer.textRotationAlignment(TextRotationAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextField(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textField(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textField is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.textField(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textField is null")
+          }
+      }
+    }
+
+    fun setTextFont(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textFont(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textFont is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textFont(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textFont is null")
+          }
+      }
+    }
+
+    fun setTextSize(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textSize(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textSize is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textSize(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textSize is null")
+          }
+      }
+    }
+
+    fun setTextMaxWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textMaxWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textMaxWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textMaxWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textMaxWidth is null")
+          }
+      }
+    }
+
+    fun setTextLineHeight(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textLineHeight(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textLineHeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textLineHeight(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textLineHeight is null")
+          }
+      }
+    }
+
+    fun setTextLetterSpacing(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textLetterSpacing(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textLetterSpacing is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textLetterSpacing(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textLetterSpacing is null")
+          }
+      }
+    }
+
+    fun setTextJustify(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textJustify(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textJustify is null")
+        }
+      } else {
+          layer.textJustify(TextJustify.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextRadialOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRadialOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRadialOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textRadialOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textRadialOffset is null")
+          }
+      }
+    }
+
+    fun setTextVariableAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textVariableAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textVariableAnchor is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textVariableAnchor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textVariableAnchor is null")
+          }
+      }
+    }
+
+    fun setTextAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textAnchor is null")
+        }
+      } else {
+          layer.textAnchor(TextAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextMaxAngle(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textMaxAngle(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textMaxAngle is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textMaxAngle(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textMaxAngle is null")
+          }
+      }
+    }
+
+    fun setTextWritingMode(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textWritingMode(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textWritingMode is null")
+        }
+      } else {
+          val value = styleValue.getStringArray(VALUE_KEY)
+          if (value != null) {
+            layer.textWritingMode(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textWritingMode is null")
+          }
+      }
+    }
+
+    fun setTextRotate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textRotate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textRotate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textRotate is null")
+          }
+      }
+    }
+
+    fun setTextPadding(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textPadding(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textPadding is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textPadding(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textPadding is null")
+          }
+      }
+    }
+
+    fun setTextKeepUpright(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textKeepUpright(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textKeepUpright is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textKeepUpright(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textKeepUpright is null")
+          }
+      }
+    }
+
+    fun setTextTransform(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTransform(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTransform is null")
+        }
+      } else {
+          layer.textTransform(TextTransform.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOffset is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.textOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOffset is null")
+          }
+      }
+    }
+
+    fun setTextAllowOverlap(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textAllowOverlap(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textAllowOverlap is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textAllowOverlap(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textAllowOverlap is null")
+          }
+      }
+    }
+
+    fun setTextIgnorePlacement(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textIgnorePlacement(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textIgnorePlacement is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textIgnorePlacement(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textIgnorePlacement is null")
+          }
+      }
+    }
+
+    fun setTextOptional(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOptional(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOptional is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.textOptional(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOptional is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setIconOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOpacity is null")
+          }
+      }
+    }
+
+
+    fun setIconOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconOpacityTransition(transition);
+      }
+    }
+
+    fun setIconColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.iconColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconColor is null")
+          }
+      }
+    }
+
+
+    fun setIconColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconColorTransition(transition);
+      }
+    }
+
+    fun setIconHaloColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloColor is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloColorTransition(transition);
+      }
+    }
+
+    fun setIconHaloWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloWidth is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloWidthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloWidthTransition(transition);
+      }
+    }
+
+    fun setIconHaloBlur(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconHaloBlur(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconHaloBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconHaloBlur(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconHaloBlur is null")
+          }
+      }
+    }
+
+
+    fun setIconHaloBlurTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconHaloBlurTransition(transition);
+      }
+    }
+
+    fun setIconTranslate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTranslate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.iconTranslate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconTranslate is null")
+          }
+      }
+    }
+
+
+    fun setIconTranslateTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconTranslateTransition(transition);
+      }
+    }
+
+    fun setIconTranslateAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconTranslateAnchor is null")
+        }
+      } else {
+          layer.iconTranslateAnchor(IconTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setTextOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOpacity is null")
+          }
+      }
+    }
+
+
+    fun setTextOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textOpacityTransition(transition);
+      }
+    }
+
+    fun setTextColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.textColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textColor is null")
+          }
+      }
+    }
+
+
+    fun setTextColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textColorTransition(transition);
+      }
+    }
+
+    fun setTextHaloColor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloColor(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloColor is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloColorTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloColorTransition(transition);
+      }
+    }
+
+    fun setTextHaloWidth(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloWidth(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloWidth(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloWidth is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloWidthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloWidthTransition(transition);
+      }
+    }
+
+    fun setTextHaloBlur(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textHaloBlur(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textHaloBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textHaloBlur(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textHaloBlur is null")
+          }
+      }
+    }
+
+
+    fun setTextHaloBlurTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textHaloBlurTransition(transition);
+      }
+    }
+
+    fun setTextTranslate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTranslate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.textTranslate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textTranslate is null")
+          }
+      }
+    }
+
+
+    fun setTextTranslateTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textTranslateTransition(transition);
+      }
+    }
+
+    fun setTextTranslateAnchor(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textTranslateAnchor is null")
+        }
+      } else {
+          layer.textTranslateAnchor(TextTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSymbolZElevate(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZElevate(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZElevate is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.symbolZElevate(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolZElevate is null")
+          }
+      }
+    }
+
+    fun setSymbolElevationReference(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolElevationReference(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolElevationReference is null")
+        }
+      } else {
+          layer.symbolElevationReference(SymbolElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setIconOcclusionOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setIconOcclusionOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setIconEmissiveStrength(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setIconEmissiveStrengthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.iconEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setTextEmissiveStrength(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setTextEmissiveStrengthTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setIconImageCrossFade(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconImageCrossFade(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconImageCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconImageCrossFade(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconImageCrossFade is null")
+          }
+      }
+    }
+
+    fun setTextOcclusionOpacity(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.textOcclusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for textOcclusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.textOcclusionOpacity(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for textOcclusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setTextOcclusionOpacityTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.textOcclusionOpacityTransition(transition);
+      }
+    }
+
+    fun setIconColorSaturation(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.iconColorSaturation(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for iconColorSaturation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.iconColorSaturation(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for iconColorSaturation is null")
+          }
+      }
+    }
+
+    fun setSymbolZOffset(layer: SymbolLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.symbolZOffset(expression)
+        } else {
+          Logger.e("RNMBXSymbol", "Expression for symbolZOffset is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.symbolZOffset(value)
+          } else {
+            Logger.e("RNMBXSymbol", "value for symbolZOffset is null")
+          }
+      }
+    }
+
+
+    fun setSymbolZOffsetTransition(layer: SymbolLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.symbolZOffsetTransition(transition);
+      }
+    }
+
+    fun setCircleSortKey(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleSortKey(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleSortKey is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleSortKey(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleSortKey is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setCircleRadius(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleRadius(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleRadius(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleRadius is null")
+          }
+      }
+    }
+
+
+    fun setCircleRadiusTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleRadiusTransition(transition);
+      }
+    }
+
+    fun setCircleColor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleColor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.circleColor(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleColor is null")
+          }
+      }
+    }
+
+
+    fun setCircleColorTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleColorTransition(transition);
+      }
+    }
+
+    fun setCircleBlur(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleBlur(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleBlur is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleBlur(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleBlur is null")
+          }
+      }
+    }
+
+
+    fun setCircleBlurTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleBlurTransition(transition);
+      }
+    }
+
+    fun setCircleOpacity(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleOpacity(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleOpacity(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleOpacity is null")
+          }
+      }
+    }
+
+
+    fun setCircleOpacityTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleOpacityTransition(transition);
+      }
+    }
+
+    fun setCircleTranslate(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleTranslate(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.circleTranslate(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleTranslate is null")
+          }
+      }
+    }
+
+
+    fun setCircleTranslateTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleTranslateTransition(transition);
+      }
+    }
+
+    fun setCircleTranslateAnchor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleTranslateAnchor is null")
+        }
+      } else {
+          layer.circleTranslateAnchor(CircleTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCirclePitchScale(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circlePitchScale(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circlePitchScale is null")
+        }
+      } else {
+          layer.circlePitchScale(CirclePitchScale.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCirclePitchAlignment(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circlePitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circlePitchAlignment is null")
+        }
+      } else {
+          layer.circlePitchAlignment(CirclePitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCircleStrokeWidth(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeWidth(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeWidth(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeWidth is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeWidthTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeWidthTransition(transition);
+      }
+    }
+
+    fun setCircleStrokeColor(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeColor(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeColor(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeColor is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeColorTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeColorTransition(transition);
+      }
+    }
+
+    fun setCircleStrokeOpacity(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleStrokeOpacity(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleStrokeOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleStrokeOpacity(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleStrokeOpacity is null")
+          }
+      }
+    }
+
+
+    fun setCircleStrokeOpacityTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleStrokeOpacityTransition(transition);
+      }
+    }
+
+    fun setCircleElevationReference(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleElevationReference(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleElevationReference is null")
+        }
+      } else {
+          layer.circleElevationReference(CircleElevationReference.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setCircleEmissiveStrength(layer: CircleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.circleEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXCircle", "Expression for circleEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.circleEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXCircle", "value for circleEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setCircleEmissiveStrengthTransition(layer: CircleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.circleEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setHeatmapRadius(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapRadius(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapRadius(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapRadius is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapRadiusTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapRadiusTransition(transition);
+      }
+    }
+
+    fun setHeatmapWeight(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapWeight(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapWeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapWeight(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapWeight is null")
+          }
+      }
+    }
+
+    fun setHeatmapIntensity(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapIntensity(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapIntensity(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapIntensity is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapIntensityTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapIntensityTransition(transition);
+      }
+    }
+
+    fun setHeatmapColor(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapColor(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapColor is null")
+        }
+      } else {
+          layer.heatmapColor(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setHeatmapOpacity(layer: HeatmapLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.heatmapOpacity(expression)
+        } else {
+          Logger.e("RNMBXHeatmap", "Expression for heatmapOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.heatmapOpacity(value)
+          } else {
+            Logger.e("RNMBXHeatmap", "value for heatmapOpacity is null")
+          }
+      }
+    }
+
+
+    fun setHeatmapOpacityTransition(layer: HeatmapLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.heatmapOpacityTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setFillExtrusionEdgeRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionEdgeRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionEdgeRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionEdgeRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionEdgeRadius is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionOpacity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionOpacity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionOpacity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionOpacity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionOpacityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionOpacityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionColor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionColor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionColor(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionColor is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionColorTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionColorTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionTranslate(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionTranslate(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionTranslate is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionTranslate(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionTranslate is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionTranslateTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionTranslateTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionTranslateAnchor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionTranslateAnchor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionTranslateAnchor is null")
+        }
+      } else {
+          layer.fillExtrusionTranslateAnchor(FillExtrusionTranslateAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionPattern(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.fillExtrusionPattern(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "Image for fillExtrusionPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.fillExtrusionPattern(expression)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.fillExtrusionPattern(value);
+        } else {
+          Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPattern is null")
+        }
+      }
+    }
+
+    fun setFillExtrusionHeight(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionHeight(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeight is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionHeight(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionHeight is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionHeightTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionHeightTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionBase(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionBase(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBase is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionBase(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionBase is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionBaseTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionBaseTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionVerticalGradient(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionVerticalGradient(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionVerticalGradient is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionVerticalGradient(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionVerticalGradient is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionIntensity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionIntensity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionIntensity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionIntensity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionIntensityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionIntensityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionRoundedRoof(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionRoundedRoof(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionRoundedRoof is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionRoundedRoof(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionRoundedRoof is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionPatternCrossFade(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionPatternCrossFade(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionPatternCrossFade is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionPatternCrossFade(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionPatternCrossFade is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionHeightAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionHeightAlignment(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionHeightAlignment is null")
+        }
+      } else {
+          layer.fillExtrusionHeightAlignment(FillExtrusionHeightAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionBaseAlignment(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionBaseAlignment(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionBaseAlignment is null")
+        }
+      } else {
+          layer.fillExtrusionBaseAlignment(FillExtrusionBaseAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionWallRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionWallRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionWallRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionWallRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionWallRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionWallRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionGroundRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionGroundRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionGroundRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionGroundRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionGroundRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionGroundRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionGroundRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionAmbientOcclusionGroundAttenuation(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionAmbientOcclusionGroundAttenuation(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionAmbientOcclusionGroundAttenuation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionAmbientOcclusionGroundAttenuation(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionAmbientOcclusionGroundAttenuation is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionAmbientOcclusionGroundAttenuationTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionAmbientOcclusionGroundAttenuationTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightColor(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightColor(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightColor(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightColor is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightColorTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightColorTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightIntensity(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightIntensity(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightIntensity(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightIntensity is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightIntensityTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightIntensityTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightWallRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightWallRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightWallRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightWallRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightWallRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightWallRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightWallRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightGroundRadius(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightGroundRadius(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightGroundRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightGroundRadius(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightGroundRadius is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightGroundRadiusTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightGroundRadiusTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionFloodLightGroundAttenuation(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionFloodLightGroundAttenuation(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionFloodLightGroundAttenuation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionFloodLightGroundAttenuation(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionFloodLightGroundAttenuation is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionFloodLightGroundAttenuationTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionFloodLightGroundAttenuationTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionVerticalScale(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionVerticalScale(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionVerticalScale is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionVerticalScale(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionVerticalScale is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionVerticalScaleTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionVerticalScaleTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionCutoffFadeRange(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionCutoffFadeRange(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionCutoffFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionCutoffFadeRange(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionCutoffFadeRange is null")
+          }
+      }
+    }
+
+    fun setFillExtrusionEmissiveStrength(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionEmissiveStrengthTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setFillExtrusionLineWidth(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.fillExtrusionLineWidth(expression)
+        } else {
+          Logger.e("RNMBXFillExtrusion", "Expression for fillExtrusionLineWidth is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.fillExtrusionLineWidth(value)
+          } else {
+            Logger.e("RNMBXFillExtrusion", "value for fillExtrusionLineWidth is null")
+          }
+      }
+    }
+
+
+    fun setFillExtrusionLineWidthTransition(layer: FillExtrusionLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.fillExtrusionLineWidthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setRasterOpacity(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterOpacity(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterOpacity(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterOpacity is null")
+          }
+      }
+    }
+
+
+    fun setRasterOpacityTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterOpacityTransition(transition);
+      }
+    }
+
+    fun setRasterHueRotate(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterHueRotate(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterHueRotate is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterHueRotate(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterHueRotate is null")
+          }
+      }
+    }
+
+
+    fun setRasterHueRotateTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterHueRotateTransition(transition);
+      }
+    }
+
+    fun setRasterBrightnessMin(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterBrightnessMin(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterBrightnessMin is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterBrightnessMin(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterBrightnessMin is null")
+          }
+      }
+    }
+
+
+    fun setRasterBrightnessMinTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterBrightnessMinTransition(transition);
+      }
+    }
+
+    fun setRasterBrightnessMax(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterBrightnessMax(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterBrightnessMax is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterBrightnessMax(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterBrightnessMax is null")
+          }
+      }
+    }
+
+
+    fun setRasterBrightnessMaxTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterBrightnessMaxTransition(transition);
+      }
+    }
+
+    fun setRasterSaturation(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterSaturation(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterSaturation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterSaturation(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterSaturation is null")
+          }
+      }
+    }
+
+
+    fun setRasterSaturationTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterSaturationTransition(transition);
+      }
+    }
+
+    fun setRasterContrast(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterContrast(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterContrast is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterContrast(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterContrast is null")
+          }
+      }
+    }
+
+
+    fun setRasterContrastTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterContrastTransition(transition);
+      }
+    }
+
+    fun setRasterResampling(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterResampling(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterResampling is null")
+        }
+      } else {
+          layer.rasterResampling(RasterResampling.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setRasterFadeDuration(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterFadeDuration(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterFadeDuration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterFadeDuration(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterFadeDuration is null")
+          }
+      }
+    }
+
+    fun setRasterColor(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColor(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColor(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColor is null")
+          }
+      }
+    }
+
+    fun setRasterColorMix(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColorMix(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColorMix is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColorMix(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColorMix is null")
+          }
+      }
+    }
+
+
+    fun setRasterColorMixTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterColorMixTransition(transition);
+      }
+    }
+
+    fun setRasterColorRange(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterColorRange(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterColorRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.rasterColorRange(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterColorRange is null")
+          }
+      }
+    }
+
+
+    fun setRasterColorRangeTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterColorRangeTransition(transition);
+      }
+    }
+
+    fun setRasterEmissiveStrength(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setRasterEmissiveStrengthTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setRasterArrayBand(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterArrayBand(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterArrayBand is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.rasterArrayBand(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterArrayBand is null")
+          }
+      }
+    }
+
+    fun setRasterElevation(layer: RasterLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterElevation(expression)
+        } else {
+          Logger.e("RNMBXRaster", "Expression for rasterElevation is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterElevation(value)
+          } else {
+            Logger.e("RNMBXRaster", "value for rasterElevation is null")
+          }
+      }
+    }
+
+
+    fun setRasterElevationTransition(layer: RasterLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterElevationTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setRasterParticleArrayBand(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleArrayBand(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleArrayBand is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleArrayBand(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleArrayBand is null")
+          }
+      }
+    }
+
+    fun setRasterParticleCount(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleCount(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleCount is null")
+        }
+      } else {
+          val value = styleValue.getLong(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleCount(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleCount is null")
+          }
+      }
+    }
+
+    fun setRasterParticleColor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleColor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleColor is null")
+        }
+      } else {
+          layer.rasterParticleColor(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setRasterParticleMaxSpeed(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleMaxSpeed(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleMaxSpeed is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleMaxSpeed(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleMaxSpeed is null")
+          }
+      }
+    }
+
+    fun setRasterParticleSpeedFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleSpeedFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleSpeedFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleSpeedFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleSpeedFactor is null")
+          }
+      }
+    }
+
+
+    fun setRasterParticleSpeedFactorTransition(layer: RasterParticleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterParticleSpeedFactorTransition(transition);
+      }
+    }
+
+    fun setRasterParticleFadeOpacityFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleFadeOpacityFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleFadeOpacityFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleFadeOpacityFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleFadeOpacityFactor is null")
+          }
+      }
+    }
+
+
+    fun setRasterParticleFadeOpacityFactorTransition(layer: RasterParticleLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rasterParticleFadeOpacityFactorTransition(transition);
+      }
+    }
+
+    fun setRasterParticleResetRateFactor(layer: RasterParticleLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.rasterParticleResetRateFactor(expression)
+        } else {
+          Logger.e("RNMBXRasterParticle", "Expression for rasterParticleResetRateFactor is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.rasterParticleResetRateFactor(value)
+          } else {
+            Logger.e("RNMBXRasterParticle", "value for rasterParticleResetRateFactor is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setHillshadeIlluminationDirection(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeIlluminationDirection(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeIlluminationDirection is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeIlluminationDirection(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeIlluminationDirection is null")
+          }
+      }
+    }
+
+    fun setHillshadeIlluminationAnchor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeIlluminationAnchor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeIlluminationAnchor is null")
+        }
+      } else {
+          layer.hillshadeIlluminationAnchor(HillshadeIlluminationAnchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setHillshadeExaggeration(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeExaggeration(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeExaggeration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeExaggeration(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeExaggeration is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeExaggerationTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeExaggerationTransition(transition);
+      }
+    }
+
+    fun setHillshadeShadowColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeShadowColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeShadowColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeShadowColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeShadowColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeShadowColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeShadowColorTransition(transition);
+      }
+    }
+
+    fun setHillshadeHighlightColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeHighlightColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeHighlightColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeHighlightColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeHighlightColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeHighlightColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeHighlightColorTransition(transition);
+      }
+    }
+
+    fun setHillshadeAccentColor(layer: HillshadeLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.hillshadeAccentColor(expression)
+        } else {
+          Logger.e("RNMBXHillshade", "Expression for hillshadeAccentColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.hillshadeAccentColor(value)
+          } else {
+            Logger.e("RNMBXHillshade", "value for hillshadeAccentColor is null")
+          }
+      }
+    }
+
+
+    fun setHillshadeAccentColorTransition(layer: HillshadeLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.hillshadeAccentColorTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setModelId(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelId(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelId is null")
+        }
+      } else {
+          val value = styleValue.getString(VALUE_KEY)
+          if (value != null) {
+            layer.modelId(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelId is null")
+          }
+      }
+    }
+
+    fun setModelOpacity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelOpacity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelOpacity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelOpacity is null")
+          }
+      }
+    }
+
+
+    fun setModelOpacityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelOpacityTransition(transition);
+      }
+    }
+
+    fun setModelRotation(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelRotation(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelRotation is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelRotation(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelRotation is null")
+          }
+      }
+    }
+
+
+    fun setModelRotationTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelRotationTransition(transition);
+      }
+    }
+
+    fun setModelScale(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelScale(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelScale is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelScale(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelScale is null")
+          }
+      }
+    }
+
+
+    fun setModelScaleTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelScaleTransition(transition);
+      }
+    }
+
+    fun setModelTranslation(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelTranslation(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelTranslation is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelTranslation(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelTranslation is null")
+          }
+      }
+    }
+
+
+    fun setModelTranslationTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelTranslationTransition(transition);
+      }
+    }
+
+    fun setModelColor(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelColor(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.modelColor(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelColor is null")
+          }
+      }
+    }
+
+
+    fun setModelColorTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelColorTransition(transition);
+      }
+    }
+
+    fun setModelColorMixIntensity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelColorMixIntensity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelColorMixIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelColorMixIntensity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelColorMixIntensity is null")
+          }
+      }
+    }
+
+
+    fun setModelColorMixIntensityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelColorMixIntensityTransition(transition);
+      }
+    }
+
+    fun setModelType(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelType(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelType is null")
+        }
+      } else {
+          layer.modelType(ModelType.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setModelCastShadows(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelCastShadows(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelCastShadows is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.modelCastShadows(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelCastShadows is null")
+          }
+      }
+    }
+
+    fun setModelReceiveShadows(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelReceiveShadows(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelReceiveShadows is null")
+        }
+      } else {
+          val value = styleValue.getBoolean(VALUE_KEY)
+          if (value != null) {
+            layer.modelReceiveShadows(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelReceiveShadows is null")
+          }
+      }
+    }
+
+    fun setModelAmbientOcclusionIntensity(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelAmbientOcclusionIntensity(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelAmbientOcclusionIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelAmbientOcclusionIntensity(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelAmbientOcclusionIntensity is null")
+          }
+      }
+    }
+
+
+    fun setModelAmbientOcclusionIntensityTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelAmbientOcclusionIntensityTransition(transition);
+      }
+    }
+
+    fun setModelEmissiveStrength(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setModelEmissiveStrengthTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setModelRoughness(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelRoughness(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelRoughness is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelRoughness(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelRoughness is null")
+          }
+      }
+    }
+
+
+    fun setModelRoughnessTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelRoughnessTransition(transition);
+      }
+    }
+
+    fun setModelHeightBasedEmissiveStrengthMultiplier(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelHeightBasedEmissiveStrengthMultiplier(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelHeightBasedEmissiveStrengthMultiplier is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.modelHeightBasedEmissiveStrengthMultiplier(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelHeightBasedEmissiveStrengthMultiplier is null")
+          }
+      }
+    }
+
+
+    fun setModelHeightBasedEmissiveStrengthMultiplierTransition(layer: ModelLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.modelHeightBasedEmissiveStrengthMultiplierTransition(transition);
+      }
+    }
+
+    fun setModelCutoffFadeRange(layer: ModelLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.modelCutoffFadeRange(expression)
+        } else {
+          Logger.e("RNMBXModel", "Expression for modelCutoffFadeRange is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.modelCutoffFadeRange(value)
+          } else {
+            Logger.e("RNMBXModel", "value for modelCutoffFadeRange is null")
+          }
+      }
+    }
+
+    fun setVisibility(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setBackgroundColor(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundColor(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundColor(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundColor is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundColorTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundColorTransition(transition);
+      }
+    }
+
+    fun setBackgroundPattern(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        if (styleValue.isImageStringValue) {
+          val value = styleValue.getImageStringValue()
+          if (value != null) {
+            layer.backgroundPattern(value)
+          } else {
+            Logger.e("RNMBXBackground", "Image for backgroundPattern is null")
+          }
+        } else {
+          val expression = styleValue.getExpression()
+          if (expression != null) {
+            layer.backgroundPattern(expression)
+          } else {
+            Logger.e("RNMBXBackground", "Expression for backgroundPattern is null")
+          }
+        }
+      } else {
+        val value = styleValue.imageURI
+        if (value != null) {
+          layer.backgroundPattern(value);
+        } else {
+          Logger.e("RNMBXBackground", "value for backgroundPattern is null")
+        }
+      }
+    }
+
+    fun setBackgroundOpacity(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundOpacity(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundOpacity(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundOpacity is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundOpacityTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundOpacityTransition(transition);
+      }
+    }
+
+    fun setBackgroundPitchAlignment(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundPitchAlignment(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundPitchAlignment is null")
+        }
+      } else {
+          layer.backgroundPitchAlignment(BackgroundPitchAlignment.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setBackgroundEmissiveStrength(layer: BackgroundLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.backgroundEmissiveStrength(expression)
+        } else {
+          Logger.e("RNMBXBackground", "Expression for backgroundEmissiveStrength is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.backgroundEmissiveStrength(value)
+          } else {
+            Logger.e("RNMBXBackground", "value for backgroundEmissiveStrength is null")
+          }
+      }
+    }
+
+
+    fun setBackgroundEmissiveStrengthTransition(layer: BackgroundLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.backgroundEmissiveStrengthTransition(transition);
+      }
+    }
+
+    fun setVisibility(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+        layer.visibility(Visibility.valueOf(styleValue.getEnumName()));
+    }
+
+    fun setSkyType(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyType(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyType is null")
+        }
+      } else {
+          layer.skyType(SkyType.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setSkyAtmosphereSun(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereSun(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereSun is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereSun(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereSun is null")
+          }
+      }
+    }
+
+    fun setSkyAtmosphereSunIntensity(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereSunIntensity(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereSunIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereSunIntensity(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereSunIntensity is null")
+          }
+      }
+    }
+
+    fun setSkyGradientCenter(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradientCenter(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradientCenter is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.skyGradientCenter(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyGradientCenter is null")
+          }
+      }
+    }
+
+    fun setSkyGradientRadius(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradientRadius(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradientRadius is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyGradientRadius(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyGradientRadius is null")
+          }
+      }
+    }
+
+    fun setSkyGradient(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyGradient(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyGradient is null")
+        }
+      } else {
+          layer.skyGradient(styleValue.getIntExpression(VALUE_KEY))
+      }
+    }
+
+    fun setSkyAtmosphereHaloColor(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereHaloColor(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereHaloColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereHaloColor(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereHaloColor is null")
+          }
+      }
+    }
+
+    fun setSkyAtmosphereColor(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyAtmosphereColor(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyAtmosphereColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.skyAtmosphereColor(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyAtmosphereColor is null")
+          }
+      }
+    }
+
+    fun setSkyOpacity(layer: SkyLayer, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.skyOpacity(expression)
+        } else {
+          Logger.e("RNMBXSky", "Expression for skyOpacity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.skyOpacity(value)
+          } else {
+            Logger.e("RNMBXSky", "value for skyOpacity is null")
+          }
+      }
+    }
+
+
+    fun setSkyOpacityTransition(layer: SkyLayer, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.skyOpacityTransition(transition);
+      }
+    }
+
+    fun setAnchor(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.anchor(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for anchor is null")
+        }
+      } else {
+          layer.anchor(Anchor.valueOf(styleValue.getEnumName()))
+      }
+    }
+
+    fun setPosition(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.position(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for position is null")
+        }
+      } else {
+          layer.position(styleValue.getLightPosition())
+      }
+    }
+
+
+    fun setPositionTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.positionTransition(transition);
+      }
+    }
+
+    fun setColor(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.color(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for color is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.color(value)
+          } else {
+            Logger.e("RNMBXLight", "value for color is null")
+          }
+      }
+    }
+
+
+    fun setColorTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.colorTransition(transition);
+      }
+    }
+
+    fun setIntensity(layer: Light, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.intensity(expression)
+        } else {
+          Logger.e("RNMBXLight", "Expression for intensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.intensity(value)
+          } else {
+            Logger.e("RNMBXLight", "value for intensity is null")
+          }
+      }
+    }
+
+
+    fun setIntensityTransition(layer: Light, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.intensityTransition(transition);
+      }
+    }
+
+    fun setRange(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.range(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for range is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.range(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for range is null")
+          }
+      }
+    }
+
+
+    fun setRangeTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.rangeTransition(transition);
+      }
+    }
+
+    fun setColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.color(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for color is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.color(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for color is null")
+          }
+      }
+    }
+
+
+    fun setColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.colorTransition(transition);
+      }
+    }
+
+    fun setHighColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.highColor(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for highColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.highColor(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for highColor is null")
+          }
+      }
+    }
+
+
+    fun setHighColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.highColorTransition(transition);
+      }
+    }
+
+    fun setSpaceColor(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.spaceColor(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for spaceColor is null")
+        }
+      } else {
+          val value = styleValue.getInt(VALUE_KEY)
+          if (value != null) {
+            layer.spaceColor(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for spaceColor is null")
+          }
+      }
+    }
+
+
+    fun setSpaceColorTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.spaceColorTransition(transition);
+      }
+    }
+
+    fun setHorizonBlend(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.horizonBlend(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for horizonBlend is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.horizonBlend(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for horizonBlend is null")
+          }
+      }
+    }
+
+
+    fun setHorizonBlendTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.horizonBlendTransition(transition);
+      }
+    }
+
+    fun setStarIntensity(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.starIntensity(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for starIntensity is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.starIntensity(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for starIntensity is null")
+          }
+      }
+    }
+
+
+    fun setStarIntensityTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.starIntensityTransition(transition);
+      }
+    }
+
+    fun setVerticalRange(layer: Atmosphere, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.verticalRange(expression)
+        } else {
+          Logger.e("RNMBXAtmosphere", "Expression for verticalRange is null")
+        }
+      } else {
+          val value = styleValue.getFloatArray(VALUE_KEY)
+          if (value != null) {
+            layer.verticalRange(value)
+          } else {
+            Logger.e("RNMBXAtmosphere", "value for verticalRange is null")
+          }
+      }
+    }
+
+
+    fun setVerticalRangeTransition(layer: Atmosphere, styleValue: RNMBXStyleValue) {
+      val transition = styleValue.transition
+      if (transition != null) {
+        layer.verticalRangeTransition(transition);
+      }
+    }
+
+    fun setExaggeration(layer: Terrain, styleValue: RNMBXStyleValue ) {
+      if (styleValue.isExpression()) {
+        val expression = styleValue.getExpression()
+        if (expression != null) {
+          layer.exaggeration(expression)
+        } else {
+          Logger.e("RNMBXTerrain", "Expression for exaggeration is null")
+        }
+      } else {
+          val value = styleValue.getDouble(VALUE_KEY)
+          if (value != null) {
+            layer.exaggeration(value)
+          } else {
+            Logger.e("RNMBXTerrain", "value for exaggeration is null")
+          }
+      }
+    }
+
+}
